/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/API/API.swift:
    1|       |//
    2|       |//  API.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/27.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Alamofire
   10|       |
   11|       |class API {
   12|      0|    static var shared: API = {
   13|      0|        let configuration = URLSessionConfiguration.af.default
   14|      0|        configuration.timeoutIntervalForRequest = 1
   15|      0|        configuration.waitsForConnectivity = true
   16|      0|        let logger = APIEventMonitor()
   17|      0|        let interceptor = APIInterceptor(storage: APITokenStorage())
   18|      0|        let session = Session(configuration: configuration, interceptor: interceptor, eventMonitors: [logger])
   19|      0|        return API(session: session)
   20|      0|    }()
   21|       |    private let session: Session
   22|       |    
   23|      0|    private init(session: Session) {
   24|      0|        self.session = session
   25|      0|    }
   26|       |    
   27|      0|    func request<T:Decodable>(_ model: APIModel, responseModel: T.Type, completion: @escaping (Result<T, AFError>?) -> Void) {
   28|      0|        session.request(model)
   29|      0|            .validate()
   30|      0|            .responseJSON { response in
   31|      0|                let decoder = JSONDecoder()
   32|      0|                decoder.keyDecodingStrategy = .convertFromSnakeCase
   33|      0|                if let data = response.data,
   34|      0|                   let json = try? decoder.decode(T.self, from: data) {
   35|      0|                    completion(.success(json))
   36|      0|                }else{
   37|      0|                    if let error = response.error {
   38|      0|                        completion(.failure(error))
   39|      0|                    }else{
   40|      0|                        completion(nil)
   41|      0|                    }
   42|      0|                }
   43|      0|            }
   44|      0|    }
   45|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/API/APIEventMonitor.swift:
    1|       |//
    2|       |//  APIEventMonitor.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/28.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Alamofire
   10|       |
   11|       |class APIEventMonitor: EventMonitor {
   12|      0|    func requestDidFinish(_ request: Request) {
   13|      0|        let header = request.request.flatMap { $0.allHTTPHeaderFields } ?? ["None": "None"]
   14|      0|        let body = request.request.flatMap { $0.httpBody.map { String(decoding: $0, as: UTF8.self) } } ?? "None"
   15|      0|        let message = """
   16|      0|        ‚ö°Ô∏è Request Started: \(request)
   17|      0|        ‚ö°Ô∏è Header Data: \(header)
   18|      0|        ‚ö°Ô∏è Body Data: \(body)
   19|      0|        """
   20|      0|        print(message)
   21|      0|    }
   22|       |    
   23|      0|    func request<Value>(_ request: DataRequest, didParseResponse response: DataResponse<Value, AFError>) {
   24|      0|        print("üôã‚Äç‚ôÇÔ∏è Response\n\(response.debugDescription)")
   25|      0|    }
   26|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/API/APIInterceptor.swift:
    1|       |//
    2|       |//  APIInterceptor.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Alamofire
   10|       |
   11|       |protocol TokenStorage {
   12|       |    var accessToken: String? { get set }
   13|       |    var refreshToken: String? { get set }
   14|       |}
   15|       |
   16|       |class APIInterceptor: RequestInterceptor {
   17|       |    public let storage: TokenStorage
   18|       |    
   19|      0|    init(storage: TokenStorage) {
   20|      0|        self.storage = storage
   21|      0|    }
   22|       |    
   23|      0|    func retry(_ request: Request, for session: Session, dueTo error: Error, completion: @escaping (RetryResult) -> Void) {
   24|      0|        if let statusCode = request.response?.statusCode {
   25|      0|            if statusCode == 401 {
   26|      0|                print("refresh!")
   27|      0|            }
   28|      0|        }
   29|      0|        completion(.doNotRetry)
   30|      0|    }
   31|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/API/APIModel.swift:
    1|       |//
    2|       |//  APIModel.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/27.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Alamofire
   10|       |
   11|       |enum APIModel: URLRequestConvertible {
   12|       |    
   13|       |    /** Auth */
   14|       |    case postAuth(_ request: PostAuthRequest)
   15|       |    
   16|       |    /** User */
   17|       |    case getUser(uuid: String)
   18|       |    case postUser(_ request: PostUsersRequest)
   19|       |    case getUserProfile(uuid: String)
   20|       |    
   21|       |    /** Group */
   22|       |    case postGroups
   23|       |    
   24|       |    // MARK: - HTTPMethod
   25|      0|    private var method: HTTPMethod {
   26|      0|        switch self {
   27|      0|        case .getUser,
   28|      0|             .getUserProfile:
   29|      0|            return .get
   30|      0|        case .postUser(_),
   31|      0|             .postAuth(_),
   32|      0|             .postGroups:
   33|      0|            return .post
   34|      0|        }
   35|      0|    }
   36|       |    
   37|       |    // MARK: - Path
   38|      0|    private var path: String {
   39|      0|        switch self {
   40|      0|        /** User */
   41|      0|        case .getUser(let uuid):
   42|      0|            return "/users/\(uuid)"
   43|      0|        case .getUserProfile(let uuid):
   44|      0|            return "/users/\(uuid)/profile"
   45|      0|        case .postUser(_):
   46|      0|            return "/users"
   47|      0|            
   48|      0|        /** Auth */
   49|      0|        case .postAuth(_):
   50|      0|            return "/auth"
   51|      0|            
   52|      0|        /** Group */
   53|      0|        case .postGroups:
   54|      0|            return "/groups"
   55|      0|        }
   56|      0|    }
   57|       |    
   58|       |    // MARK: - Parameters
   59|      0|    private var parameters: Codable? {
   60|      0|        switch self {
   61|      0|        case .postUser(let param):
   62|      0|            return param
   63|      0|        case .postAuth(let param):
   64|      0|            return param
   65|      0|        case .getUser,
   66|      0|             .getUserProfile,
   67|      0|             .postGroups:
   68|      0|            return nil
   69|      0|        }
   70|      0|    }
   71|       |    
   72|      0|    var headers: HTTPHeaders {
   73|      0|        var commonHeaders: HTTPHeaders = [HTTPHeaderField.contentType.rawValue: ContentType.json.rawValue,
   74|      0|                                          HTTPHeaderField.acceptType.rawValue: ContentType.json.rawValue]
   75|      0|        switch self {
   76|      0|        case .getUser,
   77|      0|             .getUserProfile:
   78|      0|            if let accessToken = UserDefaults.standard.string(forKey: KeychainKey.accessToken.rawValue) {
   79|      0|                let value = "Bearer \(accessToken)"
   80|      0|                commonHeaders.add(name: HTTPHeaderField.authentication.rawValue, value: value)
   81|      0|            }
   82|      0|            return commonHeaders
   83|      0|        default:
   84|      0|            return commonHeaders
   85|      0|        }
   86|      0|    }
   87|       |    
   88|       |    
   89|      0|    func asURLRequest() throws -> URLRequest {
   90|      0|        let url = try "http://localhost:8000".asURL()
   91|      0|        var urlRequest = URLRequest(url: url.appendingPathComponent(path))
   92|      0|        
   93|      0|        // HTTP Method
   94|      0|        urlRequest.httpMethod = method.rawValue
   95|      0|        
   96|      0|        // Common Headers
   97|      0|        urlRequest.headers = headers
   98|      0|        
   99|      0|        // Parameters
  100|      0|        if let parameters = parameters, let json = parameters.asDictionary() {
  101|      0|            do {
  102|      0|                urlRequest.httpBody = try JSONSerialization.data(withJSONObject: json, options: [])
  103|      0|            } catch {
  104|      0|                throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
  105|      0|            }
  106|      0|        }
  107|      0|        
  108|      0|        return urlRequest
  109|      0|    }
  110|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/API/APITokenStorage.swift:
    1|       |//
    2|       |//  APITokenStorage.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |struct APITokenStorage: TokenStorage {
   11|      0|    var accessToken: String? = {
   12|      0|        return UserDefaults.standard.string(forKey: KeychainKey.accessToken.rawValue)
   13|      0|    }()
  ------------------
  | Unexecuted instantiation: $s6watsup15APITokenStorageV11accessTokenSSSgvpfi
  ------------------
  | Unexecuted instantiation: $s6watsup15APITokenStorageV11accessTokenSSSgvpfiAEyXEfU_
  ------------------
   14|       |    
   15|      0|    var refreshToken: String? = {
   16|      0|        return UserDefaults.standard.string(forKey: KeychainKey.refreshToken.rawValue)
   17|      0|    }()
  ------------------
  | Unexecuted instantiation: $s6watsup15APITokenStorageV12refreshTokenSSSgvpfi
  ------------------
  | Unexecuted instantiation: $s6watsup15APITokenStorageV12refreshTokenSSSgvpfiAEyXEfU_
  ------------------
   18|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/AppDelegate.swift:
    1|       |//
    2|       |//  AppDelegate.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/20.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |@main
   11|       |class AppDelegate: UIResponder, UIApplicationDelegate {
   12|       |
   13|       |    var window: UIWindow?
   14|       |
   15|      7|    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
   16|      7|        application.registerForRemoteNotifications()
   17|      7|        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { result, error in
   18|      7|            if !result {
   19|      0|                print("notification denied")
   20|      7|            }
   21|      7|            if let error = error {
   22|      0|                print(error.localizedDescription)
   23|      7|            }
   24|      7|        }
   25|      7|        
   26|      7|        if let uuid = UserDefaults.standard.string(forKey: UserDefaultsKey.uuid.rawValue) {
   27|      7|            window?.rootViewController = UIStoryboard(name: "TabBar", bundle: nil).instantiateInitialViewController()
   28|      7|        }
   29|      7|        return true
   30|      7|    }
   31|       |    
   32|      0|    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
   33|      0|        let deviceToken = deviceToken.map { String(format: "%02x", $0) }.joined()
   34|      0|        print("deviceToken: \(deviceToken)")
   35|      0|    }
   36|       |}
   37|       |

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Extensions/Encodable+Extension.swift:
    1|       |//
    2|       |//  Encodable+Extension.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/28.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |extension Encodable {
   11|      0|    func asDictionary() -> [String: Any]? {
   12|      0|        guard let data = try? JSONEncoder().encode(self) else { return nil }
   13|      0|        guard let dictionary = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any] else { return nil }
   14|      0|        return dictionary
   15|      0|    }
   16|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Extensions/UIButton+Extension.swift:
    1|       |//
    2|       |//  UIButton+Extension.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |extension UIButton {
   11|      7|    func roundedButton() {
   12|      7|        self.layer.cornerRadius = 10
   13|      7|        self.clipsToBounds = true
   14|      7|    }
   15|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Extensions/UIView+Extension.swift:
    1|       |//
    2|       |//  UIView+Extension.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |extension UIView {
   11|     14|    func roundedView(_ value: CGFloat? = 12) {
   12|     14|        self.layer.cornerRadius = value ?? 12
   13|     14|        self.clipsToBounds = true
   14|     14|    }
   15|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Auth/AuthJoinViewController.swift:
    1|       |//
    2|       |//  AuthJoinViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/28.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class AuthJoinViewController: UIViewController {
   11|       |
   12|       |    @IBOutlet weak var tfEmail: UITextField!
   13|       |    @IBOutlet weak var tfPassword: UITextField!
   14|       |    
   15|      0|    override func viewDidLoad() {
   16|      0|        super.viewDidLoad()
   17|      0|
   18|      0|        // Do any additional setup after loading the view.
   19|      0|    }
   20|       |    
   21|      0|    @IBAction func onClickJoin(_ sender: UIButton) {
   22|      0|        guard let email = tfEmail.text else {
   23|      0|            return
   24|      0|        }
   25|      0|        guard let password = tfPassword.text else {
   26|      0|            return
   27|      0|        }
   28|      0|        
   29|      0|        let deviceToken = UserDefaults.standard.string(forKey: UserDefaultsKey.deviceToken.rawValue)
   30|      0|        let appVersion = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String
   31|      0|        
   32|      0|        let userData = PostUsersRequest(email: email,
   33|      0|                                        password: password,
   34|      0|                                        device_uuid: UUID().uuidString,
   35|      0|                                        device_token: deviceToken ?? "abc",
   36|      0|                                        os_type: OSType.iOS.rawValue,
   37|      0|                                        app_version: appVersion ?? "0")
   38|      0|        API.shared.request(.postUser(userData), responseModel: PostUsersResponse.self) { result in
   39|      0|            switch result {
   40|      0|            case .success(let data):
   41|      0|                print(data)
   42|      0|            case .failure(let error):
   43|      0|                print(error.localizedDescription)
   44|      0|            case .none:
   45|      0|                print("no result")
   46|      0|            }
   47|      0|        }
   48|      0|    }
   49|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Auth/AuthMainViewController.swift:
    1|       |//
    2|       |//  AuthMainViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/28.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class AuthMainViewController: UIViewController {
   11|       |
   12|      0|    override func viewDidLoad() {
   13|      0|        super.viewDidLoad()
   14|      0|
   15|      0|        // Do any additional setup after loading the view.
   16|      0|    }
   17|       |    
   18|       |
   19|       |    /*
   20|       |    // MARK: - Navigation
   21|       |
   22|       |    // In a storyboard-based application, you will often want to do a little preparation before navigation
   23|       |    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   24|       |        // Get the new view controller using segue.destination.
   25|       |        // Pass the selected object to the new view controller.
   26|       |    }
   27|       |    */
   28|       |
   29|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Auth/Login/AuthLoginViewController.swift:
    1|       |//
    2|       |//  AuthLoginViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/28.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class AuthLoginViewController: UIViewController {
   11|       |
   12|       |    @IBOutlet weak var tfEmail: UITextField!
   13|       |    @IBOutlet weak var tfPassword: UITextField!
   14|      0|    let viewModel = AuthLoginViewModel()
   15|       |    
   16|      0|    override func viewDidLoad() {
   17|      0|        super.viewDidLoad()
   18|      0|
   19|      0|        // Do any additional setup after loading the view.
   20|      0|    }
   21|       |    
   22|      0|    @IBAction func onClickLogin(_ sender: UIButton) {
   23|      0|        guard let email = tfEmail.text else {
   24|      0|            return
   25|      0|        }
   26|      0|        guard let password = tfPassword.text else {
   27|      0|            return
   28|      0|        }
   29|      0|        
   30|      0|        let userData = PostAuthRequest(email: email, password: password)
   31|      0|        API.shared.request(.postAuth(userData), responseModel: PostAuthResponse.self) { result in
   32|      0|            switch result {
   33|      0|            case .success(let data):
   34|      0|                if self.viewModel.addUser(data: data) {
   35|      0|                    self.goMain()
   36|      0|                }
   37|      0|            case .failure(let error):
   38|      0|                print(error.localizedDescription)
   39|      0|            case .none:
   40|      0|                print("no result")
   41|      0|            }
   42|      0|        }
   43|      0|    }
   44|       |    
   45|      0|    func goMain() {
   46|      0|        if let appDelegate = UIApplication.shared.delegate as? AppDelegate {
   47|      0|            appDelegate.window?.rootViewController = UIStoryboard(name: "TabBar", bundle: nil).instantiateInitialViewController()
   48|      0|            
   49|      0|        }
   50|      0|    }
   51|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Auth/Login/AuthLoginViewModel.swift:
    1|       |//
    2|       |//  AuthLoginViewModel.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |class AuthLoginViewModel {
   11|       |    /// write user data on db
   12|      0|    func addUser(data: PostAuthResponse) -> Bool {
   13|      0|        if let uuid = data.identity?.uuid {
   14|      0|            UserDefaults.standard.setValue(uuid, forKey: UserDefaultsKey.uuid.rawValue)
   15|      0|        }
   16|      0|        if let accessToken = data.accessToken {
   17|      0|            UserDefaults.standard.setValue(accessToken, forKey: KeychainKey.accessToken.rawValue)
   18|      0|        }
   19|      0|        if let refreshToken = data.refreshToken {
   20|      0|            UserDefaults.standard.setValue(refreshToken, forKey: KeychainKey.refreshToken.rawValue)
   21|      0|        }
   22|      0|        return true
   23|      0|    }
   24|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/Model/EmotionLog.swift:
    1|       |//
    2|       |//  EmotionModel.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/23.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |protocol EmotionLog {
   11|       |    var message: String? { get set }
   12|       |    var emotion: EmotionType { get set }
   13|       |    
   14|       |    init(message: String?, emotion: EmotionType)
   15|       |}
   16|       |
   17|       |class EmotionModel: EmotionLog {
   18|       |    var message: String?
   19|       |    
   20|       |    var emotion: EmotionType
   21|       |    
   22|      0|    required init(message: String?, emotion: EmotionType) {
   23|      0|        self.message = message
   24|      0|        self.emotion = emotion
   25|      0|    }
   26|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/ViewControllers/BaseViewController.swift:
    1|       |//
    2|       |//  BaseViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/22.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |import SnapKit
   10|       |
   11|       |class BaseViewController: UIViewController {
   12|       |
   13|      7|    override func viewDidLoad() {
   14|      7|        super.viewDidLoad()
   15|      7|
   16|      7|        // Do any additional setup after loading the view.
   17|      7|    }
   18|       |    
   19|      7|    func setKeyboardObserver() {
   20|      7|        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), name: UIResponder.keyboardWillShowNotification, object: nil)
   21|      7|        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide(_:)), name: UIResponder.keyboardWillHideNotification, object: nil)
   22|      7|    }
   23|       |
   24|       |    // MARK: - objc method
   25|      0|    @objc func keyboardWillShow(_ sender: NSNotification) {
   26|      0|    }
   27|       |
   28|      0|    @objc func keyboardWillHide(_ sender: NSNotification) {
   29|      0|    }
   30|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/ViewControllers/UserDetailViewController.swift:
    1|       |//
    2|       |//  UserDetailViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/21.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class UserDetailViewController: UIViewController {
   11|       |
   12|      0|    override func viewDidLoad() {
   13|      0|        super.viewDidLoad()
   14|      0|
   15|      0|        // Do any additional setup after loading the view.
   16|      0|    }
   17|       |
   18|       |
   19|       |    /*
   20|       |    // MARK: - Navigation
   21|       |
   22|       |    // In a storyboard-based application, you will often want to do a little preparation before navigation
   23|       |    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   24|       |        // Get the new view controller using segue.destination.
   25|       |        // Pass the selected object to the new view controller.
   26|       |    }
   27|       |    */
   28|       |
   29|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/Views/EmotionView.swift:
    1|       |//
    2|       |//  EmotionView.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/23.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class EmotionView: XibView {
   11|       |    
   12|       |    /// E1 < E2 < E3 ...
   13|       |    enum EmotionViewSize: Int {
   14|       |        /// Í∞ÄÏû• ÏûëÏùÄ ÏÇ¨Ïù¥Ï¶à
   15|       |        case E1 = 0
   16|       |        /// Ï§ëÍ∞Ñ ÏÇ¨Ïù¥Ï¶à
   17|       |        case E2
   18|       |        /// Í∞ÄÏû• ÌÅ∞ ÏÇ¨Ïù¥Ï¶à
   19|       |        case E3
   20|       |    }
   21|       |    
   22|       |    @IBOutlet weak var messageButton: UIButton!
   23|       |    @IBOutlet weak var emotionButton: UIButton!
   24|       |    
   25|      7|    required init?(coder: NSCoder) {
   26|      7|        super.init(coder: coder)
   27|      7|        
   28|      7|        if let view = instanceFrom(object: self) {
   29|      7|            view.frame = self.bounds
   30|      7|            self.addSubview(view)
   31|      7|            
   32|      7|            // default size
   33|      7|            setSize(.E2)
   34|      7|        }
   35|      7|    }
   36|       |    
   37|      0|    init(emotionLog: EmotionLog) {
   38|      0|        let randomX = Int.random(in: 0...Int(UIScreen.main.bounds.width))
   39|      0|        let randomY = Int.random(in: 0...Int(UIScreen.main.bounds.height))
   40|      0|        super.init(frame: CGRect(x: randomX, y: randomY, width: 100, height: 140))
   41|      0|        if let view = instanceFrom(object: self) {
   42|      0|            view.frame = self.bounds
   43|      0|            self.addSubview(view)
   44|      0|            
   45|      0|            // default size
   46|      0|            setSize(.E2)
   47|      0|        }
   48|      0|        set(emotionLog: emotionLog)
   49|      0|    }
   50|       |    
   51|       |    /// adjust font size & emotion icon size
   52|      7|    func setSize(_ size: EmotionViewSize) {
   53|      7|        let messageSize = CGFloat(15+(2*size.rawValue))
   54|      7|        messageButton.titleLabel?.font = .systemFont(ofSize: messageSize)
   55|      7|        
   56|      7|        let emotionSize = CGFloat(38+(10*size.rawValue))
   57|      7|        emotionButton.titleLabel?.font = .systemFont(ofSize: emotionSize)
   58|      7|    }
   59|       |    
   60|       |    /// set message & emotion on each buttons
   61|      0|    func set(emotionLog: EmotionLog) {
   62|      0|        if let message = emotionLog.message {
   63|      0|            messageButton.setTitle(message, for: .normal)
   64|      0|        }else{
   65|      0|            messageButton.isHidden = true
   66|      0|        }
   67|      0|        emotionButton.setTitle(emotionLog.emotion.rawValue, for: .normal)
   68|      0|    }
   69|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/Views/GradientView.swift:
    1|       |//
    2|       |//  GradientView.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |@IBDesignable
   11|       |
   12|       |class GradientView: UIView {
   13|      7|    @IBInspectable var firstColor: UIColor = UIColor.clear {
   14|      7|        didSet {
   15|      7|            updateView()
   16|      7|        }
   17|       |    }
   18|       |    
   19|      7|    @IBInspectable var secondColor: UIColor = UIColor.clear {
   20|      7|        didSet {
   21|      7|            updateView()
   22|      7|        }
   23|       |    }
   24|       |    
   25|       |    @IBInspectable var isHorizontal: Bool = true {
   26|      7|        didSet {
   27|      7|            updateView()
   28|      7|        }
   29|       |    }
   30|       |    
   31|       |    override class var layerClass: AnyClass {
   32|      7|        get {
   33|      7|            return CAGradientLayer.self
   34|      7|        }
   35|       |    }
   36|       |    
   37|     21|    func updateView() {
   38|     21|        if let layer = self.layer as? CAGradientLayer {
   39|     42|            layer.colors = [firstColor, secondColor].map{$0.cgColor}
   40|     21|            if isHorizontal {
   41|     14|                layer.startPoint = CGPoint(x: 0, y: 0.5)
   42|     14|                layer.endPoint = CGPoint (x: 1, y: 0.5)
   43|     21|            } else {
   44|      7|                layer.startPoint = CGPoint(x: 0.5, y: 0)
   45|      7|                layer.endPoint = CGPoint (x: 0.5, y: 1)
   46|     21|            }
   47|     21|        }
   48|     21|    }
   49|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/Views/SelectEmotionView.swift:
    1|       |//
    2|       |//  SelectEmotion.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/21.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class SelectEmotionView: XibView {
   11|       |    
   12|       |    @IBOutlet weak var emotionStack: UIStackView!
   13|       |    @IBOutlet weak var tfMessage: UITextField!
   14|       |    var emotion: EmotionType?
   15|       |    
   16|     14|    required init?(coder aDecoder: NSCoder) {
   17|     14|        super.init(coder: aDecoder)
   18|     14|        
   19|     14|        if let view = instanceFrom(object: self) {
   20|     14|            view.frame = self.bounds
   21|     14|            self.addSubview(view)
   22|     14|        }
   23|     14|    }
   24|       |    
   25|      0|    @IBAction func onClickEmotion(_ sender: UIButton) {
   26|      0|        emotionStack.subviews.forEach{
   27|      0|            ($0 as? UIButton)?.alpha = 0.2
   28|      0|            ($0 as? UIButton)?.isSelected = false
   29|      0|        }
   30|      0|        sender.alpha = 1
   31|      0|        sender.isSelected = true
   32|      0|        
   33|      0|        if let emotionText = sender.titleLabel?.text {
   34|      0|            emotion = EmotionType(rawValue: emotionText)
   35|      0|        }
   36|      0|    }
   37|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Common/Views/XibView.swift:
    1|       |//
    2|       |//  XibView.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/22.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class XibView: UIView {
   11|     35|    func instanceFrom(object: NSObject) -> UIView? {
   12|     35|        let nibName = String(describing: type(of: object))
   13|     35|        let bundle = Bundle(for: type(of: self))
   14|     35|        return UINib(nibName: nibName, bundle: bundle).instantiate(withOwner: object, options: nil).first as? UIView
   15|     35|    }
   16|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Group/GroupDetailViewController.swift:
    1|       |//
    2|       |//  GroupDetailViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/21.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class GroupDetailViewController: UIViewController {
   11|       |
   12|      0|    override func viewDidLoad() {
   13|      0|        super.viewDidLoad()
   14|      0|
   15|      0|        // Do any additional setup after loading the view.
   16|      0|    }
   17|       |    
   18|       |
   19|       |    /*
   20|       |    // MARK: - Navigation
   21|       |
   22|       |    // In a storyboard-based application, you will often want to do a little preparation before navigation
   23|       |    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   24|       |        // Get the new view controller using segue.destination.
   25|       |        // Pass the selected object to the new view controller.
   26|       |    }
   27|       |    */
   28|       |
   29|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Group/GroupListViewController.swift:
    1|       |//
    2|       |//  GroupListViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/21.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class GroupListViewController: UIViewController {
   11|       |    
   12|       |    enum Section: String, CaseIterable {
   13|       |        case invitedGroup
   14|       |        case joinedGroup
   15|       |    }
   16|       |
   17|       |    @IBOutlet weak var tableView: UITableView!
   18|       |    
   19|      0|    override func viewDidLoad() {
   20|      0|        super.viewDidLoad()
   21|      0|        tableView.delegate = self
   22|      0|        tableView.dataSource = self
   23|      0|        tableView.register(UINib(nibName: "GroupInvitedTableViewCell", bundle: nil), forCellReuseIdentifier: Section.invitedGroup.rawValue)
   24|      0|        tableView.register(UITableViewCell.self, forCellReuseIdentifier: Section.joinedGroup.rawValue)
   25|      0|        
   26|      0|        tableView.reloadData()
   27|      0|        API.shared.request(.postGroups, responseModel: PostGroupsResponse.self) { result in
   28|      0|            switch result {
   29|      0|            case .success(let data):
   30|      0|                print(data)
   31|      0|            case .failure(let error):
   32|      0|                print(error.localizedDescription)
   33|      0|            case .none:
   34|      0|                print("none")
   35|      0|            }
   36|      0|        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |extension GroupListViewController: UITableViewDelegate {
   41|      0|    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
   42|      0|        if section == 0 {
   43|      0|            return "Ï¥àÎåÄÎ∞õÏùÄ Í∑∏Î£π"
   44|      0|        }else{
   45|      0|            return "Ï∞∏Ïó¨ Ï§ëÏù∏ Í∑∏Î£π"
   46|      0|        }
   47|      0|    }
   48|       |    
   49|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   50|      0|        switch Section.allCases[indexPath.section] {
   51|      0|        case .invitedGroup:
   52|      0|            if let cell = tableView.dequeueReusableCell(withIdentifier: Section.invitedGroup.rawValue, for: indexPath) as? GroupInvitedTableViewCell {
   53|      0|                cell.backgroundColor = .clear
   54|      0|                return cell
   55|      0|            }else{
   56|      0|                let cell = tableView.dequeueReusableCell(withIdentifier: Section.invitedGroup.rawValue, for: indexPath)
   57|      0|                return cell
   58|      0|            }
   59|      0|        case .joinedGroup:
   60|      0|            let cell = tableView.dequeueReusableCell(withIdentifier: Section.joinedGroup.rawValue, for: indexPath)
   61|      0|            return cell
   62|      0|        }
   63|      0|    }
   64|       |    
   65|      0|    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
   66|      0|        return UITableView.automaticDimension
   67|      0|    }
   68|       |}
   69|       |
   70|       |extension GroupListViewController: UITableViewDataSource {
   71|      0|    func numberOfSections(in tableView: UITableView) -> Int {
   72|      0|        return Section.allCases.count
   73|      0|    }
   74|       |    
   75|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   76|      0|        switch Section.allCases[section] {
   77|      0|        case .invitedGroup:
   78|      0|            return 1
   79|      0|        case .joinedGroup:
   80|      0|            return 10
   81|      0|        }
   82|      0|    }
   83|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Group/Views/GroupInvitedCollectionViewCell.swift:
    1|       |//
    2|       |//  GroupInvitedCollectionViewCell.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class GroupInvitedCollectionViewCell: UICollectionViewCell {
   11|       |
   12|       |    @IBOutlet weak var profileImageView: UIImageView!
   13|       |    @IBOutlet weak var groupName: UILabel!
   14|       |    @IBOutlet weak var btnJoin: UIButton!
   15|       |    
   16|      0|    override func awakeFromNib() {
   17|      0|        super.awakeFromNib()
   18|      0|        profileImageView.roundedView(profileImageView.bounds.height/2)
   19|      0|    }
   20|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Group/Views/GroupInvitedTableViewCell.swift:
    1|       |//
    2|       |//  GroupInvitedTableViewCell.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class GroupInvitedTableViewCell: UITableViewCell {
   11|       |
   12|       |    @IBOutlet weak var collectionView: UICollectionView!
   13|       |    
   14|      0|    override func awakeFromNib() {
   15|      0|        super.awakeFromNib()
   16|      0|        
   17|      0|        collectionView.delegate = self
   18|      0|        collectionView.dataSource = self
   19|      0|        collectionView.register(UINib(nibName: "GroupInvitedCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "cell")
   20|      0|    }
   21|       |
   22|      0|    override func setSelected(_ selected: Bool, animated: Bool) {
   23|      0|        super.setSelected(selected, animated: animated)
   24|      0|
   25|      0|        // Configure the view for the selected state
   26|      0|    }
   27|       |}
   28|       |
   29|       |extension GroupInvitedTableViewCell: UICollectionViewDelegate {
   30|      0|    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   31|      0|        if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath) as? GroupInvitedCollectionViewCell {
   32|      0|            cell.roundedView(8)
   33|      0|            return cell
   34|      0|        }else{
   35|      0|            return collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)
   36|      0|        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |extension GroupInvitedTableViewCell: UICollectionViewDataSource {
   41|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   42|      0|        return 5
   43|      0|    }
   44|       |}
   45|       |
   46|       |extension GroupInvitedTableViewCell: UICollectionViewDelegateFlowLayout {
   47|      0|    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
   48|      0|        return CGSize(width: 122, height: 156)
   49|      0|    }
   50|      0|    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
   51|      0|        return 10
   52|      0|    }
   53|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Main/MainViewController.swift:
    1|       |//
    2|       |//  MainViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/21.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class MainViewController: BaseViewController {
   11|       |    
   12|       |    @IBOutlet weak var emotionRegisterView: EmotionRegisterView!
   13|       |    @IBOutlet weak var emotionRegisterViewBottom: NSLayoutConstraint!
   14|       |    @IBOutlet weak var randomEmotionView: RandomEmotionView!
   15|       |    
   16|      7|    override func viewDidLoad() {
   17|      7|        super.viewDidLoad()
   18|      7|
   19|      7|        emotionRegisterView.delegate = self
   20|      7|        
   21|      7|        randomEmotionView.frame = view.bounds
   22|      7|        randomEmotionView.myEmotionView.isHidden = true
   23|      7|        
   24|      7|        setKeyboardObserver()
   25|      7|    }
   26|       |    
   27|     14|    override func viewDidLayoutSubviews() {
   28|     14|        randomEmotionView.myEmotionView.center = randomEmotionView.center
   29|     14|        view.layoutIfNeeded()
   30|     14|        view.layoutSubviews()
   31|     14|    }
   32|       |    
   33|       |    // MARK: set
   34|       |    /// adjust view when keyboard shows up
   35|      0|    override func keyboardWillShow(_ sender: NSNotification) {
   36|      0|        if let keyboardFrame = sender.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue {
   37|      0|            UIView.animate(withDuration: 0.5) {
   38|      0|                self.emotionRegisterViewBottom.constant = keyboardFrame.cgRectValue.height
   39|      0|            }
   40|      0|        }
   41|      0|    }
   42|       |    
   43|       |    /// adjust view when keyboard hidden
   44|      0|    override func keyboardWillHide(_ sender: NSNotification) {
   45|      0|        UIView.animate(withDuration: 0.5) {
   46|      0|            self.emotionRegisterViewBottom.constant = 0
   47|      0|        }
   48|      0|    }
   49|       |}
   50|       |
   51|       |extension MainViewController: EmotionRegisterViewDelegate {
   52|      0|    func onClickRegisterEmotion(emotionLog: EmotionLog) {
   53|      0|        view.endEditing(true)
   54|      0|        
   55|      0|        UIView.animate(withDuration: 0.5) {
   56|      0|            self.emotionRegisterView.alpha = 0
   57|      0|        } completion: { _ in
   58|      0|            self.randomEmotionView.myEmotionView.isHidden = false
   59|      0|            self.randomEmotionView.myEmotionView.alpha = 0
   60|      0|            self.randomEmotionView.setMyEmotion(emotionLog: emotionLog)
   61|      0|            
   62|      0|            UIView.animate(withDuration: 0.5) {
   63|      0|                self.randomEmotionView.myEmotionView.alpha = 1
   64|      0|            }
   65|      0|            
   66|      0|            Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in
   67|      0|                let message = ["hello", "hi", "funny", "oh", "sad", "haha"].randomElement()
   68|      0|                let emotion = EmotionType.allCases.randomElement() ?? .crying
   69|      0|                let emotionLog = EmotionModel(message: message, emotion: emotion)
   70|      0|                self.randomEmotionView.addEmotion(emotionLog: emotionLog)
   71|      0|            }
   72|      0|        }
   73|      0|    }
   74|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Main/Views/EmotionRegisterView.swift:
    1|       |//
    2|       |//  EmotionRegisterView.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/23.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |protocol EmotionRegisterViewDelegate: class {
   11|       |    func onClickRegisterEmotion(emotionLog: EmotionLog)
   12|       |}
   13|       |
   14|       |class EmotionRegisterView: XibView {
   15|       | 
   16|       |    weak var delegate: EmotionRegisterViewDelegate?
   17|       |    
   18|       |    @IBOutlet weak var fakeContainer: UIVisualEffectView!
   19|       |    @IBOutlet weak var fakeSelectEmotionView: SelectEmotionView!
   20|       |    @IBOutlet weak var realSelectEmotionView: SelectEmotionView!
   21|       |    @IBOutlet weak var realContainer: UIVisualEffectView!
   22|       |    @IBOutlet weak var btnToggleReal: UIButton!
   23|       |    @IBOutlet weak var btnRegister: UIButton!
   24|       |    
   25|      7|    required init?(coder: NSCoder) {
   26|      7|        super.init(coder: coder)
   27|      7|        
   28|      7|        if let view = instanceFrom(object: self) {
   29|      7|            view.frame = self.bounds
   30|      7|            self.addSubview(view)
   31|      7|        }
   32|      7|        
   33|      7|        realContainer.alpha = 0
   34|      7|        realContainer.isHidden = true
   35|      7|        
   36|      7|        fakeSelectEmotionView.tfMessage.placeholder = "Ïò§Îäò Í∏∞Î∂Ñ Ïñ¥ÎïåÏöî?"
   37|      7|        realSelectEmotionView.tfMessage.placeholder = "ÏÇ¨Ïã§ÏùÄÏöî...."
   38|      7|        
   39|      7|        fakeContainer.roundedView()
   40|      7|        realContainer.roundedView()
   41|      7|        btnRegister.roundedButton()
   42|      7|    }
   43|       |    
   44|       |    // MARK: - IBActions
   45|      0|    @IBAction func onClickToggleRealContainer(_ sender: UIButton) {
   46|      0|        sender.isSelected = !sender.isSelected
   47|      0|        
   48|      0|        if sender.isSelected {
   49|      0|            UIView.animate(withDuration: 0.5) {
   50|      0|                self.realContainer.isHidden = false
   51|      0|            } completion: { bool in
   52|      0|                UIView.animate(withDuration: 0.5) {
   53|      0|                    self.realContainer.alpha = 1
   54|      0|                }
   55|      0|            }
   56|      0|        }else{
   57|      0|            UIView.animate(withDuration: 0.5) {
   58|      0|                self.realContainer.alpha = 0
   59|      0|            } completion: { bool in
   60|      0|                UIView.animate(withDuration: 0.5) {
   61|      0|                    self.realContainer.isHidden = true
   62|      0|                    
   63|      0|                }
   64|      0|            }
   65|      0|        }
   66|      0|    }
   67|       |    
   68|      0|    @IBAction func onClickRegisterEmotion(_ sender: UIButton) {
   69|      0|        let message = fakeSelectEmotionView.tfMessage.text
   70|      0|        if let emotion = fakeSelectEmotionView.emotion {
   71|      0|            let emotionLog = EmotionModel(message: message, emotion: emotion)
   72|      0|            delegate?.onClickRegisterEmotion(emotionLog: emotionLog)
   73|      0|        }else{
   74|      0|            print("no emotion selected")
   75|      0|        }
   76|      0|    }
   77|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Main/Views/RandomEmotionView.swift:
    1|       |//
    2|       |//  RandomEmotionView.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/23.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class RandomEmotionView: XibView {
   11|       |    
   12|       |    @IBOutlet weak var myEmotionView: EmotionView!
   13|       |    
   14|       |    /// emotions to be removed by timer
   15|      7|    var emotions = [EmotionView]()
   16|       |    var timer: Timer?
   17|       |    
   18|      7|    required init?(coder: NSCoder) {
   19|      7|        super.init(coder: coder)
   20|      7|        
   21|      7|        if let view = instanceFrom(object: self) {
   22|      7|            view.frame = self.bounds
   23|      7|            self.addSubview(view)
   24|      7|        }
   25|      7|        
   26|      7|        timer = Timer.scheduledTimer(withTimeInterval: 3, repeats: true) { timer in
   27|      0|            if let emotion = self.emotions.first {
   28|      0|                UIView.animate(withDuration: 0.5) {
   29|      0|                    self.myEmotionView.center = self.center
   30|      0|                    self.layoutIfNeeded()
   31|      0|                    self.layoutSubviews()
   32|      0|                    emotion.alpha = 0
   33|      0|                } completion: { _ in
   34|      0|                    self.emotions.removeFirst()
   35|      0|                    emotion.removeFromSuperview()
   36|      0|                    self.myEmotionView.center = self.center
   37|      0|                    self.layoutIfNeeded()
   38|      0|                    self.layoutSubviews()
   39|      0|                }
   40|      0|            }
   41|      0|        }
   42|      7|    }
   43|       |    
   44|      0|    deinit {
   45|      0|        timer?.invalidate()
   46|      0|    }
   47|       |    
   48|      0|    func setMyEmotion(emotionLog: EmotionLog) {
   49|      0|        myEmotionView.set(emotionLog: emotionLog)
   50|      0|        myEmotionView.backgroundColor = .darkGray
   51|      0|        self.addSubview(myEmotionView)
   52|      0|        myEmotionView.center = self.center
   53|      0|        self.layoutIfNeeded()
   54|      0|        self.layoutSubviews()
   55|      0|//        myEmotionView.translatesAutoresizingMaskIntoConstraints = true
   56|      0|    }
   57|       |    
   58|      0|    func addEmotion(emotionLog: EmotionLog) {
   59|      0|        let emotion = EmotionView(emotionLog: emotionLog)
   60|      0|        emotion.set(emotionLog: emotionLog)
   61|      0|        emotion.setSize(.E1)
   62|      0|        self.insertSubview(emotion, belowSubview: myEmotionView)
   63|      0|        myEmotionView.center = self.center
   64|      0|        self.layoutIfNeeded()
   65|      0|        self.layoutSubviews()
   66|      0|        emotions.append(emotion)
   67|      0|    }
   68|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Setting/SettingViewController.swift:
    1|       |//
    2|       |//  SettingViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class SettingViewController: UIViewController {
   11|       |    
   12|       |    enum Section: String, CaseIterable {
   13|       |        case myInfo
   14|       |        case setting
   15|       |    }
   16|       |    
   17|       |    enum MyInfoSection: String, CaseIterable {
   18|       |        case profile
   19|       |    }
   20|       |    
   21|       |    enum SettingSection: CaseIterable {
   22|       |        case emotion
   23|       |        case notification
   24|       |        case license
   25|       |        case version
   26|       |    }
   27|       |
   28|       |    @IBOutlet weak var tableView: UITableView!
   29|       |    
   30|       |    // MARK: - Life Cycle
   31|       |    
   32|      0|    override func viewDidLoad() {
   33|      0|        super.viewDidLoad()
   34|      0|        setTableView()
   35|      0|    }
   36|       |    
   37|      0|    override func viewWillAppear(_ animated: Bool) {
   38|      0|        super.viewWillAppear(animated)
   39|      0|        
   40|      0|        if let uuid = UserDefaults.standard.string(forKey: UserDefaultsKey.uuid.rawValue) {
   41|      0|            API.shared.request(.getUser(uuid: uuid), responseModel: GetUsersResponse.self) { result in
   42|      0|                switch result {
   43|      0|                case .success(let data):
   44|      0|                    print(data)
   45|      0|                case .failure(let error):
   46|      0|                    print(error.localizedDescription)
   47|      0|                case .none:
   48|      0|                    print("result none")
   49|      0|                }
   50|      0|            }
   51|      0|            
   52|      0|            API.shared.request(.getUserProfile(uuid: uuid), responseModel: GetUserProfileResponse.self) { result in
   53|      0|                switch result {
   54|      0|                case .success(let data):
   55|      0|                    print(data)
   56|      0|                case .failure(let error):
   57|      0|                    print(error.localizedDescription)
   58|      0|                case .none:
   59|      0|                    print("result none")
   60|      0|                }
   61|      0|            }
   62|      0|        }
   63|      0|    }
   64|       |    
   65|       |    // MARK: - Funcs
   66|      0|    func setTableView() {
   67|      0|        tableView.register(UITableViewCell.self, forCellReuseIdentifier: Section.setting.rawValue)
   68|      0|        tableView.register(UINib(nibName: "SettingProfileTableViewCell", bundle: nil), forCellReuseIdentifier: Section.myInfo.rawValue)
   69|      0|        tableView.delegate = self
   70|      0|        tableView.dataSource = self
   71|      0|    }
   72|       |}
   73|       |
   74|       |extension SettingViewController: UITableViewDelegate {
   75|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   76|      0|        switch Section.allCases[indexPath.section] {
   77|      0|        case .myInfo:
   78|      0|            let cell = tableView.dequeueReusableCell(withIdentifier: Section.myInfo.rawValue, for: indexPath)
   79|      0|            switch MyInfoSection.allCases[indexPath.row] {
   80|      0|            case .profile:
   81|      0|                if let cell = cell as? SettingProfileTableViewCell {
   82|      0|                    cell.setData()
   83|      0|                }
   84|      0|            }
   85|      0|            return cell
   86|      0|        case .setting:
   87|      0|            let cell = tableView.dequeueReusableCell(withIdentifier: Section.setting.rawValue, for: indexPath)
   88|      0|            switch SettingSection.allCases[indexPath.row] {
   89|      0|            case .notification:
   90|      0|                cell.textLabel?.text = "ÏïåÎ¶º ÏÑ§Ï†ï"
   91|      0|            case .emotion:
   92|      0|                cell.textLabel?.text = "Í∞êÏ†ï"
   93|      0|            case .license:
   94|      0|                cell.textLabel?.text = "Ïò§ÌîàÏÜåÏä§ ÎùºÏù¥ÏÑ†Ïä§"
   95|      0|            case .version:
   96|      0|                cell.textLabel?.text = "ÏµúÏã†Î≤ÑÏ†Ñ"
   97|      0|            }
   98|      0|            return cell
   99|      0|        }
  100|      0|    }
  101|       |    
  102|      0|    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
  103|      0|        return UITableView.automaticDimension
  104|      0|    }
  105|       |    
  106|      0|    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
  107|      0|        switch Section.allCases[section] {
  108|      0|        case .myInfo:
  109|      0|            return nil
  110|      0|        case .setting:
  111|      0|            return "Setting"
  112|      0|        }
  113|      0|    }
  114|       |}
  115|       |
  116|       |extension SettingViewController: UITableViewDataSource {
  117|      0|    func numberOfSections(in tableView: UITableView) -> Int {
  118|      0|        return Section.allCases.count
  119|      0|    }
  120|       |    
  121|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  122|      0|        switch Section.allCases[section] {
  123|      0|        case .myInfo:
  124|      0|            return MyInfoSection.allCases.count
  125|      0|        case .setting:
  126|      0|            return SettingSection.allCases.count
  127|      0|        }
  128|      0|    }
  129|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/Setting/Views/SettingProfileTableViewCell.swift:
    1|       |//
    2|       |//  SettingProfileTableViewCell.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/30.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class SettingProfileTableViewCell: UITableViewCell {
   11|       |
   12|       |    @IBOutlet weak var btnProfile: UIButton!
   13|       |    @IBOutlet weak var nameLabel: UILabel!
   14|       |    @IBOutlet weak var btnEditProfile: UIButton!
   15|       |    
   16|      0|    override func awakeFromNib() {
   17|      0|        super.awakeFromNib()
   18|      0|        // Initialization code
   19|      0|    }
   20|       |
   21|      0|    override func setSelected(_ selected: Bool, animated: Bool) {
   22|      0|        super.setSelected(selected, animated: animated)
   23|      0|    }
   24|       |    
   25|      0|    func setData(_ data: GetUserProfileResponse? = nil) {
   26|      0|        nameLabel.text = "ÎãâÎÑ§ÏûÑ"
   27|      0|    }
   28|       |}

/Users/jeongkyunkim/Documents/workspace/watsup/watsup-ios/watsup/Scene/TabBar/TabBarController.swift:
    1|       |//
    2|       |//  ViewController.swift
    3|       |//  watsup
    4|       |//
    5|       |//  Created by Jeongkyun Kim on 2021/01/20.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class TabBarController: UITabBarController {
   11|       |
   12|      7|    override func viewDidLoad() {
   13|      7|        super.viewDidLoad()
   14|      7|        // Do any additional setup after loading the view.
   15|      7|    }
   16|       |
   17|       |
   18|       |}
   19|       |

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/AFError.swift:
    1|       |//
    2|       |//  AFError.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// `AFError` is the error type returned by Alamofire. It encompasses a few different types of errors, each with
   28|       |/// their own associated reasons.
   29|       |public enum AFError: Error {
   30|       |    /// The underlying reason the `.multipartEncodingFailed` error occurred.
   31|       |    public enum MultipartEncodingFailureReason {
   32|       |        /// The `fileURL` provided for reading an encodable body part isn't a file `URL`.
   33|       |        case bodyPartURLInvalid(url: URL)
   34|       |        /// The filename of the `fileURL` provided has either an empty `lastPathComponent` or `pathExtension.
   35|       |        case bodyPartFilenameInvalid(in: URL)
   36|       |        /// The file at the `fileURL` provided was not reachable.
   37|       |        case bodyPartFileNotReachable(at: URL)
   38|       |        /// Attempting to check the reachability of the `fileURL` provided threw an error.
   39|       |        case bodyPartFileNotReachableWithError(atURL: URL, error: Error)
   40|       |        /// The file at the `fileURL` provided is actually a directory.
   41|       |        case bodyPartFileIsDirectory(at: URL)
   42|       |        /// The size of the file at the `fileURL` provided was not returned by the system.
   43|       |        case bodyPartFileSizeNotAvailable(at: URL)
   44|       |        /// The attempt to find the size of the file at the `fileURL` provided threw an error.
   45|       |        case bodyPartFileSizeQueryFailedWithError(forURL: URL, error: Error)
   46|       |        /// An `InputStream` could not be created for the provided `fileURL`.
   47|       |        case bodyPartInputStreamCreationFailed(for: URL)
   48|       |        /// An `OutputStream` could not be created when attempting to write the encoded data to disk.
   49|       |        case outputStreamCreationFailed(for: URL)
   50|       |        /// The encoded body data could not be written to disk because a file already exists at the provided `fileURL`.
   51|       |        case outputStreamFileAlreadyExists(at: URL)
   52|       |        /// The `fileURL` provided for writing the encoded body data to disk is not a file `URL`.
   53|       |        case outputStreamURLInvalid(url: URL)
   54|       |        /// The attempt to write the encoded body data to disk failed with an underlying error.
   55|       |        case outputStreamWriteFailed(error: Error)
   56|       |        /// The attempt to read an encoded body part `InputStream` failed with underlying system error.
   57|       |        case inputStreamReadFailed(error: Error)
   58|       |    }
   59|       |
   60|       |    /// The underlying reason the `.parameterEncodingFailed` error occurred.
   61|       |    public enum ParameterEncodingFailureReason {
   62|       |        /// The `URLRequest` did not have a `URL` to encode.
   63|       |        case missingURL
   64|       |        /// JSON serialization failed with an underlying system error during the encoding process.
   65|       |        case jsonEncodingFailed(error: Error)
   66|       |        /// Custom parameter encoding failed due to the associated `Error`.
   67|       |        case customEncodingFailed(error: Error)
   68|       |    }
   69|       |
   70|       |    /// The underlying reason the `.parameterEncoderFailed` error occurred.
   71|       |    public enum ParameterEncoderFailureReason {
   72|       |        /// Possible missing components.
   73|       |        public enum RequiredComponent {
   74|       |            /// The `URL` was missing or unable to be extracted from the passed `URLRequest` or during encoding.
   75|       |            case url
   76|       |            /// The `HTTPMethod` could not be extracted from the passed `URLRequest`.
   77|       |            case httpMethod(rawValue: String)
   78|       |        }
   79|       |
   80|       |        /// A `RequiredComponent` was missing during encoding.
   81|       |        case missingRequiredComponent(RequiredComponent)
   82|       |        /// The underlying encoder failed with the associated error.
   83|       |        case encoderFailed(error: Error)
   84|       |    }
   85|       |
   86|       |    /// The underlying reason the `.responseValidationFailed` error occurred.
   87|       |    public enum ResponseValidationFailureReason {
   88|       |        /// The data file containing the server response did not exist.
   89|       |        case dataFileNil
   90|       |        /// The data file containing the server response at the associated `URL` could not be read.
   91|       |        case dataFileReadFailed(at: URL)
   92|       |        /// The response did not contain a `Content-Type` and the `acceptableContentTypes` provided did not contain a
   93|       |        /// wildcard type.
   94|       |        case missingContentType(acceptableContentTypes: [String])
   95|       |        /// The response `Content-Type` did not match any type in the provided `acceptableContentTypes`.
   96|       |        case unacceptableContentType(acceptableContentTypes: [String], responseContentType: String)
   97|       |        /// The response status code was not acceptable.
   98|       |        case unacceptableStatusCode(code: Int)
   99|       |        /// Custom response validation failed due to the associated `Error`.
  100|       |        case customValidationFailed(error: Error)
  101|       |    }
  102|       |
  103|       |    /// The underlying reason the response serialization error occurred.
  104|       |    public enum ResponseSerializationFailureReason {
  105|       |        /// The server response contained no data or the data was zero length.
  106|       |        case inputDataNilOrZeroLength
  107|       |        /// The file containing the server response did not exist.
  108|       |        case inputFileNil
  109|       |        /// The file containing the server response could not be read from the associated `URL`.
  110|       |        case inputFileReadFailed(at: URL)
  111|       |        /// String serialization failed using the provided `String.Encoding`.
  112|       |        case stringSerializationFailed(encoding: String.Encoding)
  113|       |        /// JSON serialization failed with an underlying system error.
  114|       |        case jsonSerializationFailed(error: Error)
  115|       |        /// A `DataDecoder` failed to decode the response due to the associated `Error`.
  116|       |        case decodingFailed(error: Error)
  117|       |        /// A custom response serializer failed due to the associated `Error`.
  118|       |        case customSerializationFailed(error: Error)
  119|       |        /// Generic serialization failed for an empty response that wasn't type `Empty` but instead the associated type.
  120|       |        case invalidEmptyResponse(type: String)
  121|       |    }
  122|       |
  123|       |    /// Underlying reason a server trust evaluation error occurred.
  124|       |    public enum ServerTrustFailureReason {
  125|       |        /// The output of a server trust evaluation.
  126|       |        public struct Output {
  127|       |            /// The host for which the evaluation was performed.
  128|       |            public let host: String
  129|       |            /// The `SecTrust` value which was evaluated.
  130|       |            public let trust: SecTrust
  131|       |            /// The `OSStatus` of evaluation operation.
  132|       |            public let status: OSStatus
  133|       |            /// The result of the evaluation operation.
  134|       |            public let result: SecTrustResultType
  135|       |
  136|       |            /// Creates an `Output` value from the provided values.
  137|      0|            init(_ host: String, _ trust: SecTrust, _ status: OSStatus, _ result: SecTrustResultType) {
  138|      0|                self.host = host
  139|      0|                self.trust = trust
  140|      0|                self.status = status
  141|      0|                self.result = result
  142|      0|            }
  143|       |        }
  144|       |
  145|       |        /// No `ServerTrustEvaluator` was found for the associated host.
  146|       |        case noRequiredEvaluator(host: String)
  147|       |        /// No certificates were found with which to perform the trust evaluation.
  148|       |        case noCertificatesFound
  149|       |        /// No public keys were found with which to perform the trust evaluation.
  150|       |        case noPublicKeysFound
  151|       |        /// During evaluation, application of the associated `SecPolicy` failed.
  152|       |        case policyApplicationFailed(trust: SecTrust, policy: SecPolicy, status: OSStatus)
  153|       |        /// During evaluation, setting the associated anchor certificates failed.
  154|       |        case settingAnchorCertificatesFailed(status: OSStatus, certificates: [SecCertificate])
  155|       |        /// During evaluation, creation of the revocation policy failed.
  156|       |        case revocationPolicyCreationFailed
  157|       |        /// `SecTrust` evaluation failed with the associated `Error`, if one was produced.
  158|       |        case trustEvaluationFailed(error: Error?)
  159|       |        /// Default evaluation failed with the associated `Output`.
  160|       |        case defaultEvaluationFailed(output: Output)
  161|       |        /// Host validation failed with the associated `Output`.
  162|       |        case hostValidationFailed(output: Output)
  163|       |        /// Revocation check failed with the associated `Output` and options.
  164|       |        case revocationCheckFailed(output: Output, options: RevocationTrustEvaluator.Options)
  165|       |        /// Certificate pinning failed.
  166|       |        case certificatePinningFailed(host: String, trust: SecTrust, pinnedCertificates: [SecCertificate], serverCertificates: [SecCertificate])
  167|       |        /// Public key pinning failed.
  168|       |        case publicKeyPinningFailed(host: String, trust: SecTrust, pinnedKeys: [SecKey], serverKeys: [SecKey])
  169|       |        /// Custom server trust evaluation failed due to the associated `Error`.
  170|       |        case customEvaluationFailed(error: Error)
  171|       |    }
  172|       |
  173|       |    /// The underlying reason the `.urlRequestValidationFailed`
  174|       |    public enum URLRequestValidationFailureReason {
  175|       |        /// URLRequest with GET method had body data.
  176|       |        case bodyDataInGETRequest(Data)
  177|       |    }
  178|       |
  179|       |    ///  `UploadableConvertible` threw an error in `createUploadable()`.
  180|       |    case createUploadableFailed(error: Error)
  181|       |    ///  `URLRequestConvertible` threw an error in `asURLRequest()`.
  182|       |    case createURLRequestFailed(error: Error)
  183|       |    /// `SessionDelegate` threw an error while attempting to move downloaded file to destination URL.
  184|       |    case downloadedFileMoveFailed(error: Error, source: URL, destination: URL)
  185|       |    /// `Request` was explicitly cancelled.
  186|       |    case explicitlyCancelled
  187|       |    /// `URLConvertible` type failed to create a valid `URL`.
  188|       |    case invalidURL(url: URLConvertible)
  189|       |    /// Multipart form encoding failed.
  190|       |    case multipartEncodingFailed(reason: MultipartEncodingFailureReason)
  191|       |    /// `ParameterEncoding` threw an error during the encoding process.
  192|       |    case parameterEncodingFailed(reason: ParameterEncodingFailureReason)
  193|       |    /// `ParameterEncoder` threw an error while running the encoder.
  194|       |    case parameterEncoderFailed(reason: ParameterEncoderFailureReason)
  195|       |    /// `RequestAdapter` threw an error during adaptation.
  196|       |    case requestAdaptationFailed(error: Error)
  197|       |    /// `RequestRetrier` threw an error during the request retry process.
  198|       |    case requestRetryFailed(retryError: Error, originalError: Error)
  199|       |    /// Response validation failed.
  200|       |    case responseValidationFailed(reason: ResponseValidationFailureReason)
  201|       |    /// Response serialization failed.
  202|       |    case responseSerializationFailed(reason: ResponseSerializationFailureReason)
  203|       |    /// `ServerTrustEvaluating` instance threw an error during trust evaluation.
  204|       |    case serverTrustEvaluationFailed(reason: ServerTrustFailureReason)
  205|       |    /// `Session` which issued the `Request` was deinitialized, most likely because its reference went out of scope.
  206|       |    case sessionDeinitialized
  207|       |    /// `Session` was explicitly invalidated, possibly with the `Error` produced by the underlying `URLSession`.
  208|       |    case sessionInvalidated(error: Error?)
  209|       |    /// `URLSessionTask` completed with error.
  210|       |    case sessionTaskFailed(error: Error)
  211|       |    /// `URLRequest` failed validation.
  212|       |    case urlRequestValidationFailed(reason: URLRequestValidationFailureReason)
  213|       |}
  214|       |
  215|       |extension Error {
  216|       |    /// Returns the instance cast as an `AFError`.
  217|      0|    public var asAFError: AFError? {
  218|      0|        self as? AFError
  219|      0|    }
  220|       |
  221|       |    /// Returns the instance cast as an `AFError`. If casting fails, a `fatalError` with the specified `message` is thrown.
  222|      0|    public func asAFError(orFailWith message: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) -> AFError {
  223|      0|        guard let afError = self as? AFError else {
  224|      0|            fatalError(message(), file: file, line: line)
  225|      0|        }
  226|      0|        return afError
  227|      0|    }
  228|       |
  229|       |    /// Casts the instance as `AFError` or returns `defaultAFError`
  230|      0|    func asAFError(or defaultAFError: @autoclosure () -> AFError) -> AFError {
  231|      0|        self as? AFError ?? defaultAFError()
  232|      0|    }
  233|       |}
  234|       |
  235|       |// MARK: - Error Booleans
  236|       |
  237|       |extension AFError {
  238|       |    /// Returns whether the instance is `.sessionDeinitialized`.
  239|      0|    public var isSessionDeinitializedError: Bool {
  240|      0|        if case .sessionDeinitialized = self { return true }
  241|      0|        return false
  242|      0|    }
  243|       |
  244|       |    /// Returns whether the instance is `.sessionInvalidated`.
  245|      0|    public var isSessionInvalidatedError: Bool {
  246|      0|        if case .sessionInvalidated = self { return true }
  247|      0|        return false
  248|      0|    }
  249|       |
  250|       |    /// Returns whether the instance is `.explicitlyCancelled`.
  251|      0|    public var isExplicitlyCancelledError: Bool {
  252|      0|        if case .explicitlyCancelled = self { return true }
  253|      0|        return false
  254|      0|    }
  255|       |
  256|       |    /// Returns whether the instance is `.invalidURL`.
  257|      0|    public var isInvalidURLError: Bool {
  258|      0|        if case .invalidURL = self { return true }
  259|      0|        return false
  260|      0|    }
  261|       |
  262|       |    /// Returns whether the instance is `.parameterEncodingFailed`. When `true`, the `underlyingError` property will
  263|       |    /// contain the associated value.
  264|      0|    public var isParameterEncodingError: Bool {
  265|      0|        if case .parameterEncodingFailed = self { return true }
  266|      0|        return false
  267|      0|    }
  268|       |
  269|       |    /// Returns whether the instance is `.parameterEncoderFailed`. When `true`, the `underlyingError` property will
  270|       |    /// contain the associated value.
  271|      0|    public var isParameterEncoderError: Bool {
  272|      0|        if case .parameterEncoderFailed = self { return true }
  273|      0|        return false
  274|      0|    }
  275|       |
  276|       |    /// Returns whether the instance is `.multipartEncodingFailed`. When `true`, the `url` and `underlyingError`
  277|       |    /// properties will contain the associated values.
  278|      0|    public var isMultipartEncodingError: Bool {
  279|      0|        if case .multipartEncodingFailed = self { return true }
  280|      0|        return false
  281|      0|    }
  282|       |
  283|       |    /// Returns whether the instance is `.requestAdaptationFailed`. When `true`, the `underlyingError` property will
  284|       |    /// contain the associated value.
  285|      0|    public var isRequestAdaptationError: Bool {
  286|      0|        if case .requestAdaptationFailed = self { return true }
  287|      0|        return false
  288|      0|    }
  289|       |
  290|       |    /// Returns whether the instance is `.responseValidationFailed`. When `true`, the `acceptableContentTypes`,
  291|       |    /// `responseContentType`,  `responseCode`, and `underlyingError` properties will contain the associated values.
  292|      0|    public var isResponseValidationError: Bool {
  293|      0|        if case .responseValidationFailed = self { return true }
  294|      0|        return false
  295|      0|    }
  296|       |
  297|       |    /// Returns whether the instance is `.responseSerializationFailed`. When `true`, the `failedStringEncoding` and
  298|       |    /// `underlyingError` properties will contain the associated values.
  299|      0|    public var isResponseSerializationError: Bool {
  300|      0|        if case .responseSerializationFailed = self { return true }
  301|      0|        return false
  302|      0|    }
  303|       |
  304|       |    /// Returns whether the instance is `.serverTrustEvaluationFailed`. When `true`, the `underlyingError` property will
  305|       |    /// contain the associated value.
  306|      0|    public var isServerTrustEvaluationError: Bool {
  307|      0|        if case .serverTrustEvaluationFailed = self { return true }
  308|      0|        return false
  309|      0|    }
  310|       |
  311|       |    /// Returns whether the instance is `requestRetryFailed`. When `true`, the `underlyingError` property will
  312|       |    /// contain the associated value.
  313|      0|    public var isRequestRetryError: Bool {
  314|      0|        if case .requestRetryFailed = self { return true }
  315|      0|        return false
  316|      0|    }
  317|       |
  318|       |    /// Returns whether the instance is `createUploadableFailed`. When `true`, the `underlyingError` property will
  319|       |    /// contain the associated value.
  320|      0|    public var isCreateUploadableError: Bool {
  321|      0|        if case .createUploadableFailed = self { return true }
  322|      0|        return false
  323|      0|    }
  324|       |
  325|       |    /// Returns whether the instance is `createURLRequestFailed`. When `true`, the `underlyingError` property will
  326|       |    /// contain the associated value.
  327|      0|    public var isCreateURLRequestError: Bool {
  328|      0|        if case .createURLRequestFailed = self { return true }
  329|      0|        return false
  330|      0|    }
  331|       |
  332|       |    /// Returns whether the instance is `downloadedFileMoveFailed`. When `true`, the `destination` and `underlyingError` properties will
  333|       |    /// contain the associated values.
  334|      0|    public var isDownloadedFileMoveError: Bool {
  335|      0|        if case .downloadedFileMoveFailed = self { return true }
  336|      0|        return false
  337|      0|    }
  338|       |
  339|       |    /// Returns whether the instance is `createURLRequestFailed`. When `true`, the `underlyingError` property will
  340|       |    /// contain the associated value.
  341|      0|    public var isSessionTaskError: Bool {
  342|      0|        if case .sessionTaskFailed = self { return true }
  343|      0|        return false
  344|      0|    }
  345|       |}
  346|       |
  347|       |// MARK: - Convenience Properties
  348|       |
  349|       |extension AFError {
  350|       |    /// The `URLConvertible` associated with the error.
  351|      0|    public var urlConvertible: URLConvertible? {
  352|      0|        guard case let .invalidURL(url) = self else { return nil }
  353|      0|        return url
  354|      0|    }
  355|       |
  356|       |    /// The `URL` associated with the error.
  357|      0|    public var url: URL? {
  358|      0|        guard case let .multipartEncodingFailed(reason) = self else { return nil }
  359|      0|        return reason.url
  360|      0|    }
  361|       |
  362|       |    /// The underlying `Error` responsible for generating the failure associated with `.sessionInvalidated`,
  363|       |    /// `.parameterEncodingFailed`, `.parameterEncoderFailed`, `.multipartEncodingFailed`, `.requestAdaptationFailed`,
  364|       |    /// `.responseSerializationFailed`, `.requestRetryFailed` errors.
  365|      0|    public var underlyingError: Error? {
  366|      0|        switch self {
  367|      0|        case let .multipartEncodingFailed(reason):
  368|      0|            return reason.underlyingError
  369|      0|        case let .parameterEncodingFailed(reason):
  370|      0|            return reason.underlyingError
  371|      0|        case let .parameterEncoderFailed(reason):
  372|      0|            return reason.underlyingError
  373|      0|        case let .requestAdaptationFailed(error):
  374|      0|            return error
  375|      0|        case let .requestRetryFailed(retryError, _):
  376|      0|            return retryError
  377|      0|        case let .responseValidationFailed(reason):
  378|      0|            return reason.underlyingError
  379|      0|        case let .responseSerializationFailed(reason):
  380|      0|            return reason.underlyingError
  381|      0|        case let .serverTrustEvaluationFailed(reason):
  382|      0|            return reason.underlyingError
  383|      0|        case let .sessionInvalidated(error):
  384|      0|            return error
  385|      0|        case let .createUploadableFailed(error):
  386|      0|            return error
  387|      0|        case let .createURLRequestFailed(error):
  388|      0|            return error
  389|      0|        case let .downloadedFileMoveFailed(error, _, _):
  390|      0|            return error
  391|      0|        case let .sessionTaskFailed(error):
  392|      0|            return error
  393|      0|        case .explicitlyCancelled,
  394|      0|             .invalidURL,
  395|      0|             .sessionDeinitialized,
  396|      0|             .urlRequestValidationFailed:
  397|      0|            return nil
  398|      0|        }
  399|      0|    }
  400|       |
  401|       |    /// The acceptable `Content-Type`s of a `.responseValidationFailed` error.
  402|      0|    public var acceptableContentTypes: [String]? {
  403|      0|        guard case let .responseValidationFailed(reason) = self else { return nil }
  404|      0|        return reason.acceptableContentTypes
  405|      0|    }
  406|       |
  407|       |    /// The response `Content-Type` of a `.responseValidationFailed` error.
  408|      0|    public var responseContentType: String? {
  409|      0|        guard case let .responseValidationFailed(reason) = self else { return nil }
  410|      0|        return reason.responseContentType
  411|      0|    }
  412|       |
  413|       |    /// The response code of a `.responseValidationFailed` error.
  414|      0|    public var responseCode: Int? {
  415|      0|        guard case let .responseValidationFailed(reason) = self else { return nil }
  416|      0|        return reason.responseCode
  417|      0|    }
  418|       |
  419|       |    /// The `String.Encoding` associated with a failed `.stringResponse()` call.
  420|      0|    public var failedStringEncoding: String.Encoding? {
  421|      0|        guard case let .responseSerializationFailed(reason) = self else { return nil }
  422|      0|        return reason.failedStringEncoding
  423|      0|    }
  424|       |
  425|       |    /// The `source` URL of a `.downloadedFileMoveFailed` error.
  426|      0|    public var sourceURL: URL? {
  427|      0|        guard case let .downloadedFileMoveFailed(_, source, _) = self else { return nil }
  428|      0|        return source
  429|      0|    }
  430|       |
  431|       |    /// The `destination` URL of a `.downloadedFileMoveFailed` error.
  432|      0|    public var destinationURL: URL? {
  433|      0|        guard case let .downloadedFileMoveFailed(_, _, destination) = self else { return nil }
  434|      0|        return destination
  435|      0|    }
  436|       |}
  437|       |
  438|       |extension AFError.ParameterEncodingFailureReason {
  439|      0|    var underlyingError: Error? {
  440|      0|        switch self {
  441|      0|        case let .jsonEncodingFailed(error),
  442|      0|             let .customEncodingFailed(error):
  443|      0|            return error
  444|      0|        case .missingURL:
  445|      0|            return nil
  446|      0|        }
  447|      0|    }
  448|       |}
  449|       |
  450|       |extension AFError.ParameterEncoderFailureReason {
  451|      0|    var underlyingError: Error? {
  452|      0|        switch self {
  453|      0|        case let .encoderFailed(error):
  454|      0|            return error
  455|      0|        case .missingRequiredComponent:
  456|      0|            return nil
  457|      0|        }
  458|      0|    }
  459|       |}
  460|       |
  461|       |extension AFError.MultipartEncodingFailureReason {
  462|      0|    var url: URL? {
  463|      0|        switch self {
  464|      0|        case let .bodyPartURLInvalid(url),
  465|      0|             let .bodyPartFilenameInvalid(url),
  466|      0|             let .bodyPartFileNotReachable(url),
  467|      0|             let .bodyPartFileIsDirectory(url),
  468|      0|             let .bodyPartFileSizeNotAvailable(url),
  469|      0|             let .bodyPartInputStreamCreationFailed(url),
  470|      0|             let .outputStreamCreationFailed(url),
  471|      0|             let .outputStreamFileAlreadyExists(url),
  472|      0|             let .outputStreamURLInvalid(url),
  473|      0|             let .bodyPartFileNotReachableWithError(url, _),
  474|      0|             let .bodyPartFileSizeQueryFailedWithError(url, _):
  475|      0|            return url
  476|      0|        case .outputStreamWriteFailed,
  477|      0|             .inputStreamReadFailed:
  478|      0|            return nil
  479|      0|        }
  480|      0|    }
  481|       |
  482|      0|    var underlyingError: Error? {
  483|      0|        switch self {
  484|      0|        case let .bodyPartFileNotReachableWithError(_, error),
  485|      0|             let .bodyPartFileSizeQueryFailedWithError(_, error),
  486|      0|             let .outputStreamWriteFailed(error),
  487|      0|             let .inputStreamReadFailed(error):
  488|      0|            return error
  489|      0|        case .bodyPartURLInvalid,
  490|      0|             .bodyPartFilenameInvalid,
  491|      0|             .bodyPartFileNotReachable,
  492|      0|             .bodyPartFileIsDirectory,
  493|      0|             .bodyPartFileSizeNotAvailable,
  494|      0|             .bodyPartInputStreamCreationFailed,
  495|      0|             .outputStreamCreationFailed,
  496|      0|             .outputStreamFileAlreadyExists,
  497|      0|             .outputStreamURLInvalid:
  498|      0|            return nil
  499|      0|        }
  500|      0|    }
  501|       |}
  502|       |
  503|       |extension AFError.ResponseValidationFailureReason {
  504|      0|    var acceptableContentTypes: [String]? {
  505|      0|        switch self {
  506|      0|        case let .missingContentType(types),
  507|      0|             let .unacceptableContentType(types, _):
  508|      0|            return types
  509|      0|        case .dataFileNil,
  510|      0|             .dataFileReadFailed,
  511|      0|             .unacceptableStatusCode,
  512|      0|             .customValidationFailed:
  513|      0|            return nil
  514|      0|        }
  515|      0|    }
  516|       |
  517|      0|    var responseContentType: String? {
  518|      0|        switch self {
  519|      0|        case let .unacceptableContentType(_, responseType):
  520|      0|            return responseType
  521|      0|        case .dataFileNil,
  522|      0|             .dataFileReadFailed,
  523|      0|             .missingContentType,
  524|      0|             .unacceptableStatusCode,
  525|      0|             .customValidationFailed:
  526|      0|            return nil
  527|      0|        }
  528|      0|    }
  529|       |
  530|      0|    var responseCode: Int? {
  531|      0|        switch self {
  532|      0|        case let .unacceptableStatusCode(code):
  533|      0|            return code
  534|      0|        case .dataFileNil,
  535|      0|             .dataFileReadFailed,
  536|      0|             .missingContentType,
  537|      0|             .unacceptableContentType,
  538|      0|             .customValidationFailed:
  539|      0|            return nil
  540|      0|        }
  541|      0|    }
  542|       |
  543|      0|    var underlyingError: Error? {
  544|      0|        switch self {
  545|      0|        case let .customValidationFailed(error):
  546|      0|            return error
  547|      0|        case .dataFileNil,
  548|      0|             .dataFileReadFailed,
  549|      0|             .missingContentType,
  550|      0|             .unacceptableContentType,
  551|      0|             .unacceptableStatusCode:
  552|      0|            return nil
  553|      0|        }
  554|      0|    }
  555|       |}
  556|       |
  557|       |extension AFError.ResponseSerializationFailureReason {
  558|      0|    var failedStringEncoding: String.Encoding? {
  559|      0|        switch self {
  560|      0|        case let .stringSerializationFailed(encoding):
  561|      0|            return encoding
  562|      0|        case .inputDataNilOrZeroLength,
  563|      0|             .inputFileNil,
  564|      0|             .inputFileReadFailed(_),
  565|      0|             .jsonSerializationFailed(_),
  566|      0|             .decodingFailed(_),
  567|      0|             .customSerializationFailed(_),
  568|      0|             .invalidEmptyResponse:
  569|      0|            return nil
  570|      0|        }
  571|      0|    }
  572|       |
  573|      0|    var underlyingError: Error? {
  574|      0|        switch self {
  575|      0|        case let .jsonSerializationFailed(error),
  576|      0|             let .decodingFailed(error),
  577|      0|             let .customSerializationFailed(error):
  578|      0|            return error
  579|      0|        case .inputDataNilOrZeroLength,
  580|      0|             .inputFileNil,
  581|      0|             .inputFileReadFailed,
  582|      0|             .stringSerializationFailed,
  583|      0|             .invalidEmptyResponse:
  584|      0|            return nil
  585|      0|        }
  586|      0|    }
  587|       |}
  588|       |
  589|       |extension AFError.ServerTrustFailureReason {
  590|      0|    var output: AFError.ServerTrustFailureReason.Output? {
  591|      0|        switch self {
  592|      0|        case let .defaultEvaluationFailed(output),
  593|      0|             let .hostValidationFailed(output),
  594|      0|             let .revocationCheckFailed(output, _):
  595|      0|            return output
  596|      0|        case .noRequiredEvaluator,
  597|      0|             .noCertificatesFound,
  598|      0|             .noPublicKeysFound,
  599|      0|             .policyApplicationFailed,
  600|      0|             .settingAnchorCertificatesFailed,
  601|      0|             .revocationPolicyCreationFailed,
  602|      0|             .trustEvaluationFailed,
  603|      0|             .certificatePinningFailed,
  604|      0|             .publicKeyPinningFailed,
  605|      0|             .customEvaluationFailed:
  606|      0|            return nil
  607|      0|        }
  608|      0|    }
  609|       |
  610|      0|    var underlyingError: Error? {
  611|      0|        switch self {
  612|      0|        case let .customEvaluationFailed(error):
  613|      0|            return error
  614|      0|        case let .trustEvaluationFailed(error):
  615|      0|            return error
  616|      0|        case .noRequiredEvaluator,
  617|      0|             .noCertificatesFound,
  618|      0|             .noPublicKeysFound,
  619|      0|             .policyApplicationFailed,
  620|      0|             .settingAnchorCertificatesFailed,
  621|      0|             .revocationPolicyCreationFailed,
  622|      0|             .defaultEvaluationFailed,
  623|      0|             .hostValidationFailed,
  624|      0|             .revocationCheckFailed,
  625|      0|             .certificatePinningFailed,
  626|      0|             .publicKeyPinningFailed:
  627|      0|            return nil
  628|      0|        }
  629|      0|    }
  630|       |}
  631|       |
  632|       |// MARK: - Error Descriptions
  633|       |
  634|       |extension AFError: LocalizedError {
  635|      0|    public var errorDescription: String? {
  636|      0|        switch self {
  637|      0|        case .explicitlyCancelled:
  638|      0|            return "Request explicitly cancelled."
  639|      0|        case let .invalidURL(url):
  640|      0|            return "URL is not valid: \(url)"
  641|      0|        case let .parameterEncodingFailed(reason):
  642|      0|            return reason.localizedDescription
  643|      0|        case let .parameterEncoderFailed(reason):
  644|      0|            return reason.localizedDescription
  645|      0|        case let .multipartEncodingFailed(reason):
  646|      0|            return reason.localizedDescription
  647|      0|        case let .requestAdaptationFailed(error):
  648|      0|            return "Request adaption failed with error: \(error.localizedDescription)"
  649|      0|        case let .responseValidationFailed(reason):
  650|      0|            return reason.localizedDescription
  651|      0|        case let .responseSerializationFailed(reason):
  652|      0|            return reason.localizedDescription
  653|      0|        case let .requestRetryFailed(retryError, originalError):
  654|      0|            return """
  655|      0|            Request retry failed with retry error: \(retryError.localizedDescription), \
  656|      0|            original error: \(originalError.localizedDescription)
  657|      0|            """
  658|      0|        case .sessionDeinitialized:
  659|      0|            return """
  660|      0|            Session was invalidated without error, so it was likely deinitialized unexpectedly. \
  661|      0|            Be sure to retain a reference to your Session for the duration of your requests.
  662|      0|            """
  663|      0|        case let .sessionInvalidated(error):
  664|      0|            return "Session was invalidated with error: \(error?.localizedDescription ?? "No description.")"
  665|      0|        case let .serverTrustEvaluationFailed(reason):
  666|      0|            return "Server trust evaluation failed due to reason: \(reason.localizedDescription)"
  667|      0|        case let .urlRequestValidationFailed(reason):
  668|      0|            return "URLRequest validation failed due to reason: \(reason.localizedDescription)"
  669|      0|        case let .createUploadableFailed(error):
  670|      0|            return "Uploadable creation failed with error: \(error.localizedDescription)"
  671|      0|        case let .createURLRequestFailed(error):
  672|      0|            return "URLRequest creation failed with error: \(error.localizedDescription)"
  673|      0|        case let .downloadedFileMoveFailed(error, source, destination):
  674|      0|            return "Moving downloaded file from: \(source) to: \(destination) failed with error: \(error.localizedDescription)"
  675|      0|        case let .sessionTaskFailed(error):
  676|      0|            return "URLSessionTask failed with error: \(error.localizedDescription)"
  677|      0|        }
  678|      0|    }
  679|       |}
  680|       |
  681|       |extension AFError.ParameterEncodingFailureReason {
  682|      0|    var localizedDescription: String {
  683|      0|        switch self {
  684|      0|        case .missingURL:
  685|      0|            return "URL request to encode was missing a URL"
  686|      0|        case let .jsonEncodingFailed(error):
  687|      0|            return "JSON could not be encoded because of error:\n\(error.localizedDescription)"
  688|      0|        case let .customEncodingFailed(error):
  689|      0|            return "Custom parameter encoder failed with error: \(error.localizedDescription)"
  690|      0|        }
  691|      0|    }
  692|       |}
  693|       |
  694|       |extension AFError.ParameterEncoderFailureReason {
  695|      0|    var localizedDescription: String {
  696|      0|        switch self {
  697|      0|        case let .missingRequiredComponent(component):
  698|      0|            return "Encoding failed due to a missing request component: \(component)"
  699|      0|        case let .encoderFailed(error):
  700|      0|            return "The underlying encoder failed with the error: \(error)"
  701|      0|        }
  702|      0|    }
  703|       |}
  704|       |
  705|       |extension AFError.MultipartEncodingFailureReason {
  706|      0|    var localizedDescription: String {
  707|      0|        switch self {
  708|      0|        case let .bodyPartURLInvalid(url):
  709|      0|            return "The URL provided is not a file URL: \(url)"
  710|      0|        case let .bodyPartFilenameInvalid(url):
  711|      0|            return "The URL provided does not have a valid filename: \(url)"
  712|      0|        case let .bodyPartFileNotReachable(url):
  713|      0|            return "The URL provided is not reachable: \(url)"
  714|      0|        case let .bodyPartFileNotReachableWithError(url, error):
  715|      0|            return """
  716|      0|            The system returned an error while checking the provided URL for reachability.
  717|      0|            URL: \(url)
  718|      0|            Error: \(error)
  719|      0|            """
  720|      0|        case let .bodyPartFileIsDirectory(url):
  721|      0|            return "The URL provided is a directory: \(url)"
  722|      0|        case let .bodyPartFileSizeNotAvailable(url):
  723|      0|            return "Could not fetch the file size from the provided URL: \(url)"
  724|      0|        case let .bodyPartFileSizeQueryFailedWithError(url, error):
  725|      0|            return """
  726|      0|            The system returned an error while attempting to fetch the file size from the provided URL.
  727|      0|            URL: \(url)
  728|      0|            Error: \(error)
  729|      0|            """
  730|      0|        case let .bodyPartInputStreamCreationFailed(url):
  731|      0|            return "Failed to create an InputStream for the provided URL: \(url)"
  732|      0|        case let .outputStreamCreationFailed(url):
  733|      0|            return "Failed to create an OutputStream for URL: \(url)"
  734|      0|        case let .outputStreamFileAlreadyExists(url):
  735|      0|            return "A file already exists at the provided URL: \(url)"
  736|      0|        case let .outputStreamURLInvalid(url):
  737|      0|            return "The provided OutputStream URL is invalid: \(url)"
  738|      0|        case let .outputStreamWriteFailed(error):
  739|      0|            return "OutputStream write failed with error: \(error)"
  740|      0|        case let .inputStreamReadFailed(error):
  741|      0|            return "InputStream read failed with error: \(error)"
  742|      0|        }
  743|      0|    }
  744|       |}
  745|       |
  746|       |extension AFError.ResponseSerializationFailureReason {
  747|      0|    var localizedDescription: String {
  748|      0|        switch self {
  749|      0|        case .inputDataNilOrZeroLength:
  750|      0|            return "Response could not be serialized, input data was nil or zero length."
  751|      0|        case .inputFileNil:
  752|      0|            return "Response could not be serialized, input file was nil."
  753|      0|        case let .inputFileReadFailed(url):
  754|      0|            return "Response could not be serialized, input file could not be read: \(url)."
  755|      0|        case let .stringSerializationFailed(encoding):
  756|      0|            return "String could not be serialized with encoding: \(encoding)."
  757|      0|        case let .jsonSerializationFailed(error):
  758|      0|            return "JSON could not be serialized because of error:\n\(error.localizedDescription)"
  759|      0|        case let .invalidEmptyResponse(type):
  760|      0|            return """
  761|      0|            Empty response could not be serialized to type: \(type). \
  762|      0|            Use Empty as the expected type for such responses.
  763|      0|            """
  764|      0|        case let .decodingFailed(error):
  765|      0|            return "Response could not be decoded because of error:\n\(error.localizedDescription)"
  766|      0|        case let .customSerializationFailed(error):
  767|      0|            return "Custom response serializer failed with error:\n\(error.localizedDescription)"
  768|      0|        }
  769|      0|    }
  770|       |}
  771|       |
  772|       |extension AFError.ResponseValidationFailureReason {
  773|      0|    var localizedDescription: String {
  774|      0|        switch self {
  775|      0|        case .dataFileNil:
  776|      0|            return "Response could not be validated, data file was nil."
  777|      0|        case let .dataFileReadFailed(url):
  778|      0|            return "Response could not be validated, data file could not be read: \(url)."
  779|      0|        case let .missingContentType(types):
  780|      0|            return """
  781|      0|            Response Content-Type was missing and acceptable content types \
  782|      0|            (\(types.joined(separator: ","))) do not match "*/*".
  783|      0|            """
  784|      0|        case let .unacceptableContentType(acceptableTypes, responseType):
  785|      0|            return """
  786|      0|            Response Content-Type "\(responseType)" does not match any acceptable types: \
  787|      0|            \(acceptableTypes.joined(separator: ",")).
  788|      0|            """
  789|      0|        case let .unacceptableStatusCode(code):
  790|      0|            return "Response status code was unacceptable: \(code)."
  791|      0|        case let .customValidationFailed(error):
  792|      0|            return "Custom response validation failed with error: \(error.localizedDescription)"
  793|      0|        }
  794|      0|    }
  795|       |}
  796|       |
  797|       |extension AFError.ServerTrustFailureReason {
  798|      0|    var localizedDescription: String {
  799|      0|        switch self {
  800|      0|        case let .noRequiredEvaluator(host):
  801|      0|            return "A ServerTrustEvaluating value is required for host \(host) but none was found."
  802|      0|        case .noCertificatesFound:
  803|      0|            return "No certificates were found or provided for evaluation."
  804|      0|        case .noPublicKeysFound:
  805|      0|            return "No public keys were found or provided for evaluation."
  806|      0|        case .policyApplicationFailed:
  807|      0|            return "Attempting to set a SecPolicy failed."
  808|      0|        case .settingAnchorCertificatesFailed:
  809|      0|            return "Attempting to set the provided certificates as anchor certificates failed."
  810|      0|        case .revocationPolicyCreationFailed:
  811|      0|            return "Attempting to create a revocation policy failed."
  812|      0|        case let .trustEvaluationFailed(error):
  813|      0|            return "SecTrust evaluation failed with error: \(error?.localizedDescription ?? "None")"
  814|      0|        case let .defaultEvaluationFailed(output):
  815|      0|            return "Default evaluation failed for host \(output.host)."
  816|      0|        case let .hostValidationFailed(output):
  817|      0|            return "Host validation failed for host \(output.host)."
  818|      0|        case let .revocationCheckFailed(output, _):
  819|      0|            return "Revocation check failed for host \(output.host)."
  820|      0|        case let .certificatePinningFailed(host, _, _, _):
  821|      0|            return "Certificate pinning failed for host \(host)."
  822|      0|        case let .publicKeyPinningFailed(host, _, _, _):
  823|      0|            return "Public key pinning failed for host \(host)."
  824|      0|        case let .customEvaluationFailed(error):
  825|      0|            return "Custom trust evaluation failed with error: \(error.localizedDescription)"
  826|      0|        }
  827|      0|    }
  828|       |}
  829|       |
  830|       |extension AFError.URLRequestValidationFailureReason {
  831|      0|    var localizedDescription: String {
  832|      0|        switch self {
  833|      0|        case let .bodyDataInGETRequest(data):
  834|      0|            return """
  835|      0|            Invalid URLRequest: Requests with GET method cannot have body data:
  836|      0|            \(String(decoding: data, as: UTF8.self))
  837|      0|            """
  838|      0|        }
  839|      0|    }
  840|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/AlamofireExtended.swift:
    1|       |//
    2|       |//  AlamofireExtended.swift
    3|       |//
    4|       |//  Copyright (c) 2019 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |/// Type that acts as a generic extension point for all `AlamofireExtended` types.
   26|       |public struct AlamofireExtension<ExtendedType> {
   27|       |    /// Stores the type or meta-type of any extended type.
   28|       |    public private(set) var type: ExtendedType
   29|       |
   30|       |    /// Create an instance from the provided value.
   31|       |    ///
   32|       |    /// - Parameter type: Instance being extended.
   33|      0|    public init(_ type: ExtendedType) {
   34|      0|        self.type = type
   35|      0|    }
   36|       |}
   37|       |
   38|       |/// Protocol describing the `af` extension points for Alamofire extended types.
   39|       |public protocol AlamofireExtended {
   40|       |    /// Type being extended.
   41|       |    associatedtype ExtendedType
   42|       |
   43|       |    /// Static Alamofire extension point.
   44|       |    static var af: AlamofireExtension<ExtendedType>.Type { get set }
   45|       |    /// Instance Alamofire extension point.
   46|       |    var af: AlamofireExtension<ExtendedType> { get set }
   47|       |}
   48|       |
   49|       |extension AlamofireExtended {
   50|       |    /// Static Alamofire extension point.
   51|       |    public static var af: AlamofireExtension<Self>.Type {
   52|      0|        get { AlamofireExtension<Self>.self }
   53|      0|        set {}
   54|       |    }
   55|       |
   56|       |    /// Instance Alamofire extension point.
   57|       |    public var af: AlamofireExtension<Self> {
   58|      0|        get { AlamofireExtension(self) }
   59|      0|        set {}
   60|       |    }
   61|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/AuthenticationInterceptor.swift:
    1|       |//
    2|       |//  AuthenticationInterceptor.swift
    3|       |//
    4|       |//  Copyright (c) 2020 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Types adopting the `AuthenticationCredential` protocol can be used to authenticate `URLRequest`s.
   28|       |///
   29|       |/// One common example of an `AuthenticationCredential` is an OAuth2 credential containing an access token used to
   30|       |/// authenticate all requests on behalf of a user. The access token generally has an expiration window of 60 minutes
   31|       |/// which will then require a refresh of the credential using the refresh token to generate a new access token.
   32|       |public protocol AuthenticationCredential {
   33|       |    /// Whether the credential requires a refresh. This property should always return `true` when the credential is
   34|       |    /// expired. It is also wise to consider returning `true` when the credential will expire in several seconds or
   35|       |    /// minutes depending on the expiration window of the credential.
   36|       |    ///
   37|       |    /// For example, if the credential is valid for 60 minutes, then it would be wise to return `true` when the
   38|       |    /// credential is only valid for 5 minutes or less. That ensures the credential will not expire as it is passed
   39|       |    /// around backend services.
   40|       |    var requiresRefresh: Bool { get }
   41|       |}
   42|       |
   43|       |// MARK: -
   44|       |
   45|       |/// Types adopting the `Authenticator` protocol can be used to authenticate `URLRequest`s with an
   46|       |/// `AuthenticationCredential` as well as refresh the `AuthenticationCredential` when required.
   47|       |public protocol Authenticator: AnyObject {
   48|       |    /// The type of credential associated with the `Authenticator` instance.
   49|       |    associatedtype Credential: AuthenticationCredential
   50|       |
   51|       |    /// Applies the `Credential` to the `URLRequest`.
   52|       |    ///
   53|       |    /// In the case of OAuth2, the access token of the `Credential` would be added to the `URLRequest` as a Bearer
   54|       |    /// token to the `Authorization` header.
   55|       |    ///
   56|       |    /// - Parameters:
   57|       |    ///   - credential: The `Credential`.
   58|       |    ///   - urlRequest: The `URLRequest`.
   59|       |    func apply(_ credential: Credential, to urlRequest: inout URLRequest)
   60|       |
   61|       |    /// Refreshes the `Credential` and executes the `completion` closure with the `Result` once complete.
   62|       |    ///
   63|       |    /// Refresh can be called in one of two ways. It can be called before the `Request` is actually executed due to
   64|       |    /// a `requiresRefresh` returning `true` during the adapt portion of the `Request` creation process. It can also
   65|       |    /// be triggered by a failed `Request` where the authentication server denied access due to an expired or
   66|       |    /// invalidated access token.
   67|       |    ///
   68|       |    /// In the case of OAuth2, this method would use the refresh token of the `Credential` to generate a new
   69|       |    /// `Credential` using the authentication service. Once complete, the `completion` closure should be called with
   70|       |    /// the new `Credential`, or the error that occurred.
   71|       |    ///
   72|       |    /// In general, if the refresh call fails with certain status codes from the authentication server (commonly a 401),
   73|       |    /// the refresh token in the `Credential` can no longer be used to generate a valid `Credential`. In these cases,
   74|       |    /// you will need to reauthenticate the user with their username / password.
   75|       |    ///
   76|       |    /// Please note, these are just general examples of common use cases. They are not meant to solve your specific
   77|       |    /// authentication server challenges. Please work with your authentication server team to ensure your
   78|       |    /// `Authenticator` logic matches their expectations.
   79|       |    ///
   80|       |    /// - Parameters:
   81|       |    ///   - credential: The `Credential` to refresh.
   82|       |    ///   - session:    The `Session` requiring the refresh.
   83|       |    ///   - completion: The closure to be executed once the refresh is complete.
   84|       |    func refresh(_ credential: Credential, for session: Session, completion: @escaping (Result<Credential, Error>) -> Void)
   85|       |
   86|       |    /// Determines whether the `URLRequest` failed due to an authentication error based on the `HTTPURLResponse`.
   87|       |    ///
   88|       |    /// If the authentication server **CANNOT** invalidate credentials after they are issued, then simply return `false`
   89|       |    /// for this method. If the authentication server **CAN** invalidate credentials due to security breaches, then you
   90|       |    /// will need to work with your authentication server team to understand how to identify when this occurs.
   91|       |    ///
   92|       |    /// In the case of OAuth2, where an authentication server can invalidate credentials, you will need to inspect the
   93|       |    /// `HTTPURLResponse` or possibly the `Error` for when this occurs. This is commonly handled by the authentication
   94|       |    /// server returning a 401 status code and some additional header to indicate an OAuth2 failure occurred.
   95|       |    ///
   96|       |    /// It is very important to understand how your authentication server works to be able to implement this correctly.
   97|       |    /// For example, if your authentication server returns a 401 when an OAuth2 error occurs, and your downstream
   98|       |    /// service also returns a 401 when you are not authorized to perform that operation, how do you know which layer
   99|       |    /// of the backend returned you a 401? You do not want to trigger a refresh unless you know your authentication
  100|       |    /// server is actually the layer rejecting the request. Again, work with your authentication server team to understand
  101|       |    /// how to identify an OAuth2 401 error vs. a downstream 401 error to avoid endless refresh loops.
  102|       |    ///
  103|       |    /// - Parameters:
  104|       |    ///   - urlRequest: The `URLRequest`.
  105|       |    ///   - response:   The `HTTPURLResponse`.
  106|       |    ///   - error:      The `Error`.
  107|       |    ///
  108|       |    /// - Returns: `true` if the `URLRequest` failed due to an authentication error, `false` otherwise.
  109|       |    func didRequest(_ urlRequest: URLRequest, with response: HTTPURLResponse, failDueToAuthenticationError error: Error) -> Bool
  110|       |
  111|       |    /// Determines whether the `URLRequest` is authenticated with the `Credential`.
  112|       |    ///
  113|       |    /// If the authentication server **CANNOT** invalidate credentials after they are issued, then simply return `true`
  114|       |    /// for this method. If the authentication server **CAN** invalidate credentials due to security breaches, then
  115|       |    /// read on.
  116|       |    ///
  117|       |    /// When an authentication server can invalidate credentials, it means that you may have a non-expired credential
  118|       |    /// that appears to be valid, but will be rejected by the authentication server when used. Generally when this
  119|       |    /// happens, a number of requests are all sent when the application is foregrounded, and all of them will be
  120|       |    /// rejected by the authentication server in the order they are received. The first failed request will trigger a
  121|       |    /// refresh internally, which will update the credential, and then retry all the queued requests with the new
  122|       |    /// credential. However, it is possible that some of the original requests will not return from the authentication
  123|       |    /// server until the refresh has completed. This is where this method comes in.
  124|       |    ///
  125|       |    /// When the authentication server rejects a credential, we need to check to make sure we haven't refreshed the
  126|       |    /// credential while the request was in flight. If it has already refreshed, then we don't need to trigger an
  127|       |    /// additional refresh. If it hasn't refreshed, then we need to refresh.
  128|       |    ///
  129|       |    /// Now that it is understood how the result of this method is used in the refresh lifecyle, let's walk through how
  130|       |    /// to implement it. You should return `true` in this method if the `URLRequest` is authenticated in a way that
  131|       |    /// matches the values in the `Credential`. In the case of OAuth2, this would mean that the Bearer token in the
  132|       |    /// `Authorization` header of the `URLRequest` matches the access token in the `Credential`. If it matches, then we
  133|       |    /// know the `Credential` was used to authenticate the `URLRequest` and should return `true`. If the Bearer token
  134|       |    /// did not match the access token, then you should return `false`.
  135|       |    ///
  136|       |    /// - Parameters:
  137|       |    ///   - urlRequest: The `URLRequest`.
  138|       |    ///   - credential: The `Credential`.
  139|       |    ///
  140|       |    /// - Returns: `true` if the `URLRequest` is authenticated with the `Credential`, `false` otherwise.
  141|       |    func isRequest(_ urlRequest: URLRequest, authenticatedWith credential: Credential) -> Bool
  142|       |}
  143|       |
  144|       |// MARK: -
  145|       |
  146|       |/// Represents various authentication failures that occur when using the `AuthenticationInterceptor`. All errors are
  147|       |/// still vended from Alamofire as `AFError` types. The `AuthenticationError` instances will be embedded within
  148|       |/// `AFError` `.requestAdaptationFailed` or `.requestRetryFailed` cases.
  149|       |public enum AuthenticationError: Error {
  150|       |    /// The credential was missing so the request could not be authenticated.
  151|       |    case missingCredential
  152|       |    /// The credential was refreshed too many times within the `RefreshWindow`.
  153|       |    case excessiveRefresh
  154|       |}
  155|       |
  156|       |// MARK: -
  157|       |
  158|       |/// The `AuthenticationInterceptor` class manages the queuing and threading complexity of authenticating requests.
  159|       |/// It relies on an `Authenticator` type to handle the actual `URLRequest` authentication and `Credential` refresh.
  160|       |public class AuthenticationInterceptor<AuthenticatorType>: RequestInterceptor where AuthenticatorType: Authenticator {
  161|       |    // MARK: Typealiases
  162|       |
  163|       |    /// Type of credential used to authenticate requests.
  164|       |    public typealias Credential = AuthenticatorType.Credential
  165|       |
  166|       |    // MARK: Helper Types
  167|       |
  168|       |    /// Type that defines a time window used to identify excessive refresh calls. When enabled, prior to executing a
  169|       |    /// refresh, the `AuthenticationInterceptor` compares the timestamp history of previous refresh calls against the
  170|       |    /// `RefreshWindow`. If more refreshes have occurred within the refresh window than allowed, the refresh is
  171|       |    /// cancelled and an `AuthorizationError.excessiveRefresh` error is thrown.
  172|       |    public struct RefreshWindow {
  173|       |        /// `TimeInterval` defining the duration of the time window before the current time in which the number of
  174|       |        /// refresh attempts is compared against `maximumAttempts`. For example, if `interval` is 30 seconds, then the
  175|       |        /// `RefreshWindow` represents the past 30 seconds. If more attempts occurred in the past 30 seconds than
  176|       |        /// `maximumAttempts`, an `.excessiveRefresh` error will be thrown.
  177|       |        public let interval: TimeInterval
  178|       |
  179|       |        /// Total refresh attempts allowed within `interval` before throwing an `.excessiveRefresh` error.
  180|       |        public let maximumAttempts: Int
  181|       |
  182|       |        /// Creates a `RefreshWindow` instance from the specified `interval` and `maximumAttempts`.
  183|       |        ///
  184|       |        /// - Parameters:
  185|       |        ///   - interval:        `TimeInterval` defining the duration of the time window before the current time.
  186|       |        ///   - maximumAttempts: The maximum attempts allowed within the `TimeInterval`.
  187|      0|        public init(interval: TimeInterval = 30.0, maximumAttempts: Int = 5) {
  188|      0|            self.interval = interval
  189|      0|            self.maximumAttempts = maximumAttempts
  190|      0|        }
  191|       |    }
  192|       |
  193|       |    private struct AdaptOperation {
  194|       |        let urlRequest: URLRequest
  195|       |        let session: Session
  196|       |        let completion: (Result<URLRequest, Error>) -> Void
  197|       |    }
  198|       |
  199|       |    private enum AdaptResult {
  200|       |        case adapt(Credential)
  201|       |        case doNotAdapt(AuthenticationError)
  202|       |        case adaptDeferred
  203|       |    }
  204|       |
  205|       |    private struct MutableState {
  206|       |        var credential: Credential?
  207|       |
  208|       |        var isRefreshing = false
  209|       |        var refreshTimestamps: [TimeInterval] = []
  210|       |        var refreshWindow: RefreshWindow?
  211|       |
  212|       |        var adaptOperations: [AdaptOperation] = []
  213|       |        var requestsToRetry: [(RetryResult) -> Void] = []
  214|       |    }
  215|       |
  216|       |    // MARK: Properties
  217|       |
  218|       |    /// The `Credential` used to authenticate requests.
  219|       |    public var credential: Credential? {
  220|      0|        get { mutableState.credential }
  221|      0|        set { mutableState.credential = newValue }
  222|       |    }
  223|       |
  224|       |    let authenticator: AuthenticatorType
  225|      0|    let queue = DispatchQueue(label: "org.alamofire.authentication.inspector")
  226|       |
  227|       |    @Protected
  228|      0|    private var mutableState = MutableState()
  229|       |
  230|       |    // MARK: Initialization
  231|       |
  232|       |    /// Creates an `AuthenticationInterceptor` instance from the specified parameters.
  233|       |    ///
  234|       |    /// A `nil` `RefreshWindow` will result in the `AuthenticationInterceptor` not checking for excessive refresh calls.
  235|       |    /// It is recommended to always use a `RefreshWindow` to avoid endless refresh cycles.
  236|       |    ///
  237|       |    /// - Parameters:
  238|       |    ///   - authenticator: The `Authenticator` type.
  239|       |    ///   - credential:    The `Credential` if it exists. `nil` by default.
  240|       |    ///   - refreshWindow: The `RefreshWindow` used to identify excessive refresh calls. `RefreshWindow()` by default.
  241|       |    public init(authenticator: AuthenticatorType,
  242|       |                credential: Credential? = nil,
  243|      0|                refreshWindow: RefreshWindow? = RefreshWindow()) {
  244|      0|        self.authenticator = authenticator
  245|      0|        mutableState.credential = credential
  246|      0|        mutableState.refreshWindow = refreshWindow
  247|      0|    }
  248|       |
  249|       |    // MARK: Adapt
  250|       |
  251|      0|    public func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (Result<URLRequest, Error>) -> Void) {
  252|      0|        let adaptResult: AdaptResult = $mutableState.write { mutableState in
  253|      0|            // Queue the adapt operation if a refresh is already in place.
  254|      0|            guard !mutableState.isRefreshing else {
  255|      0|                let operation = AdaptOperation(urlRequest: urlRequest, session: session, completion: completion)
  256|      0|                mutableState.adaptOperations.append(operation)
  257|      0|                return .adaptDeferred
  258|      0|            }
  259|      0|
  260|      0|            // Throw missing credential error is the credential is missing.
  261|      0|            guard let credential = mutableState.credential else {
  262|      0|                let error = AuthenticationError.missingCredential
  263|      0|                return .doNotAdapt(error)
  264|      0|            }
  265|      0|
  266|      0|            // Queue the adapt operation and trigger refresh operation if credential requires refresh.
  267|      0|            guard !credential.requiresRefresh else {
  268|      0|                let operation = AdaptOperation(urlRequest: urlRequest, session: session, completion: completion)
  269|      0|                mutableState.adaptOperations.append(operation)
  270|      0|                refresh(credential, for: session, insideLock: &mutableState)
  271|      0|                return .adaptDeferred
  272|      0|            }
  273|      0|
  274|      0|            return .adapt(credential)
  275|      0|        }
  276|      0|
  277|      0|        switch adaptResult {
  278|      0|        case let .adapt(credential):
  279|      0|            var authenticatedRequest = urlRequest
  280|      0|            authenticator.apply(credential, to: &authenticatedRequest)
  281|      0|            completion(.success(authenticatedRequest))
  282|      0|
  283|      0|        case let .doNotAdapt(adaptError):
  284|      0|            completion(.failure(adaptError))
  285|      0|
  286|      0|        case .adaptDeferred:
  287|      0|            // No-op: adapt operation captured during refresh.
  288|      0|            break
  289|      0|        }
  290|      0|    }
  291|       |
  292|       |    // MARK: Retry
  293|       |
  294|      0|    public func retry(_ request: Request, for session: Session, dueTo error: Error, completion: @escaping (RetryResult) -> Void) {
  295|      0|        // Do not attempt retry if there was not an original request and response from the server.
  296|      0|        guard let urlRequest = request.request, let response = request.response else {
  297|      0|            completion(.doNotRetry)
  298|      0|            return
  299|      0|        }
  300|      0|
  301|      0|        // Do not attempt retry unless the `Authenticator` verifies failure was due to authentication error (i.e. 401 status code).
  302|      0|        guard authenticator.didRequest(urlRequest, with: response, failDueToAuthenticationError: error) else {
  303|      0|            completion(.doNotRetry)
  304|      0|            return
  305|      0|        }
  306|      0|
  307|      0|        // Do not attempt retry if there is no credential.
  308|      0|        guard let credential = credential else {
  309|      0|            let error = AuthenticationError.missingCredential
  310|      0|            completion(.doNotRetryWithError(error))
  311|      0|            return
  312|      0|        }
  313|      0|
  314|      0|        // Retry the request if the `Authenticator` verifies it was authenticated with a previous credential.
  315|      0|        guard authenticator.isRequest(urlRequest, authenticatedWith: credential) else {
  316|      0|            completion(.retry)
  317|      0|            return
  318|      0|        }
  319|      0|
  320|      0|        $mutableState.write { mutableState in
  321|      0|            mutableState.requestsToRetry.append(completion)
  322|      0|
  323|      0|            guard !mutableState.isRefreshing else { return }
  324|      0|
  325|      0|            refresh(credential, for: session, insideLock: &mutableState)
  326|      0|        }
  327|      0|    }
  328|       |
  329|       |    // MARK: Refresh
  330|       |
  331|      0|    private func refresh(_ credential: Credential, for session: Session, insideLock mutableState: inout MutableState) {
  332|      0|        guard !isRefreshExcessive(insideLock: &mutableState) else {
  333|      0|            let error = AuthenticationError.excessiveRefresh
  334|      0|            handleRefreshFailure(error, insideLock: &mutableState)
  335|      0|            return
  336|      0|        }
  337|      0|
  338|      0|        mutableState.refreshTimestamps.append(ProcessInfo.processInfo.systemUptime)
  339|      0|        mutableState.isRefreshing = true
  340|      0|
  341|      0|        // Dispatch to queue to hop out of the lock in case authenticator.refresh is implemented synchronously.
  342|      0|        queue.async {
  343|      0|            self.authenticator.refresh(credential, for: session) { result in
  344|      0|                self.$mutableState.write { mutableState in
  345|      0|                    switch result {
  346|      0|                    case let .success(credential):
  347|      0|                        self.handleRefreshSuccess(credential, insideLock: &mutableState)
  348|      0|                    case let .failure(error):
  349|      0|                        self.handleRefreshFailure(error, insideLock: &mutableState)
  350|      0|                    }
  351|      0|                }
  352|      0|            }
  353|      0|        }
  354|      0|    }
  355|       |
  356|      0|    private func isRefreshExcessive(insideLock mutableState: inout MutableState) -> Bool {
  357|      0|        guard let refreshWindow = mutableState.refreshWindow else { return false }
  358|      0|
  359|      0|        let refreshWindowMin = ProcessInfo.processInfo.systemUptime - refreshWindow.interval
  360|      0|
  361|      0|        let refreshAttemptsWithinWindow = mutableState.refreshTimestamps.reduce(into: 0) { attempts, refreshTimestamp in
  362|      0|            guard refreshWindowMin <= refreshTimestamp else { return }
  363|      0|            attempts += 1
  364|      0|        }
  365|      0|
  366|      0|        let isRefreshExcessive = refreshAttemptsWithinWindow >= refreshWindow.maximumAttempts
  367|      0|
  368|      0|        return isRefreshExcessive
  369|      0|    }
  370|       |
  371|      0|    private func handleRefreshSuccess(_ credential: Credential, insideLock mutableState: inout MutableState) {
  372|      0|        mutableState.credential = credential
  373|      0|
  374|      0|        let adaptOperations = mutableState.adaptOperations
  375|      0|        let requestsToRetry = mutableState.requestsToRetry
  376|      0|
  377|      0|        mutableState.adaptOperations.removeAll()
  378|      0|        mutableState.requestsToRetry.removeAll()
  379|      0|
  380|      0|        mutableState.isRefreshing = false
  381|      0|
  382|      0|        // Dispatch to queue to hop out of the mutable state lock
  383|      0|        queue.async {
  384|      0|            adaptOperations.forEach { self.adapt($0.urlRequest, for: $0.session, completion: $0.completion) }
  385|      0|            requestsToRetry.forEach { $0(.retry) }
  386|      0|        }
  387|      0|    }
  388|       |
  389|      0|    private func handleRefreshFailure(_ error: Error, insideLock mutableState: inout MutableState) {
  390|      0|        let adaptOperations = mutableState.adaptOperations
  391|      0|        let requestsToRetry = mutableState.requestsToRetry
  392|      0|
  393|      0|        mutableState.adaptOperations.removeAll()
  394|      0|        mutableState.requestsToRetry.removeAll()
  395|      0|
  396|      0|        mutableState.isRefreshing = false
  397|      0|
  398|      0|        // Dispatch to queue to hop out of the mutable state lock
  399|      0|        queue.async {
  400|      0|            adaptOperations.forEach { $0.completion(.failure(error)) }
  401|      0|            requestsToRetry.forEach { $0(.doNotRetryWithError(error)) }
  402|      0|        }
  403|      0|    }
  404|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/CachedResponseHandler.swift:
    1|       |//
    2|       |//  CachedResponseHandler.swift
    3|       |//
    4|       |//  Copyright (c) 2019 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A type that handles whether the data task should store the HTTP response in the cache.
   28|       |public protocol CachedResponseHandler {
   29|       |    /// Determines whether the HTTP response should be stored in the cache.
   30|       |    ///
   31|       |    /// The `completion` closure should be passed one of three possible options:
   32|       |    ///
   33|       |    ///   1. The cached response provided by the server (this is the most common use case).
   34|       |    ///   2. A modified version of the cached response (you may want to modify it in some way before caching).
   35|       |    ///   3. A `nil` value to prevent the cached response from being stored in the cache.
   36|       |    ///
   37|       |    /// - Parameters:
   38|       |    ///   - task:       The data task whose request resulted in the cached response.
   39|       |    ///   - response:   The cached response to potentially store in the cache.
   40|       |    ///   - completion: The closure to execute containing cached response, a modified response, or `nil`.
   41|       |    func dataTask(_ task: URLSessionDataTask,
   42|       |                  willCacheResponse response: CachedURLResponse,
   43|       |                  completion: @escaping (CachedURLResponse?) -> Void)
   44|       |}
   45|       |
   46|       |// MARK: -
   47|       |
   48|       |/// `ResponseCacher` is a convenience `CachedResponseHandler` making it easy to cache, not cache, or modify a cached
   49|       |/// response.
   50|       |public struct ResponseCacher {
   51|       |    /// Defines the behavior of the `ResponseCacher` type.
   52|       |    public enum Behavior {
   53|       |        /// Stores the cached response in the cache.
   54|       |        case cache
   55|       |        /// Prevents the cached response from being stored in the cache.
   56|       |        case doNotCache
   57|       |        /// Modifies the cached response before storing it in the cache.
   58|       |        case modify((URLSessionDataTask, CachedURLResponse) -> CachedURLResponse?)
   59|       |    }
   60|       |
   61|       |    /// Returns a `ResponseCacher` with a follow `Behavior`.
   62|       |    public static let cache = ResponseCacher(behavior: .cache)
   63|       |    /// Returns a `ResponseCacher` with a do not follow `Behavior`.
   64|       |    public static let doNotCache = ResponseCacher(behavior: .doNotCache)
   65|       |
   66|       |    /// The `Behavior` of the `ResponseCacher`.
   67|       |    public let behavior: Behavior
   68|       |
   69|       |    /// Creates a `ResponseCacher` instance from the `Behavior`.
   70|       |    ///
   71|       |    /// - Parameter behavior: The `Behavior`.
   72|      0|    public init(behavior: Behavior) {
   73|      0|        self.behavior = behavior
   74|      0|    }
   75|       |}
   76|       |
   77|       |extension ResponseCacher: CachedResponseHandler {
   78|       |    public func dataTask(_ task: URLSessionDataTask,
   79|       |                         willCacheResponse response: CachedURLResponse,
   80|      0|                         completion: @escaping (CachedURLResponse?) -> Void) {
   81|      0|        switch behavior {
   82|      0|        case .cache:
   83|      0|            completion(response)
   84|      0|        case .doNotCache:
   85|      0|            completion(nil)
   86|      0|        case let .modify(closure):
   87|      0|            let response = closure(task, response)
   88|      0|            completion(response)
   89|      0|        }
   90|      0|    }
   91|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Combine.swift:
    1|       |//
    2|       |//  Combine.swift
    3|       |//
    4|       |//  Copyright (c) 2020 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |#if canImport(Combine)
   26|       |
   27|       |import Combine
   28|       |import Dispatch
   29|       |import Foundation
   30|       |
   31|       |// MARK: - DataRequest / UploadRequest
   32|       |
   33|       |/// A Combine `Publisher` that publishes the `DataResponse<Value, AFError>` of the provided `DataRequest`.
   34|       |@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
   35|       |public struct DataResponsePublisher<Value>: Publisher {
   36|       |    public typealias Output = DataResponse<Value, AFError>
   37|       |    public typealias Failure = Never
   38|       |
   39|       |    private typealias Handler = (@escaping (_ response: DataResponse<Value, AFError>) -> Void) -> DataRequest
   40|       |
   41|       |    private let request: DataRequest
   42|       |    private let responseHandler: Handler
   43|       |
   44|       |    /// Creates an instance which will serialize responses using the provided `ResponseSerializer`.
   45|       |    ///
   46|       |    /// - Parameters:
   47|       |    ///   - request:    `DataRequest` for which to publish the response.
   48|       |    ///   - queue:      `DispatchQueue` on which the `DataResponse` value will be published. `.main` by default.
   49|       |    ///   - serializer: `ResponseSerializer` used to produce the published `DataResponse`.
   50|       |    public init<Serializer: ResponseSerializer>(_ request: DataRequest, queue: DispatchQueue, serializer: Serializer)
   51|      0|        where Value == Serializer.SerializedObject {
   52|      0|        self.request = request
   53|      0|        responseHandler = { request.response(queue: queue, responseSerializer: serializer, completionHandler: $0) }
   54|      0|    }
   55|       |
   56|       |    /// Creates an instance which will serialize responses using the provided `DataResponseSerializerProtocol`.
   57|       |    ///
   58|       |    /// - Parameters:
   59|       |    ///   - request:    `DataRequest` for which to publish the response.
   60|       |    ///   - queue:      `DispatchQueue` on which the `DataResponse` value will be published. `.main` by default.
   61|       |    ///   - serializer: `DataResponseSerializerProtocol` used to produce the published `DataResponse`.
   62|       |    public init<Serializer: DataResponseSerializerProtocol>(_ request: DataRequest,
   63|       |                                                            queue: DispatchQueue,
   64|       |                                                            serializer: Serializer)
   65|      0|        where Value == Serializer.SerializedObject {
   66|      0|        self.request = request
   67|      0|        responseHandler = { request.response(queue: queue, responseSerializer: serializer, completionHandler: $0) }
   68|      0|    }
   69|       |
   70|       |    /// Publishes only the `Result` of the `DataResponse` value.
   71|       |    ///
   72|       |    /// - Returns: The `AnyPublisher` publishing the `Result<Value, AFError>` value.
   73|      0|    public func result() -> AnyPublisher<Result<Value, AFError>, Never> {
   74|      0|        map { $0.result }.eraseToAnyPublisher()
   75|      0|    }
   76|       |
   77|       |    /// Publishes the `Result` of the `DataResponse` as a single `Value` or fail with the `AFError` instance.
   78|       |    ///
   79|       |    /// - Returns: The `AnyPublisher<Value, AFError>` publishing the stream.
   80|      0|    public func value() -> AnyPublisher<Value, AFError> {
   81|      0|        setFailureType(to: AFError.self).flatMap { $0.result.publisher }.eraseToAnyPublisher()
   82|      0|    }
   83|       |
   84|      0|    public func receive<S>(subscriber: S) where S: Subscriber, DataResponsePublisher.Failure == S.Failure, DataResponsePublisher.Output == S.Input {
   85|      0|        subscriber.receive(subscription: Inner(request: request,
   86|      0|                                               responseHandler: responseHandler,
   87|      0|                                               downstream: subscriber))
   88|      0|    }
   89|       |
   90|       |    private final class Inner<Downstream: Subscriber>: Subscription, Cancellable
   91|       |        where Downstream.Input == Output {
   92|       |        typealias Failure = Downstream.Failure
   93|       |
   94|       |        @Protected
   95|       |        private var downstream: Downstream?
   96|       |        private let request: DataRequest
   97|       |        private let responseHandler: Handler
   98|       |
   99|      0|        init(request: DataRequest, responseHandler: @escaping Handler, downstream: Downstream) {
  100|      0|            self.request = request
  101|      0|            self.responseHandler = responseHandler
  102|      0|            self.downstream = downstream
  103|      0|        }
  104|       |
  105|      0|        func request(_ demand: Subscribers.Demand) {
  106|      0|            assert(demand > 0)
  107|      0|
  108|      0|            guard let downstream = downstream else { return }
  109|      0|
  110|      0|            self.downstream = nil
  111|      0|            responseHandler { response in
  112|      0|                _ = downstream.receive(response)
  113|      0|                downstream.receive(completion: .finished)
  114|      0|            }.resume()
  115|      0|        }
  116|       |
  117|      0|        func cancel() {
  118|      0|            request.cancel()
  119|      0|            downstream = nil
  120|      0|        }
  121|       |    }
  122|       |}
  123|       |
  124|       |@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  125|       |extension DataResponsePublisher where Value == Data? {
  126|       |    /// Creates an instance which publishes a `DataResponse<Data?, AFError>` value without serialization.
  127|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  128|      0|    public init(_ request: DataRequest, queue: DispatchQueue) {
  129|      0|        self.request = request
  130|      0|        responseHandler = { request.response(queue: queue, completionHandler: $0) }
  131|      0|    }
  132|       |}
  133|       |
  134|       |extension DataRequest {
  135|       |    /// Creates a `DataResponsePublisher` for this instance using the given `ResponseSerializer` and `DispatchQueue`.
  136|       |    ///
  137|       |    /// - Parameters:
  138|       |    ///   - serializer: `ResponseSerializer` used to serialize response `Data`.
  139|       |    ///   - queue:      `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  140|       |    ///
  141|       |    /// - Returns:      The `DataResponsePublisher`.
  142|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  143|       |    public func publishResponse<Serializer: ResponseSerializer, T>(using serializer: Serializer, on queue: DispatchQueue = .main) -> DataResponsePublisher<T>
  144|      0|        where Serializer.SerializedObject == T {
  145|      0|        DataResponsePublisher(self, queue: queue, serializer: serializer)
  146|      0|    }
  147|       |
  148|       |    /// Creates a `DataResponsePublisher` for this instance and uses a `DataResponseSerializer` to serialize the
  149|       |    /// response.
  150|       |    ///
  151|       |    /// - Parameters:
  152|       |    ///   - queue:               `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  153|       |    ///   - preprocessor:        `DataPreprocessor` which filters the `Data` before serialization. `PassthroughPreprocessor()`
  154|       |    ///                          by default.
  155|       |    ///   - emptyResponseCodes:  `Set<Int>` of HTTP status codes for which empty responses are allowed. `[204, 205]` by
  156|       |    ///                          default.
  157|       |    ///   - emptyRequestMethods: `Set<HTTPMethod>` of `HTTPMethod`s for which empty responses are allowed, regardless of
  158|       |    ///                          status code. `[.head]` by default.
  159|       |    /// - Returns:               The `DataResponsePublisher`.
  160|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  161|       |    public func publishData(queue: DispatchQueue = .main,
  162|       |                            preprocessor: DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor,
  163|       |                            emptyResponseCodes: Set<Int> = DataResponseSerializer.defaultEmptyResponseCodes,
  164|      0|                            emptyRequestMethods: Set<HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> DataResponsePublisher<Data> {
  165|      0|        publishResponse(using: DataResponseSerializer(dataPreprocessor: preprocessor,
  166|      0|                                                      emptyResponseCodes: emptyResponseCodes,
  167|      0|                                                      emptyRequestMethods: emptyRequestMethods),
  168|      0|                        on: queue)
  169|      0|    }
  170|       |
  171|       |    /// Creates a `DataResponsePublisher` for this instance and uses a `StringResponseSerializer` to serialize the
  172|       |    /// response.
  173|       |    ///
  174|       |    /// - Parameters:
  175|       |    ///   - queue:               `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  176|       |    ///   - preprocessor:        `DataPreprocessor` which filters the `Data` before serialization. `PassthroughPreprocessor()`
  177|       |    ///                          by default.
  178|       |    ///   - encoding:            `String.Encoding` to parse the response. `nil` by default, in which case the encoding
  179|       |    ///                          will be determined by the server response, falling back to the default HTTP character
  180|       |    ///                          set, `ISO-8859-1`.
  181|       |    ///   - emptyResponseCodes:  `Set<Int>` of HTTP status codes for which empty responses are allowed. `[204, 205]` by
  182|       |    ///                          default.
  183|       |    ///   - emptyRequestMethods: `Set<HTTPMethod>` of `HTTPMethod`s for which empty responses are allowed, regardless of
  184|       |    ///                          status code. `[.head]` by default.
  185|       |    ///
  186|       |    /// - Returns:               The `DataResponsePublisher`.
  187|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  188|       |    public func publishString(queue: DispatchQueue = .main,
  189|       |                              preprocessor: DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor,
  190|       |                              encoding: String.Encoding? = nil,
  191|       |                              emptyResponseCodes: Set<Int> = StringResponseSerializer.defaultEmptyResponseCodes,
  192|      0|                              emptyRequestMethods: Set<HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> DataResponsePublisher<String> {
  193|      0|        publishResponse(using: StringResponseSerializer(dataPreprocessor: preprocessor,
  194|      0|                                                        encoding: encoding,
  195|      0|                                                        emptyResponseCodes: emptyResponseCodes,
  196|      0|                                                        emptyRequestMethods: emptyRequestMethods),
  197|      0|                        on: queue)
  198|      0|    }
  199|       |
  200|       |    /// Creates a `DataResponsePublisher` for this instance and uses a `DecodableResponseSerializer` to serialize the
  201|       |    /// response.
  202|       |    ///
  203|       |    /// - Parameters:
  204|       |    ///   - type:                `Decodable` type to which to decode response `Data`. Inferred from the context by default.
  205|       |    ///   - queue:               `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  206|       |    ///   - preprocessor:        `DataPreprocessor` which filters the `Data` before serialization. `PassthroughPreprocessor()`
  207|       |    ///                          by default.
  208|       |    ///   - decoder:             `DataDecoder` instance used to decode response `Data`. `JSONDecoder()` by default.
  209|       |    ///   - emptyResponseCodes:  `Set<Int>` of HTTP status codes for which empty responses are allowed. `[204, 205]` by
  210|       |    ///                          default.
  211|       |    ///   - emptyRequestMethods: `Set<HTTPMethod>` of `HTTPMethod`s for which empty responses are allowed, regardless of
  212|       |    ///                          status code. `[.head]` by default.
  213|       |    ///
  214|       |    /// - Returns:               The `DataResponsePublisher`.
  215|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  216|       |    public func publishDecodable<T: Decodable>(type: T.Type = T.self,
  217|       |                                               queue: DispatchQueue = .main,
  218|       |                                               preprocessor: DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor,
  219|       |                                               decoder: DataDecoder = JSONDecoder(),
  220|       |                                               emptyResponseCodes: Set<Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes,
  221|      0|                                               emptyResponseMethods: Set<HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> DataResponsePublisher<T> {
  222|      0|        publishResponse(using: DecodableResponseSerializer(dataPreprocessor: preprocessor,
  223|      0|                                                           decoder: decoder,
  224|      0|                                                           emptyResponseCodes: emptyResponseCodes,
  225|      0|                                                           emptyRequestMethods: emptyResponseMethods),
  226|      0|                        on: queue)
  227|      0|    }
  228|       |
  229|       |    /// Creates a `DataResponsePublisher` for this instance which does not serialize the response before publishing.
  230|       |    ///
  231|       |    ///   - queue: `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  232|       |    ///
  233|       |    /// - Returns: The `DataResponsePublisher`.
  234|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  235|      0|    public func publishUnserialized(queue: DispatchQueue = .main) -> DataResponsePublisher<Data?> {
  236|      0|        DataResponsePublisher(self, queue: queue)
  237|      0|    }
  238|       |}
  239|       |
  240|       |// A Combine `Publisher` that publishes a sequence of `Stream<Value, AFError>` values received by the provided `DataStreamRequest`.
  241|       |@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  242|       |public struct DataStreamPublisher<Value>: Publisher {
  243|       |    public typealias Output = DataStreamRequest.Stream<Value, AFError>
  244|       |    public typealias Failure = Never
  245|       |
  246|       |    private typealias Handler = (@escaping DataStreamRequest.Handler<Value, AFError>) -> DataStreamRequest
  247|       |
  248|       |    private let request: DataStreamRequest
  249|       |    private let streamHandler: Handler
  250|       |
  251|       |    /// Creates an instance which will serialize responses using the provided `DataStreamSerializer`.
  252|       |    ///
  253|       |    /// - Parameters:
  254|       |    ///   - request:    `DataStreamRequest` for which to publish the response.
  255|       |    ///   - queue:      `DispatchQueue` on which the `Stream<Value, AFError>` values will be published. `.main` by
  256|       |    ///                 default.
  257|       |    ///   - serializer: `DataStreamSerializer` used to produce the published `Stream<Value, AFError>` values.
  258|       |    public init<Serializer: DataStreamSerializer>(_ request: DataStreamRequest, queue: DispatchQueue, serializer: Serializer)
  259|      0|        where Value == Serializer.SerializedObject {
  260|      0|        self.request = request
  261|      0|        streamHandler = { request.responseStream(using: serializer, on: queue, stream: $0) }
  262|      0|    }
  263|       |
  264|       |    /// Publishes only the `Result` of the `DataStreamRequest.Stream`'s `Event`s.
  265|       |    ///
  266|       |    /// - Returns: The `AnyPublisher` publishing the `Result<Value, AFError>` value.
  267|      0|    public func result() -> AnyPublisher<Result<Value, AFError>, Never> {
  268|      0|        compactMap { stream in
  269|      0|            switch stream.event {
  270|      0|            case let .stream(result):
  271|      0|                return result
  272|      0|            // If the stream has completed with an error, send the error value downstream as a `.failure`.
  273|      0|            case let .complete(completion):
  274|      0|                return completion.error.map(Result.failure)
  ------------------
  | Unexecuted instantiation: $s9Alamofire19DataStreamPublisherV6result7Combine03AnyD0Vys6ResultOyxAA7AFErrorOGs5NeverOGyFALSgAA0bC7RequestC0C0Vy_xAKGcfU_AlKcALmcfu_
  ------------------
  | Unexecuted instantiation: $s9Alamofire19DataStreamPublisherV6result7Combine03AnyD0Vys6ResultOyxAA7AFErrorOGs5NeverOGyFALSgAA0bC7RequestC0C0Vy_xAKGcfU_AlKcALmcfu_AlKcfu0_
  ------------------
  275|      0|            }
  276|      0|        }
  277|      0|        .eraseToAnyPublisher()
  278|      0|    }
  279|       |
  280|       |    /// Publishes the streamed values of the `DataStreamRequest.Stream` as a sequence of `Value` or fail with the
  281|       |    /// `AFError` instance.
  282|       |    ///
  283|       |    /// - Returns: The `AnyPublisher<Value, AFError>` publishing the stream.
  284|      0|    public func value() -> AnyPublisher<Value, AFError> {
  285|      0|        result().setFailureType(to: AFError.self).flatMap { $0.publisher }.eraseToAnyPublisher()
  286|      0|    }
  287|       |
  288|      0|    public func receive<S>(subscriber: S) where S: Subscriber, DataStreamPublisher.Failure == S.Failure, DataStreamPublisher.Output == S.Input {
  289|      0|        subscriber.receive(subscription: Inner(request: request,
  290|      0|                                               streamHandler: streamHandler,
  291|      0|                                               downstream: subscriber))
  292|      0|    }
  293|       |
  294|       |    private final class Inner<Downstream: Subscriber>: Subscription, Cancellable
  295|       |        where Downstream.Input == Output {
  296|       |        typealias Failure = Downstream.Failure
  297|       |
  298|       |        @Protected
  299|       |        private var downstream: Downstream?
  300|       |        private let request: DataStreamRequest
  301|       |        private let streamHandler: Handler
  302|       |
  303|      0|        init(request: DataStreamRequest, streamHandler: @escaping Handler, downstream: Downstream) {
  304|      0|            self.request = request
  305|      0|            self.streamHandler = streamHandler
  306|      0|            self.downstream = downstream
  307|      0|        }
  308|       |
  309|      0|        func request(_ demand: Subscribers.Demand) {
  310|      0|            assert(demand > 0)
  311|      0|
  312|      0|            guard let downstream = downstream else { return }
  313|      0|
  314|      0|            self.downstream = nil
  315|      0|            streamHandler { stream in
  316|      0|                _ = downstream.receive(stream)
  317|      0|                if case .complete = stream.event {
  318|      0|                    downstream.receive(completion: .finished)
  319|      0|                }
  320|      0|            }.resume()
  321|      0|        }
  322|       |
  323|      0|        func cancel() {
  324|      0|            request.cancel()
  325|      0|            downstream = nil
  326|      0|        }
  327|       |    }
  328|       |}
  329|       |
  330|       |extension DataStreamRequest {
  331|       |    /// Creates a `DataStreamPublisher` for this instance using the given `DataStreamSerializer` and `DispatchQueue`.
  332|       |    ///
  333|       |    /// - Parameters:
  334|       |    ///   - serializer: `DataStreamSerializer` used to serialize the streamed `Data`.
  335|       |    ///   - queue:      `DispatchQueue` on which the `DataRequest.Stream` values will be published. `.main` by default.
  336|       |    /// - Returns:      The `DataStreamPublisher`.
  337|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  338|       |    public func publishStream<Serializer: DataStreamSerializer>(using serializer: Serializer,
  339|      0|                                                                on queue: DispatchQueue = .main) -> DataStreamPublisher<Serializer.SerializedObject> {
  340|      0|        DataStreamPublisher(self, queue: queue, serializer: serializer)
  341|      0|    }
  342|       |
  343|       |    /// Creates a `DataStreamPublisher` for this instance which uses a `PassthroughStreamSerializer` to stream `Data`
  344|       |    /// unserialized.
  345|       |    ///
  346|       |    /// - Parameters:
  347|       |    ///   - queue:      `DispatchQueue` on which the `DataRequest.Stream` values will be published. `.main` by default.
  348|       |    /// - Returns:      The `DataStreamPublisher`.
  349|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  350|      0|    public func publishData(queue: DispatchQueue = .main) -> DataStreamPublisher<Data> {
  351|      0|        publishStream(using: PassthroughStreamSerializer(), on: queue)
  352|      0|    }
  353|       |
  354|       |    /// Creates a `DataStreamPublisher` for this instance which uses a `StringStreamSerializer` to serialize stream
  355|       |    /// `Data` values into `String` values.
  356|       |    ///
  357|       |    /// - Parameters:
  358|       |    ///   - queue:      `DispatchQueue` on which the `DataRequest.Stream` values will be published. `.main` by default.
  359|       |    /// - Returns:      The `DataStreamPublisher`.
  360|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  361|      0|    public func publishString(queue: DispatchQueue = .main) -> DataStreamPublisher<String> {
  362|      0|        publishStream(using: StringStreamSerializer(), on: queue)
  363|      0|    }
  364|       |
  365|       |    /// Creates a `DataStreamPublisher` for this instance which uses a `DecodableStreamSerializer` with the provided
  366|       |    /// parameters to serialize stream `Data` values into the provided type.
  367|       |    ///
  368|       |    /// - Parameters:
  369|       |    ///   - type:         `Decodable` type to which to decode stream `Data`. Inferred from the context by default.
  370|       |    ///   - queue:        `DispatchQueue` on which the `DataRequest.Stream` values will be published. `.main` by default.
  371|       |    ///   - decoder:      `DataDecoder` instance used to decode stream `Data`. `JSONDecoder()` by default.
  372|       |    ///   - preprocessor: `DataPreprocessor` which filters incoming stream `Data` before serialization.
  373|       |    ///                   `PassthroughPreprocessor()` by default.
  374|       |    /// - Returns:        The `DataStreamPublisher`.
  375|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  376|       |    public func publishDecodable<T: Decodable>(type: T.Type = T.self,
  377|       |                                               queue: DispatchQueue = .main,
  378|       |                                               decoder: DataDecoder = JSONDecoder(),
  379|      0|                                               preprocessor: DataPreprocessor = PassthroughPreprocessor()) -> DataStreamPublisher<T> {
  380|      0|        publishStream(using: DecodableStreamSerializer(decoder: decoder,
  381|      0|                                                       dataPreprocessor: preprocessor),
  382|      0|                      on: queue)
  383|      0|    }
  384|       |}
  385|       |
  386|       |/// A Combine `Publisher` that publishes the `DownloadResponse<Value, AFError>` of the provided `DownloadRequest`.
  387|       |@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  388|       |public struct DownloadResponsePublisher<Value>: Publisher {
  389|       |    public typealias Output = DownloadResponse<Value, AFError>
  390|       |    public typealias Failure = Never
  391|       |
  392|       |    private typealias Handler = (@escaping (_ response: DownloadResponse<Value, AFError>) -> Void) -> DownloadRequest
  393|       |
  394|       |    private let request: DownloadRequest
  395|       |    private let responseHandler: Handler
  396|       |
  397|       |    /// Creates an instance which will serialize responses using the provided `ResponseSerializer`.
  398|       |    ///
  399|       |    /// - Parameters:
  400|       |    ///   - request:    `DownloadRequest` for which to publish the response.
  401|       |    ///   - queue:      `DispatchQueue` on which the `DownloadResponse` value will be published. `.main` by default.
  402|       |    ///   - serializer: `ResponseSerializer` used to produce the published `DownloadResponse`.
  403|       |    public init<Serializer: ResponseSerializer>(_ request: DownloadRequest, queue: DispatchQueue, serializer: Serializer)
  404|      0|        where Value == Serializer.SerializedObject {
  405|      0|        self.request = request
  406|      0|        responseHandler = { request.response(queue: queue, responseSerializer: serializer, completionHandler: $0) }
  407|      0|    }
  408|       |
  409|       |    /// Creates an instance which will serialize responses using the provided `DownloadResponseSerializerProtocol` value.
  410|       |    ///
  411|       |    /// - Parameters:
  412|       |    ///   - request:    `DownloadRequest` for which to publish the response.
  413|       |    ///   - queue:      `DispatchQueue` on which the `DataResponse` value will be published. `.main` by default.
  414|       |    ///   - serializer: `DownloadResponseSerializerProtocol` used to produce the published `DownloadResponse`.
  415|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  416|       |    public init<Serializer: DownloadResponseSerializerProtocol>(_ request: DownloadRequest,
  417|       |                                                                queue: DispatchQueue,
  418|       |                                                                serializer: Serializer)
  419|      0|        where Value == Serializer.SerializedObject {
  420|      0|        self.request = request
  421|      0|        responseHandler = { request.response(queue: queue, responseSerializer: serializer, completionHandler: $0) }
  422|      0|    }
  423|       |
  424|       |    /// Publishes only the `Result` of the `DownloadResponse` value.
  425|       |    ///
  426|       |    /// - Returns: The `AnyPublisher` publishing the `Result<Value, AFError>` value.
  427|      0|    public func result() -> AnyPublisher<Result<Value, AFError>, Never> {
  428|      0|        map { $0.result }.eraseToAnyPublisher()
  429|      0|    }
  430|       |
  431|       |    /// Publishes the `Result` of the `DownloadResponse` as a single `Value` or fail with the `AFError` instance.
  432|       |    ///
  433|       |    /// - Returns: The `AnyPublisher<Value, AFError>` publishing the stream.
  434|      0|    public func value() -> AnyPublisher<Value, AFError> {
  435|      0|        setFailureType(to: AFError.self).flatMap { $0.result.publisher }.eraseToAnyPublisher()
  436|      0|    }
  437|       |
  438|      0|    public func receive<S>(subscriber: S) where S: Subscriber, DownloadResponsePublisher.Failure == S.Failure, DownloadResponsePublisher.Output == S.Input {
  439|      0|        subscriber.receive(subscription: Inner(request: request,
  440|      0|                                               responseHandler: responseHandler,
  441|      0|                                               downstream: subscriber))
  442|      0|    }
  443|       |
  444|       |    private final class Inner<Downstream: Subscriber>: Subscription, Cancellable
  445|       |        where Downstream.Input == Output {
  446|       |        typealias Failure = Downstream.Failure
  447|       |
  448|       |        @Protected
  449|       |        private var downstream: Downstream?
  450|       |        private let request: DownloadRequest
  451|       |        private let responseHandler: Handler
  452|       |
  453|      0|        init(request: DownloadRequest, responseHandler: @escaping Handler, downstream: Downstream) {
  454|      0|            self.request = request
  455|      0|            self.responseHandler = responseHandler
  456|      0|            self.downstream = downstream
  457|      0|        }
  458|       |
  459|      0|        func request(_ demand: Subscribers.Demand) {
  460|      0|            assert(demand > 0)
  461|      0|
  462|      0|            guard let downstream = downstream else { return }
  463|      0|
  464|      0|            self.downstream = nil
  465|      0|            responseHandler { response in
  466|      0|                _ = downstream.receive(response)
  467|      0|                downstream.receive(completion: .finished)
  468|      0|            }.resume()
  469|      0|        }
  470|       |
  471|      0|        func cancel() {
  472|      0|            request.cancel()
  473|      0|            downstream = nil
  474|      0|        }
  475|       |    }
  476|       |}
  477|       |
  478|       |extension DownloadRequest {
  479|       |    /// Creates a `DownloadResponsePublisher` for this instance using the given `ResponseSerializer` and `DispatchQueue`.
  480|       |    ///
  481|       |    /// - Parameters:
  482|       |    ///   - serializer: `ResponseSerializer` used to serialize the response `Data` from disk.
  483|       |    ///   - queue:      `DispatchQueue` on which the `DownloadResponse` will be published.`.main` by default.
  484|       |    ///
  485|       |    /// - Returns:      The `DownloadResponsePublisher`.
  486|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  487|       |    public func publishResponse<Serializer: ResponseSerializer, T>(using serializer: Serializer, on queue: DispatchQueue = .main) -> DownloadResponsePublisher<T>
  488|      0|        where Serializer.SerializedObject == T {
  489|      0|        DownloadResponsePublisher(self, queue: queue, serializer: serializer)
  490|      0|    }
  491|       |
  492|       |    /// Creates a `DownloadResponsePublisher` for this instance using the given `DownloadResponseSerializerProtocol` and
  493|       |    /// `DispatchQueue`.
  494|       |    ///
  495|       |    /// - Parameters:
  496|       |    ///   - serializer: `DownloadResponseSerializer` used to serialize the response `Data` from disk.
  497|       |    ///   - queue:      `DispatchQueue` on which the `DownloadResponse` will be published.`.main` by default.
  498|       |    ///
  499|       |    /// - Returns:      The `DownloadResponsePublisher`.
  500|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  501|       |    public func publishResponse<Serializer: DownloadResponseSerializerProtocol, T>(using serializer: Serializer, on queue: DispatchQueue = .main) -> DownloadResponsePublisher<T>
  502|      0|        where Serializer.SerializedObject == T {
  503|      0|        DownloadResponsePublisher(self, queue: queue, serializer: serializer)
  504|      0|    }
  505|       |
  506|       |    /// Creates a `DownloadResponsePublisher` for this instance and uses a `URLResponseSerializer` to serialize the
  507|       |    /// response.
  508|       |    ///
  509|       |    /// - Parameter queue: `DispatchQueue` on which the `DownloadResponse` will be published. `.main` by default.
  510|       |    ///
  511|       |    /// - Returns:         The `DownloadResponsePublisher`.
  512|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  513|      0|    public func publishURL(queue: DispatchQueue = .main) -> DownloadResponsePublisher<URL> {
  514|      0|        publishResponse(using: URLResponseSerializer(), on: queue)
  515|      0|    }
  516|       |
  517|       |    /// Creates a `DownloadResponsePublisher` for this instance and uses a `DataResponseSerializer` to serialize the
  518|       |    /// response.
  519|       |    ///
  520|       |    /// - Parameters:
  521|       |    ///   - queue:               `DispatchQueue` on which the `DownloadResponse` will be published. `.main` by default.
  522|       |    ///   - preprocessor:        `DataPreprocessor` which filters the `Data` before serialization. `PassthroughPreprocessor()`
  523|       |    ///                          by default.
  524|       |    ///   - emptyResponseCodes:  `Set<Int>` of HTTP status codes for which empty responses are allowed. `[204, 205]` by
  525|       |    ///                          default.
  526|       |    ///   - emptyRequestMethods: `Set<HTTPMethod>` of `HTTPMethod`s for which empty responses are allowed, regardless of
  527|       |    ///                          status code. `[.head]` by default.
  528|       |    ///
  529|       |    /// - Returns:               The `DownloadResponsePublisher`.
  530|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  531|       |    public func publishData(queue: DispatchQueue = .main,
  532|       |                            preprocessor: DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor,
  533|       |                            emptyResponseCodes: Set<Int> = DataResponseSerializer.defaultEmptyResponseCodes,
  534|      0|                            emptyRequestMethods: Set<HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> DownloadResponsePublisher<Data> {
  535|      0|        publishResponse(using: DataResponseSerializer(dataPreprocessor: preprocessor,
  536|      0|                                                      emptyResponseCodes: emptyResponseCodes,
  537|      0|                                                      emptyRequestMethods: emptyRequestMethods),
  538|      0|                        on: queue)
  539|      0|    }
  540|       |
  541|       |    /// Creates a `DataResponsePublisher` for this instance and uses a `StringResponseSerializer` to serialize the
  542|       |    /// response.
  543|       |    ///
  544|       |    /// - Parameters:
  545|       |    ///   - queue:               `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  546|       |    ///   - preprocessor:        `DataPreprocessor` which filters the `Data` before serialization. `PassthroughPreprocessor()`
  547|       |    ///                          by default.
  548|       |    ///   - encoding:            `String.Encoding` to parse the response. `nil` by default, in which case the encoding
  549|       |    ///                          will be determined by the server response, falling back to the default HTTP character
  550|       |    ///                          set, `ISO-8859-1`.
  551|       |    ///   - emptyResponseCodes:  `Set<Int>` of HTTP status codes for which empty responses are allowed. `[204, 205]` by
  552|       |    ///                          default.
  553|       |    ///   - emptyRequestMethods: `Set<HTTPMethod>` of `HTTPMethod`s for which empty responses are allowed, regardless of
  554|       |    ///                          status code. `[.head]` by default.
  555|       |    ///
  556|       |    /// - Returns:               The `DownloadResponsePublisher`.
  557|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  558|       |    public func publishString(queue: DispatchQueue = .main,
  559|       |                              preprocessor: DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor,
  560|       |                              encoding: String.Encoding? = nil,
  561|       |                              emptyResponseCodes: Set<Int> = StringResponseSerializer.defaultEmptyResponseCodes,
  562|      0|                              emptyRequestMethods: Set<HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> DownloadResponsePublisher<String> {
  563|      0|        publishResponse(using: StringResponseSerializer(dataPreprocessor: preprocessor,
  564|      0|                                                        encoding: encoding,
  565|      0|                                                        emptyResponseCodes: emptyResponseCodes,
  566|      0|                                                        emptyRequestMethods: emptyRequestMethods),
  567|      0|                        on: queue)
  568|      0|    }
  569|       |
  570|       |    /// Creates a `DataResponsePublisher` for this instance and uses a `DecodableResponseSerializer` to serialize the
  571|       |    /// response.
  572|       |    ///
  573|       |    /// - Parameters:
  574|       |    ///   - type:                `Decodable` type to which to decode response `Data`. Inferred from the context by default.
  575|       |    ///   - queue:               `DispatchQueue` on which the `DataResponse` will be published. `.main` by default.
  576|       |    ///   - preprocessor:        `DataPreprocessor` which filters the `Data` before serialization. `PassthroughPreprocessor()`
  577|       |    ///                          by default.
  578|       |    ///   - decoder:             `DataDecoder` instance used to decode response `Data`. `JSONDecoder()` by default.
  579|       |    ///   - emptyResponseCodes:  `Set<Int>` of HTTP status codes for which empty responses are allowed. `[204, 205]` by
  580|       |    ///                          default.
  581|       |    ///   - emptyRequestMethods: `Set<HTTPMethod>` of `HTTPMethod`s for which empty responses are allowed, regardless of
  582|       |    ///                          status code. `[.head]` by default.
  583|       |    ///
  584|       |    /// - Returns:               The `DownloadResponsePublisher`.
  585|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  586|       |    public func publishDecodable<T: Decodable>(type: T.Type = T.self,
  587|       |                                               queue: DispatchQueue = .main,
  588|       |                                               preprocessor: DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor,
  589|       |                                               decoder: DataDecoder = JSONDecoder(),
  590|       |                                               emptyResponseCodes: Set<Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes,
  591|      0|                                               emptyResponseMethods: Set<HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> DownloadResponsePublisher<T> {
  592|      0|        publishResponse(using: DecodableResponseSerializer(dataPreprocessor: preprocessor,
  593|      0|                                                           decoder: decoder,
  594|      0|                                                           emptyResponseCodes: emptyResponseCodes,
  595|      0|                                                           emptyRequestMethods: emptyResponseMethods),
  596|      0|                        on: queue)
  597|      0|    }
  598|       |}
  599|       |
  600|       |@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  601|       |extension DownloadResponsePublisher where Value == URL? {
  602|       |    /// Creates an instance which publishes a `DownloadResponse<URL?, AFError>` value without serialization.
  603|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  604|      0|    public init(_ request: DownloadRequest, queue: DispatchQueue) {
  605|      0|        self.request = request
  606|      0|        responseHandler = { request.response(queue: queue, completionHandler: $0) }
  607|      0|    }
  608|       |}
  609|       |
  610|       |extension DownloadRequest {
  611|       |    /// Creates a `DownloadResponsePublisher` for this instance which does not serialize the response before publishing.
  612|       |    ///
  613|       |    /// - Parameter queue: `DispatchQueue` on which the `DownloadResponse` will be published. `.main` by default.
  614|       |    ///
  615|       |    /// - Returns:         The `DownloadResponsePublisher`.
  616|       |    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  617|      0|    public func publishUnserialized(on queue: DispatchQueue = .main) -> DownloadResponsePublisher<URL?> {
  618|      0|        DownloadResponsePublisher(self, queue: queue)
  619|      0|    }
  620|       |}
  621|       |
  622|       |#endif

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/DispatchQueue+Alamofire.swift:
    1|       |//
    2|       |//  DispatchQueue+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Dispatch
   26|       |import Foundation
   27|       |
   28|       |extension DispatchQueue {
   29|       |    /// Execute the provided closure after a `TimeInterval`.
   30|       |    ///
   31|       |    /// - Parameters:
   32|       |    ///   - delay:   `TimeInterval` to delay execution.
   33|       |    ///   - closure: Closure to execute.
   34|      0|    func after(_ delay: TimeInterval, execute closure: @escaping () -> Void) {
   35|      0|        asyncAfter(deadline: .now() + delay, execute: closure)
   36|      0|    }
   37|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/EventMonitor.swift:
    1|       |//
    2|       |//  EventMonitor.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Protocol outlining the lifetime events inside Alamofire. It includes both events received from the various
   28|       |/// `URLSession` delegate protocols as well as various events from the lifetime of `Request` and its subclasses.
   29|       |public protocol EventMonitor {
   30|       |    /// The `DispatchQueue` onto which Alamofire's root `CompositeEventMonitor` will dispatch events. `.main` by default.
   31|       |    var queue: DispatchQueue { get }
   32|       |
   33|       |    // MARK: - URLSession Events
   34|       |
   35|       |    // MARK: URLSessionDelegate Events
   36|       |
   37|       |    /// Event called during `URLSessionDelegate`'s `urlSession(_:didBecomeInvalidWithError:)` method.
   38|       |    func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?)
   39|       |
   40|       |    // MARK: URLSessionTaskDelegate Events
   41|       |
   42|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:task:didReceive:completionHandler:)` method.
   43|       |    func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge)
   44|       |
   45|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)` method.
   46|       |    func urlSession(_ session: URLSession,
   47|       |                    task: URLSessionTask,
   48|       |                    didSendBodyData bytesSent: Int64,
   49|       |                    totalBytesSent: Int64,
   50|       |                    totalBytesExpectedToSend: Int64)
   51|       |
   52|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:task:needNewBodyStream:)` method.
   53|       |    func urlSession(_ session: URLSession, taskNeedsNewBodyStream task: URLSessionTask)
   54|       |
   55|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)` method.
   56|       |    func urlSession(_ session: URLSession,
   57|       |                    task: URLSessionTask,
   58|       |                    willPerformHTTPRedirection response: HTTPURLResponse,
   59|       |                    newRequest request: URLRequest)
   60|       |
   61|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:task:didFinishCollecting:)` method.
   62|       |    func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)
   63|       |
   64|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:task:didCompleteWithError:)` method.
   65|       |    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)
   66|       |
   67|       |    /// Event called during `URLSessionTaskDelegate`'s `urlSession(_:taskIsWaitingForConnectivity:)` method.
   68|       |    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
   69|       |    func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask)
   70|       |
   71|       |    // MARK: URLSessionDataDelegate Events
   72|       |
   73|       |    /// Event called during `URLSessionDataDelegate`'s `urlSession(_:dataTask:didReceive:)` method.
   74|       |    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)
   75|       |
   76|       |    /// Event called during `URLSessionDataDelegate`'s `urlSession(_:dataTask:willCacheResponse:completionHandler:)` method.
   77|       |    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse)
   78|       |
   79|       |    // MARK: URLSessionDownloadDelegate Events
   80|       |
   81|       |    /// Event called during `URLSessionDownloadDelegate`'s `urlSession(_:downloadTask:didResumeAtOffset:expectedTotalBytes:)` method.
   82|       |    func urlSession(_ session: URLSession,
   83|       |                    downloadTask: URLSessionDownloadTask,
   84|       |                    didResumeAtOffset fileOffset: Int64,
   85|       |                    expectedTotalBytes: Int64)
   86|       |
   87|       |    /// Event called during `URLSessionDownloadDelegate`'s `urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)` method.
   88|       |    func urlSession(_ session: URLSession,
   89|       |                    downloadTask: URLSessionDownloadTask,
   90|       |                    didWriteData bytesWritten: Int64,
   91|       |                    totalBytesWritten: Int64,
   92|       |                    totalBytesExpectedToWrite: Int64)
   93|       |
   94|       |    /// Event called during `URLSessionDownloadDelegate`'s `urlSession(_:downloadTask:didFinishDownloadingTo:)` method.
   95|       |    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL)
   96|       |
   97|       |    // MARK: - Request Events
   98|       |
   99|       |    /// Event called when a `URLRequest` is first created for a `Request`. If a `RequestAdapter` is active, the
  100|       |    /// `URLRequest` will be adapted before being issued.
  101|       |    func request(_ request: Request, didCreateInitialURLRequest urlRequest: URLRequest)
  102|       |
  103|       |    /// Event called when the attempt to create a `URLRequest` from a `Request`'s original `URLRequestConvertible` value fails.
  104|       |    func request(_ request: Request, didFailToCreateURLRequestWithError error: AFError)
  105|       |
  106|       |    /// Event called when a `RequestAdapter` adapts the `Request`'s initial `URLRequest`.
  107|       |    func request(_ request: Request, didAdaptInitialRequest initialRequest: URLRequest, to adaptedRequest: URLRequest)
  108|       |
  109|       |    /// Event called when a `RequestAdapter` fails to adapt the `Request`'s initial `URLRequest`.
  110|       |    func request(_ request: Request, didFailToAdaptURLRequest initialRequest: URLRequest, withError error: AFError)
  111|       |
  112|       |    /// Event called when a final `URLRequest` is created for a `Request`.
  113|       |    func request(_ request: Request, didCreateURLRequest urlRequest: URLRequest)
  114|       |
  115|       |    /// Event called when a `URLSessionTask` subclass instance is created for a `Request`.
  116|       |    func request(_ request: Request, didCreateTask task: URLSessionTask)
  117|       |
  118|       |    /// Event called when a `Request` receives a `URLSessionTaskMetrics` value.
  119|       |    func request(_ request: Request, didGatherMetrics metrics: URLSessionTaskMetrics)
  120|       |
  121|       |    /// Event called when a `Request` fails due to an error created by Alamofire. e.g. When certificate pinning fails.
  122|       |    func request(_ request: Request, didFailTask task: URLSessionTask, earlyWithError error: AFError)
  123|       |
  124|       |    /// Event called when a `Request`'s task completes, possibly with an error. A `Request` may receive this event
  125|       |    /// multiple times if it is retried.
  126|       |    func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?)
  127|       |
  128|       |    /// Event called when a `Request` is about to be retried.
  129|       |    func requestIsRetrying(_ request: Request)
  130|       |
  131|       |    /// Event called when a `Request` finishes and response serializers are being called.
  132|       |    func requestDidFinish(_ request: Request)
  133|       |
  134|       |    /// Event called when a `Request` receives a `resume` call.
  135|       |    func requestDidResume(_ request: Request)
  136|       |
  137|       |    /// Event called when a `Request`'s associated `URLSessionTask` is resumed.
  138|       |    func request(_ request: Request, didResumeTask task: URLSessionTask)
  139|       |
  140|       |    /// Event called when a `Request` receives a `suspend` call.
  141|       |    func requestDidSuspend(_ request: Request)
  142|       |
  143|       |    /// Event called when a `Request`'s associated `URLSessionTask` is suspended.
  144|       |    func request(_ request: Request, didSuspendTask task: URLSessionTask)
  145|       |
  146|       |    /// Event called when a `Request` receives a `cancel` call.
  147|       |    func requestDidCancel(_ request: Request)
  148|       |
  149|       |    /// Event called when a `Request`'s associated `URLSessionTask` is cancelled.
  150|       |    func request(_ request: Request, didCancelTask task: URLSessionTask)
  151|       |
  152|       |    // MARK: DataRequest Events
  153|       |
  154|       |    /// Event called when a `DataRequest` calls a `Validation`.
  155|       |    func request(_ request: DataRequest,
  156|       |                 didValidateRequest urlRequest: URLRequest?,
  157|       |                 response: HTTPURLResponse,
  158|       |                 data: Data?,
  159|       |                 withResult result: Request.ValidationResult)
  160|       |
  161|       |    /// Event called when a `DataRequest` creates a `DataResponse<Data?>` value without calling a `ResponseSerializer`.
  162|       |    func request(_ request: DataRequest, didParseResponse response: DataResponse<Data?, AFError>)
  163|       |
  164|       |    /// Event called when a `DataRequest` calls a `ResponseSerializer` and creates a generic `DataResponse<Value, AFError>`.
  165|       |    func request<Value>(_ request: DataRequest, didParseResponse response: DataResponse<Value, AFError>)
  166|       |
  167|       |    // MARK: DataStreamRequest Events
  168|       |
  169|       |    /// Event called when a `DataStreamRequest` calls a `Validation` closure.
  170|       |    ///
  171|       |    /// - Parameters:
  172|       |    ///   - request:    `DataStreamRequest` which is calling the `Validation`.
  173|       |    ///   - urlRequest: `URLRequest` of the request being validated.
  174|       |    ///   - response:   `HTTPURLResponse` of the request being validated.
  175|       |    ///   - result:      Produced `ValidationResult`.
  176|       |    func request(_ request: DataStreamRequest,
  177|       |                 didValidateRequest urlRequest: URLRequest?,
  178|       |                 response: HTTPURLResponse,
  179|       |                 withResult result: Request.ValidationResult)
  180|       |
  181|       |    /// Event called when a `DataStreamSerializer` produces a value from streamed `Data`.
  182|       |    ///
  183|       |    /// - Parameters:
  184|       |    ///   - request: `DataStreamRequest` for which the value was serialized.
  185|       |    ///   - result:  `Result` of the serialization attempt.
  186|       |    func request<Value>(_ request: DataStreamRequest, didParseStream result: Result<Value, AFError>)
  187|       |
  188|       |    // MARK: UploadRequest Events
  189|       |
  190|       |    /// Event called when an `UploadRequest` creates its `Uploadable` value, indicating the type of upload it represents.
  191|       |    func request(_ request: UploadRequest, didCreateUploadable uploadable: UploadRequest.Uploadable)
  192|       |
  193|       |    /// Event called when an `UploadRequest` failed to create its `Uploadable` value due to an error.
  194|       |    func request(_ request: UploadRequest, didFailToCreateUploadableWithError error: AFError)
  195|       |
  196|       |    /// Event called when an `UploadRequest` provides the `InputStream` from its `Uploadable` value. This only occurs if
  197|       |    /// the `InputStream` does not wrap a `Data` value or file `URL`.
  198|       |    func request(_ request: UploadRequest, didProvideInputStream stream: InputStream)
  199|       |
  200|       |    // MARK: DownloadRequest Events
  201|       |
  202|       |    /// Event called when a `DownloadRequest`'s `URLSessionDownloadTask` finishes and the temporary file has been moved.
  203|       |    func request(_ request: DownloadRequest, didFinishDownloadingUsing task: URLSessionTask, with result: Result<URL, AFError>)
  204|       |
  205|       |    /// Event called when a `DownloadRequest`'s `Destination` closure is called and creates the destination URL the
  206|       |    /// downloaded file will be moved to.
  207|       |    func request(_ request: DownloadRequest, didCreateDestinationURL url: URL)
  208|       |
  209|       |    /// Event called when a `DownloadRequest` calls a `Validation`.
  210|       |    func request(_ request: DownloadRequest,
  211|       |                 didValidateRequest urlRequest: URLRequest?,
  212|       |                 response: HTTPURLResponse,
  213|       |                 fileURL: URL?,
  214|       |                 withResult result: Request.ValidationResult)
  215|       |
  216|       |    /// Event called when a `DownloadRequest` creates a `DownloadResponse<URL?, AFError>` without calling a `ResponseSerializer`.
  217|       |    func request(_ request: DownloadRequest, didParseResponse response: DownloadResponse<URL?, AFError>)
  218|       |
  219|       |    /// Event called when a `DownloadRequest` calls a `DownloadResponseSerializer` and creates a generic `DownloadResponse<Value, AFError>`
  220|       |    func request<Value>(_ request: DownloadRequest, didParseResponse response: DownloadResponse<Value, AFError>)
  221|       |}
  222|       |
  223|       |extension EventMonitor {
  224|       |    /// The default queue on which `CompositeEventMonitor`s will call the `EventMonitor` methods. `.main` by default.
  225|      0|    public var queue: DispatchQueue { .main }
  226|       |
  227|       |    // MARK: Default Implementations
  228|       |
  229|      0|    public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {}
  230|       |    public func urlSession(_ session: URLSession,
  231|       |                           task: URLSessionTask,
  232|      0|                           didReceive challenge: URLAuthenticationChallenge) {}
  233|       |    public func urlSession(_ session: URLSession,
  234|       |                           task: URLSessionTask,
  235|       |                           didSendBodyData bytesSent: Int64,
  236|       |                           totalBytesSent: Int64,
  237|      0|                           totalBytesExpectedToSend: Int64) {}
  238|      0|    public func urlSession(_ session: URLSession, taskNeedsNewBodyStream task: URLSessionTask) {}
  239|       |    public func urlSession(_ session: URLSession,
  240|       |                           task: URLSessionTask,
  241|       |                           willPerformHTTPRedirection response: HTTPURLResponse,
  242|      0|                           newRequest request: URLRequest) {}
  243|       |    public func urlSession(_ session: URLSession,
  244|       |                           task: URLSessionTask,
  245|      0|                           didFinishCollecting metrics: URLSessionTaskMetrics) {}
  246|      0|    public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {}
  247|      0|    public func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {}
  248|      0|    public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {}
  249|       |    public func urlSession(_ session: URLSession,
  250|       |                           dataTask: URLSessionDataTask,
  251|      0|                           willCacheResponse proposedResponse: CachedURLResponse) {}
  252|       |    public func urlSession(_ session: URLSession,
  253|       |                           downloadTask: URLSessionDownloadTask,
  254|       |                           didResumeAtOffset fileOffset: Int64,
  255|      0|                           expectedTotalBytes: Int64) {}
  256|       |    public func urlSession(_ session: URLSession,
  257|       |                           downloadTask: URLSessionDownloadTask,
  258|       |                           didWriteData bytesWritten: Int64,
  259|       |                           totalBytesWritten: Int64,
  260|      0|                           totalBytesExpectedToWrite: Int64) {}
  261|       |    public func urlSession(_ session: URLSession,
  262|       |                           downloadTask: URLSessionDownloadTask,
  263|      0|                           didFinishDownloadingTo location: URL) {}
  264|      0|    public func request(_ request: Request, didCreateInitialURLRequest urlRequest: URLRequest) {}
  265|      0|    public func request(_ request: Request, didFailToCreateURLRequestWithError error: AFError) {}
  266|       |    public func request(_ request: Request,
  267|       |                        didAdaptInitialRequest initialRequest: URLRequest,
  268|      0|                        to adaptedRequest: URLRequest) {}
  269|       |    public func request(_ request: Request,
  270|       |                        didFailToAdaptURLRequest initialRequest: URLRequest,
  271|      0|                        withError error: AFError) {}
  272|      0|    public func request(_ request: Request, didCreateURLRequest urlRequest: URLRequest) {}
  273|      0|    public func request(_ request: Request, didCreateTask task: URLSessionTask) {}
  274|      0|    public func request(_ request: Request, didGatherMetrics metrics: URLSessionTaskMetrics) {}
  275|      0|    public func request(_ request: Request, didFailTask task: URLSessionTask, earlyWithError error: AFError) {}
  276|      0|    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {}
  277|      0|    public func requestIsRetrying(_ request: Request) {}
  278|      0|    public func requestDidFinish(_ request: Request) {}
  279|      0|    public func requestDidResume(_ request: Request) {}
  280|      0|    public func request(_ request: Request, didResumeTask task: URLSessionTask) {}
  281|      0|    public func requestDidSuspend(_ request: Request) {}
  282|      0|    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {}
  283|      0|    public func requestDidCancel(_ request: Request) {}
  284|      0|    public func request(_ request: Request, didCancelTask task: URLSessionTask) {}
  285|       |    public func request(_ request: DataRequest,
  286|       |                        didValidateRequest urlRequest: URLRequest?,
  287|       |                        response: HTTPURLResponse,
  288|       |                        data: Data?,
  289|      0|                        withResult result: Request.ValidationResult) {}
  290|      0|    public func request(_ request: DataRequest, didParseResponse response: DataResponse<Data?, AFError>) {}
  291|      0|    public func request<Value>(_ request: DataRequest, didParseResponse response: DataResponse<Value, AFError>) {}
  292|       |    public func request(_ request: DataStreamRequest,
  293|       |                        didValidateRequest urlRequest: URLRequest?,
  294|       |                        response: HTTPURLResponse,
  295|      0|                        withResult result: Request.ValidationResult) {}
  296|      0|    public func request<Value>(_ request: DataStreamRequest, didParseStream result: Result<Value, AFError>) {}
  297|      0|    public func request(_ request: UploadRequest, didCreateUploadable uploadable: UploadRequest.Uploadable) {}
  298|      0|    public func request(_ request: UploadRequest, didFailToCreateUploadableWithError error: AFError) {}
  299|      0|    public func request(_ request: UploadRequest, didProvideInputStream stream: InputStream) {}
  300|      0|    public func request(_ request: DownloadRequest, didFinishDownloadingUsing task: URLSessionTask, with result: Result<URL, AFError>) {}
  301|      0|    public func request(_ request: DownloadRequest, didCreateDestinationURL url: URL) {}
  302|       |    public func request(_ request: DownloadRequest,
  303|       |                        didValidateRequest urlRequest: URLRequest?,
  304|       |                        response: HTTPURLResponse,
  305|       |                        fileURL: URL?,
  306|      0|                        withResult result: Request.ValidationResult) {}
  307|      0|    public func request(_ request: DownloadRequest, didParseResponse response: DownloadResponse<URL?, AFError>) {}
  308|      0|    public func request<Value>(_ request: DownloadRequest, didParseResponse response: DownloadResponse<Value, AFError>) {}
  309|       |}
  310|       |
  311|       |/// An `EventMonitor` which can contain multiple `EventMonitor`s and calls their methods on their queues.
  312|       |public final class CompositeEventMonitor: EventMonitor {
  313|      0|    public let queue = DispatchQueue(label: "org.alamofire.compositeEventMonitor", qos: .utility)
  314|       |
  315|       |    let monitors: [EventMonitor]
  316|       |
  317|      0|    init(monitors: [EventMonitor]) {
  318|      0|        self.monitors = monitors
  319|      0|    }
  320|       |
  321|      0|    func performEvent(_ event: @escaping (EventMonitor) -> Void) {
  322|      0|        queue.async {
  323|      0|            for monitor in self.monitors {
  324|      0|                monitor.queue.async { event(monitor) }
  325|      0|            }
  326|      0|        }
  327|      0|    }
  328|       |
  329|      0|    public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {
  330|      0|        performEvent { $0.urlSession(session, didBecomeInvalidWithError: error) }
  331|      0|    }
  332|       |
  333|       |    public func urlSession(_ session: URLSession,
  334|       |                           task: URLSessionTask,
  335|      0|                           didReceive challenge: URLAuthenticationChallenge) {
  336|      0|        performEvent { $0.urlSession(session, task: task, didReceive: challenge) }
  337|      0|    }
  338|       |
  339|       |    public func urlSession(_ session: URLSession,
  340|       |                           task: URLSessionTask,
  341|       |                           didSendBodyData bytesSent: Int64,
  342|       |                           totalBytesSent: Int64,
  343|      0|                           totalBytesExpectedToSend: Int64) {
  344|      0|        performEvent {
  345|      0|            $0.urlSession(session,
  346|      0|                          task: task,
  347|      0|                          didSendBodyData: bytesSent,
  348|      0|                          totalBytesSent: totalBytesSent,
  349|      0|                          totalBytesExpectedToSend: totalBytesExpectedToSend)
  350|      0|        }
  351|      0|    }
  352|       |
  353|      0|    public func urlSession(_ session: URLSession, taskNeedsNewBodyStream task: URLSessionTask) {
  354|      0|        performEvent {
  355|      0|            $0.urlSession(session, taskNeedsNewBodyStream: task)
  356|      0|        }
  357|      0|    }
  358|       |
  359|       |    public func urlSession(_ session: URLSession,
  360|       |                           task: URLSessionTask,
  361|       |                           willPerformHTTPRedirection response: HTTPURLResponse,
  362|      0|                           newRequest request: URLRequest) {
  363|      0|        performEvent {
  364|      0|            $0.urlSession(session,
  365|      0|                          task: task,
  366|      0|                          willPerformHTTPRedirection: response,
  367|      0|                          newRequest: request)
  368|      0|        }
  369|      0|    }
  370|       |
  371|      0|    public func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {
  372|      0|        performEvent { $0.urlSession(session, task: task, didFinishCollecting: metrics) }
  373|      0|    }
  374|       |
  375|      0|    public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  376|      0|        performEvent { $0.urlSession(session, task: task, didCompleteWithError: error) }
  377|      0|    }
  378|       |
  379|       |    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  380|      0|    public func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {
  381|      0|        performEvent { $0.urlSession(session, taskIsWaitingForConnectivity: task) }
  382|      0|    }
  383|       |
  384|      0|    public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  385|      0|        performEvent { $0.urlSession(session, dataTask: dataTask, didReceive: data) }
  386|      0|    }
  387|       |
  388|       |    public func urlSession(_ session: URLSession,
  389|       |                           dataTask: URLSessionDataTask,
  390|      0|                           willCacheResponse proposedResponse: CachedURLResponse) {
  391|      0|        performEvent { $0.urlSession(session, dataTask: dataTask, willCacheResponse: proposedResponse) }
  392|      0|    }
  393|       |
  394|       |    public func urlSession(_ session: URLSession,
  395|       |                           downloadTask: URLSessionDownloadTask,
  396|       |                           didResumeAtOffset fileOffset: Int64,
  397|      0|                           expectedTotalBytes: Int64) {
  398|      0|        performEvent {
  399|      0|            $0.urlSession(session,
  400|      0|                          downloadTask: downloadTask,
  401|      0|                          didResumeAtOffset: fileOffset,
  402|      0|                          expectedTotalBytes: expectedTotalBytes)
  403|      0|        }
  404|      0|    }
  405|       |
  406|       |    public func urlSession(_ session: URLSession,
  407|       |                           downloadTask: URLSessionDownloadTask,
  408|       |                           didWriteData bytesWritten: Int64,
  409|       |                           totalBytesWritten: Int64,
  410|      0|                           totalBytesExpectedToWrite: Int64) {
  411|      0|        performEvent {
  412|      0|            $0.urlSession(session,
  413|      0|                          downloadTask: downloadTask,
  414|      0|                          didWriteData: bytesWritten,
  415|      0|                          totalBytesWritten: totalBytesWritten,
  416|      0|                          totalBytesExpectedToWrite: totalBytesExpectedToWrite)
  417|      0|        }
  418|      0|    }
  419|       |
  420|       |    public func urlSession(_ session: URLSession,
  421|       |                           downloadTask: URLSessionDownloadTask,
  422|      0|                           didFinishDownloadingTo location: URL) {
  423|      0|        performEvent { $0.urlSession(session, downloadTask: downloadTask, didFinishDownloadingTo: location) }
  424|      0|    }
  425|       |
  426|      0|    public func request(_ request: Request, didCreateInitialURLRequest urlRequest: URLRequest) {
  427|      0|        performEvent { $0.request(request, didCreateInitialURLRequest: urlRequest) }
  428|      0|    }
  429|       |
  430|      0|    public func request(_ request: Request, didFailToCreateURLRequestWithError error: AFError) {
  431|      0|        performEvent { $0.request(request, didFailToCreateURLRequestWithError: error) }
  432|      0|    }
  433|       |
  434|      0|    public func request(_ request: Request, didAdaptInitialRequest initialRequest: URLRequest, to adaptedRequest: URLRequest) {
  435|      0|        performEvent { $0.request(request, didAdaptInitialRequest: initialRequest, to: adaptedRequest) }
  436|      0|    }
  437|       |
  438|      0|    public func request(_ request: Request, didFailToAdaptURLRequest initialRequest: URLRequest, withError error: AFError) {
  439|      0|        performEvent { $0.request(request, didFailToAdaptURLRequest: initialRequest, withError: error) }
  440|      0|    }
  441|       |
  442|      0|    public func request(_ request: Request, didCreateURLRequest urlRequest: URLRequest) {
  443|      0|        performEvent { $0.request(request, didCreateURLRequest: urlRequest) }
  444|      0|    }
  445|       |
  446|      0|    public func request(_ request: Request, didCreateTask task: URLSessionTask) {
  447|      0|        performEvent { $0.request(request, didCreateTask: task) }
  448|      0|    }
  449|       |
  450|      0|    public func request(_ request: Request, didGatherMetrics metrics: URLSessionTaskMetrics) {
  451|      0|        performEvent { $0.request(request, didGatherMetrics: metrics) }
  452|      0|    }
  453|       |
  454|      0|    public func request(_ request: Request, didFailTask task: URLSessionTask, earlyWithError error: AFError) {
  455|      0|        performEvent { $0.request(request, didFailTask: task, earlyWithError: error) }
  456|      0|    }
  457|       |
  458|      0|    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {
  459|      0|        performEvent { $0.request(request, didCompleteTask: task, with: error) }
  460|      0|    }
  461|       |
  462|      0|    public func requestIsRetrying(_ request: Request) {
  463|      0|        performEvent { $0.requestIsRetrying(request) }
  464|      0|    }
  465|       |
  466|      0|    public func requestDidFinish(_ request: Request) {
  467|      0|        performEvent { $0.requestDidFinish(request) }
  468|      0|    }
  469|       |
  470|      0|    public func requestDidResume(_ request: Request) {
  471|      0|        performEvent { $0.requestDidResume(request) }
  472|      0|    }
  473|       |
  474|      0|    public func request(_ request: Request, didResumeTask task: URLSessionTask) {
  475|      0|        performEvent { $0.request(request, didResumeTask: task) }
  476|      0|    }
  477|       |
  478|      0|    public func requestDidSuspend(_ request: Request) {
  479|      0|        performEvent { $0.requestDidSuspend(request) }
  480|      0|    }
  481|       |
  482|      0|    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {
  483|      0|        performEvent { $0.request(request, didSuspendTask: task) }
  484|      0|    }
  485|       |
  486|      0|    public func requestDidCancel(_ request: Request) {
  487|      0|        performEvent { $0.requestDidCancel(request) }
  488|      0|    }
  489|       |
  490|      0|    public func request(_ request: Request, didCancelTask task: URLSessionTask) {
  491|      0|        performEvent { $0.request(request, didCancelTask: task) }
  492|      0|    }
  493|       |
  494|       |    public func request(_ request: DataRequest,
  495|       |                        didValidateRequest urlRequest: URLRequest?,
  496|       |                        response: HTTPURLResponse,
  497|       |                        data: Data?,
  498|      0|                        withResult result: Request.ValidationResult) {
  499|      0|        performEvent { $0.request(request,
  500|      0|                                  didValidateRequest: urlRequest,
  501|      0|                                  response: response,
  502|      0|                                  data: data,
  503|      0|                                  withResult: result)
  504|      0|        }
  505|      0|    }
  506|       |
  507|      0|    public func request(_ request: DataRequest, didParseResponse response: DataResponse<Data?, AFError>) {
  508|      0|        performEvent { $0.request(request, didParseResponse: response) }
  509|      0|    }
  510|       |
  511|      0|    public func request<Value>(_ request: DataRequest, didParseResponse response: DataResponse<Value, AFError>) {
  512|      0|        performEvent { $0.request(request, didParseResponse: response) }
  513|      0|    }
  514|       |
  515|       |    public func request(_ request: DataStreamRequest,
  516|       |                        didValidateRequest urlRequest: URLRequest?,
  517|       |                        response: HTTPURLResponse,
  518|      0|                        withResult result: Request.ValidationResult) {
  519|      0|        performEvent { $0.request(request,
  520|      0|                                  didValidateRequest: urlRequest,
  521|      0|                                  response: response,
  522|      0|                                  withResult: result)
  523|      0|        }
  524|      0|    }
  525|       |
  526|      0|    public func request<Value>(_ request: DataStreamRequest, didParseStream result: Result<Value, AFError>) {
  527|      0|        performEvent { $0.request(request, didParseStream: result) }
  528|      0|    }
  529|       |
  530|      0|    public func request(_ request: UploadRequest, didCreateUploadable uploadable: UploadRequest.Uploadable) {
  531|      0|        performEvent { $0.request(request, didCreateUploadable: uploadable) }
  532|      0|    }
  533|       |
  534|      0|    public func request(_ request: UploadRequest, didFailToCreateUploadableWithError error: AFError) {
  535|      0|        performEvent { $0.request(request, didFailToCreateUploadableWithError: error) }
  536|      0|    }
  537|       |
  538|      0|    public func request(_ request: UploadRequest, didProvideInputStream stream: InputStream) {
  539|      0|        performEvent { $0.request(request, didProvideInputStream: stream) }
  540|      0|    }
  541|       |
  542|      0|    public func request(_ request: DownloadRequest, didFinishDownloadingUsing task: URLSessionTask, with result: Result<URL, AFError>) {
  543|      0|        performEvent { $0.request(request, didFinishDownloadingUsing: task, with: result) }
  544|      0|    }
  545|       |
  546|      0|    public func request(_ request: DownloadRequest, didCreateDestinationURL url: URL) {
  547|      0|        performEvent { $0.request(request, didCreateDestinationURL: url) }
  548|      0|    }
  549|       |
  550|       |    public func request(_ request: DownloadRequest,
  551|       |                        didValidateRequest urlRequest: URLRequest?,
  552|       |                        response: HTTPURLResponse,
  553|       |                        fileURL: URL?,
  554|      0|                        withResult result: Request.ValidationResult) {
  555|      0|        performEvent { $0.request(request,
  556|      0|                                  didValidateRequest: urlRequest,
  557|      0|                                  response: response,
  558|      0|                                  fileURL: fileURL,
  559|      0|                                  withResult: result) }
  560|      0|    }
  561|       |
  562|      0|    public func request(_ request: DownloadRequest, didParseResponse response: DownloadResponse<URL?, AFError>) {
  563|      0|        performEvent { $0.request(request, didParseResponse: response) }
  564|      0|    }
  565|       |
  566|      0|    public func request<Value>(_ request: DownloadRequest, didParseResponse response: DownloadResponse<Value, AFError>) {
  567|      0|        performEvent { $0.request(request, didParseResponse: response) }
  568|      0|    }
  569|       |}
  570|       |
  571|       |/// `EventMonitor` that allows optional closures to be set to receive events.
  572|       |open class ClosureEventMonitor: EventMonitor {
  573|       |    /// Closure called on the `urlSession(_:didBecomeInvalidWithError:)` event.
  574|       |    open var sessionDidBecomeInvalidWithError: ((URLSession, Error?) -> Void)?
  575|       |
  576|       |    /// Closure called on the `urlSession(_:task:didReceive:completionHandler:)`.
  577|       |    open var taskDidReceiveChallenge: ((URLSession, URLSessionTask, URLAuthenticationChallenge) -> Void)?
  578|       |
  579|       |    /// Closure that receives `urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)` event.
  580|       |    open var taskDidSendBodyData: ((URLSession, URLSessionTask, Int64, Int64, Int64) -> Void)?
  581|       |
  582|       |    /// Closure called on the `urlSession(_:task:needNewBodyStream:)` event.
  583|       |    open var taskNeedNewBodyStream: ((URLSession, URLSessionTask) -> Void)?
  584|       |
  585|       |    /// Closure called on the `urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)` event.
  586|       |    open var taskWillPerformHTTPRedirection: ((URLSession, URLSessionTask, HTTPURLResponse, URLRequest) -> Void)?
  587|       |
  588|       |    /// Closure called on the `urlSession(_:task:didFinishCollecting:)` event.
  589|       |    open var taskDidFinishCollectingMetrics: ((URLSession, URLSessionTask, URLSessionTaskMetrics) -> Void)?
  590|       |
  591|       |    /// Closure called on the `urlSession(_:task:didCompleteWithError:)` event.
  592|       |    open var taskDidComplete: ((URLSession, URLSessionTask, Error?) -> Void)?
  593|       |
  594|       |    /// Closure called on the `urlSession(_:taskIsWaitingForConnectivity:)` event.
  595|       |    open var taskIsWaitingForConnectivity: ((URLSession, URLSessionTask) -> Void)?
  596|       |
  597|       |    /// Closure that receives the `urlSession(_:dataTask:didReceive:)` event.
  598|       |    open var dataTaskDidReceiveData: ((URLSession, URLSessionDataTask, Data) -> Void)?
  599|       |
  600|       |    /// Closure called on the `urlSession(_:dataTask:willCacheResponse:completionHandler:)` event.
  601|       |    open var dataTaskWillCacheResponse: ((URLSession, URLSessionDataTask, CachedURLResponse) -> Void)?
  602|       |
  603|       |    /// Closure called on the `urlSession(_:downloadTask:didFinishDownloadingTo:)` event.
  604|       |    open var downloadTaskDidFinishDownloadingToURL: ((URLSession, URLSessionDownloadTask, URL) -> Void)?
  605|       |
  606|       |    /// Closure called on the `urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)`
  607|       |    /// event.
  608|       |    open var downloadTaskDidWriteData: ((URLSession, URLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
  609|       |
  610|       |    /// Closure called on the `urlSession(_:downloadTask:didResumeAtOffset:expectedTotalBytes:)` event.
  611|       |    open var downloadTaskDidResumeAtOffset: ((URLSession, URLSessionDownloadTask, Int64, Int64) -> Void)?
  612|       |
  613|       |    // MARK: - Request Events
  614|       |
  615|       |    /// Closure called on the `request(_:didCreateInitialURLRequest:)` event.
  616|       |    open var requestDidCreateInitialURLRequest: ((Request, URLRequest) -> Void)?
  617|       |
  618|       |    /// Closure called on the `request(_:didFailToCreateURLRequestWithError:)` event.
  619|       |    open var requestDidFailToCreateURLRequestWithError: ((Request, AFError) -> Void)?
  620|       |
  621|       |    /// Closure called on the `request(_:didAdaptInitialRequest:to:)` event.
  622|       |    open var requestDidAdaptInitialRequestToAdaptedRequest: ((Request, URLRequest, URLRequest) -> Void)?
  623|       |
  624|       |    /// Closure called on the `request(_:didFailToAdaptURLRequest:withError:)` event.
  625|       |    open var requestDidFailToAdaptURLRequestWithError: ((Request, URLRequest, AFError) -> Void)?
  626|       |
  627|       |    /// Closure called on the `request(_:didCreateURLRequest:)` event.
  628|       |    open var requestDidCreateURLRequest: ((Request, URLRequest) -> Void)?
  629|       |
  630|       |    /// Closure called on the `request(_:didCreateTask:)` event.
  631|       |    open var requestDidCreateTask: ((Request, URLSessionTask) -> Void)?
  632|       |
  633|       |    /// Closure called on the `request(_:didGatherMetrics:)` event.
  634|       |    open var requestDidGatherMetrics: ((Request, URLSessionTaskMetrics) -> Void)?
  635|       |
  636|       |    /// Closure called on the `request(_:didFailTask:earlyWithError:)` event.
  637|       |    open var requestDidFailTaskEarlyWithError: ((Request, URLSessionTask, AFError) -> Void)?
  638|       |
  639|       |    /// Closure called on the `request(_:didCompleteTask:with:)` event.
  640|       |    open var requestDidCompleteTaskWithError: ((Request, URLSessionTask, AFError?) -> Void)?
  641|       |
  642|       |    /// Closure called on the `requestIsRetrying(_:)` event.
  643|       |    open var requestIsRetrying: ((Request) -> Void)?
  644|       |
  645|       |    /// Closure called on the `requestDidFinish(_:)` event.
  646|       |    open var requestDidFinish: ((Request) -> Void)?
  647|       |
  648|       |    /// Closure called on the `requestDidResume(_:)` event.
  649|       |    open var requestDidResume: ((Request) -> Void)?
  650|       |
  651|       |    /// Closure called on the `request(_:didResumeTask:)` event.
  652|       |    open var requestDidResumeTask: ((Request, URLSessionTask) -> Void)?
  653|       |
  654|       |    /// Closure called on the `requestDidSuspend(_:)` event.
  655|       |    open var requestDidSuspend: ((Request) -> Void)?
  656|       |
  657|       |    /// Closure called on the `request(_:didSuspendTask:)` event.
  658|       |    open var requestDidSuspendTask: ((Request, URLSessionTask) -> Void)?
  659|       |
  660|       |    /// Closure called on the `requestDidCancel(_:)` event.
  661|       |    open var requestDidCancel: ((Request) -> Void)?
  662|       |
  663|       |    /// Closure called on the `request(_:didCancelTask:)` event.
  664|       |    open var requestDidCancelTask: ((Request, URLSessionTask) -> Void)?
  665|       |
  666|       |    /// Closure called on the `request(_:didValidateRequest:response:data:withResult:)` event.
  667|       |    open var requestDidValidateRequestResponseDataWithResult: ((DataRequest, URLRequest?, HTTPURLResponse, Data?, Request.ValidationResult) -> Void)?
  668|       |
  669|       |    /// Closure called on the `request(_:didParseResponse:)` event.
  670|       |    open var requestDidParseResponse: ((DataRequest, DataResponse<Data?, AFError>) -> Void)?
  671|       |
  672|       |    /// Closure called on the `request(_:didValidateRequest:response:withResult:)` event.
  673|       |    open var requestDidValidateRequestResponseWithResult: ((DataStreamRequest, URLRequest?, HTTPURLResponse, Request.ValidationResult) -> Void)?
  674|       |
  675|       |    /// Closure called on the `request(_:didCreateUploadable:)` event.
  676|       |    open var requestDidCreateUploadable: ((UploadRequest, UploadRequest.Uploadable) -> Void)?
  677|       |
  678|       |    /// Closure called on the `request(_:didFailToCreateUploadableWithError:)` event.
  679|       |    open var requestDidFailToCreateUploadableWithError: ((UploadRequest, AFError) -> Void)?
  680|       |
  681|       |    /// Closure called on the `request(_:didProvideInputStream:)` event.
  682|       |    open var requestDidProvideInputStream: ((UploadRequest, InputStream) -> Void)?
  683|       |
  684|       |    /// Closure called on the `request(_:didFinishDownloadingUsing:with:)` event.
  685|       |    open var requestDidFinishDownloadingUsingTaskWithResult: ((DownloadRequest, URLSessionTask, Result<URL, AFError>) -> Void)?
  686|       |
  687|       |    /// Closure called on the `request(_:didCreateDestinationURL:)` event.
  688|       |    open var requestDidCreateDestinationURL: ((DownloadRequest, URL) -> Void)?
  689|       |
  690|       |    /// Closure called on the `request(_:didValidateRequest:response:temporaryURL:destinationURL:withResult:)` event.
  691|       |    open var requestDidValidateRequestResponseFileURLWithResult: ((DownloadRequest, URLRequest?, HTTPURLResponse, URL?, Request.ValidationResult) -> Void)?
  692|       |
  693|       |    /// Closure called on the `request(_:didParseResponse:)` event.
  694|       |    open var requestDidParseDownloadResponse: ((DownloadRequest, DownloadResponse<URL?, AFError>) -> Void)?
  695|       |
  696|       |    public let queue: DispatchQueue
  697|       |
  698|       |    /// Creates an instance using the provided queue.
  699|       |    ///
  700|       |    /// - Parameter queue: `DispatchQueue` on which events will fired. `.main` by default.
  701|      0|    public init(queue: DispatchQueue = .main) {
  702|      0|        self.queue = queue
  703|      0|    }
  704|       |
  705|      0|    open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {
  706|      0|        sessionDidBecomeInvalidWithError?(session, error)
  707|      0|    }
  708|       |
  709|      0|    open func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge) {
  710|      0|        taskDidReceiveChallenge?(session, task, challenge)
  711|      0|    }
  712|       |
  713|       |    open func urlSession(_ session: URLSession,
  714|       |                         task: URLSessionTask,
  715|       |                         didSendBodyData bytesSent: Int64,
  716|       |                         totalBytesSent: Int64,
  717|      0|                         totalBytesExpectedToSend: Int64) {
  718|      0|        taskDidSendBodyData?(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
  719|      0|    }
  720|       |
  721|      0|    open func urlSession(_ session: URLSession, taskNeedsNewBodyStream task: URLSessionTask) {
  722|      0|        taskNeedNewBodyStream?(session, task)
  723|      0|    }
  724|       |
  725|       |    open func urlSession(_ session: URLSession,
  726|       |                         task: URLSessionTask,
  727|       |                         willPerformHTTPRedirection response: HTTPURLResponse,
  728|      0|                         newRequest request: URLRequest) {
  729|      0|        taskWillPerformHTTPRedirection?(session, task, response, request)
  730|      0|    }
  731|       |
  732|      0|    open func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {
  733|      0|        taskDidFinishCollectingMetrics?(session, task, metrics)
  734|      0|    }
  735|       |
  736|      0|    open func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  737|      0|        taskDidComplete?(session, task, error)
  738|      0|    }
  739|       |
  740|      0|    open func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {
  741|      0|        taskIsWaitingForConnectivity?(session, task)
  742|      0|    }
  743|       |
  744|      0|    open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  745|      0|        dataTaskDidReceiveData?(session, dataTask, data)
  746|      0|    }
  747|       |
  748|      0|    open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse) {
  749|      0|        dataTaskWillCacheResponse?(session, dataTask, proposedResponse)
  750|      0|    }
  751|       |
  752|       |    open func urlSession(_ session: URLSession,
  753|       |                         downloadTask: URLSessionDownloadTask,
  754|       |                         didResumeAtOffset fileOffset: Int64,
  755|      0|                         expectedTotalBytes: Int64) {
  756|      0|        downloadTaskDidResumeAtOffset?(session, downloadTask, fileOffset, expectedTotalBytes)
  757|      0|    }
  758|       |
  759|       |    open func urlSession(_ session: URLSession,
  760|       |                         downloadTask: URLSessionDownloadTask,
  761|       |                         didWriteData bytesWritten: Int64,
  762|       |                         totalBytesWritten: Int64,
  763|      0|                         totalBytesExpectedToWrite: Int64) {
  764|      0|        downloadTaskDidWriteData?(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
  765|      0|    }
  766|       |
  767|      0|    open func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
  768|      0|        downloadTaskDidFinishDownloadingToURL?(session, downloadTask, location)
  769|      0|    }
  770|       |
  771|       |    // MARK: Request Events
  772|       |
  773|      0|    open func request(_ request: Request, didCreateInitialURLRequest urlRequest: URLRequest) {
  774|      0|        requestDidCreateInitialURLRequest?(request, urlRequest)
  775|      0|    }
  776|       |
  777|      0|    open func request(_ request: Request, didFailToCreateURLRequestWithError error: AFError) {
  778|      0|        requestDidFailToCreateURLRequestWithError?(request, error)
  779|      0|    }
  780|       |
  781|      0|    open func request(_ request: Request, didAdaptInitialRequest initialRequest: URLRequest, to adaptedRequest: URLRequest) {
  782|      0|        requestDidAdaptInitialRequestToAdaptedRequest?(request, initialRequest, adaptedRequest)
  783|      0|    }
  784|       |
  785|      0|    open func request(_ request: Request, didFailToAdaptURLRequest initialRequest: URLRequest, withError error: AFError) {
  786|      0|        requestDidFailToAdaptURLRequestWithError?(request, initialRequest, error)
  787|      0|    }
  788|       |
  789|      0|    open func request(_ request: Request, didCreateURLRequest urlRequest: URLRequest) {
  790|      0|        requestDidCreateURLRequest?(request, urlRequest)
  791|      0|    }
  792|       |
  793|      0|    open func request(_ request: Request, didCreateTask task: URLSessionTask) {
  794|      0|        requestDidCreateTask?(request, task)
  795|      0|    }
  796|       |
  797|      0|    open func request(_ request: Request, didGatherMetrics metrics: URLSessionTaskMetrics) {
  798|      0|        requestDidGatherMetrics?(request, metrics)
  799|      0|    }
  800|       |
  801|      0|    open func request(_ request: Request, didFailTask task: URLSessionTask, earlyWithError error: AFError) {
  802|      0|        requestDidFailTaskEarlyWithError?(request, task, error)
  803|      0|    }
  804|       |
  805|      0|    open func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {
  806|      0|        requestDidCompleteTaskWithError?(request, task, error)
  807|      0|    }
  808|       |
  809|      0|    open func requestIsRetrying(_ request: Request) {
  810|      0|        requestIsRetrying?(request)
  811|      0|    }
  812|       |
  813|      0|    open func requestDidFinish(_ request: Request) {
  814|      0|        requestDidFinish?(request)
  815|      0|    }
  816|       |
  817|      0|    open func requestDidResume(_ request: Request) {
  818|      0|        requestDidResume?(request)
  819|      0|    }
  820|       |
  821|      0|    public func request(_ request: Request, didResumeTask task: URLSessionTask) {
  822|      0|        requestDidResumeTask?(request, task)
  823|      0|    }
  824|       |
  825|      0|    open func requestDidSuspend(_ request: Request) {
  826|      0|        requestDidSuspend?(request)
  827|      0|    }
  828|       |
  829|      0|    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {
  830|      0|        requestDidSuspendTask?(request, task)
  831|      0|    }
  832|       |
  833|      0|    open func requestDidCancel(_ request: Request) {
  834|      0|        requestDidCancel?(request)
  835|      0|    }
  836|       |
  837|      0|    public func request(_ request: Request, didCancelTask task: URLSessionTask) {
  838|      0|        requestDidCancelTask?(request, task)
  839|      0|    }
  840|       |
  841|       |    open func request(_ request: DataRequest,
  842|       |                      didValidateRequest urlRequest: URLRequest?,
  843|       |                      response: HTTPURLResponse,
  844|       |                      data: Data?,
  845|      0|                      withResult result: Request.ValidationResult) {
  846|      0|        requestDidValidateRequestResponseDataWithResult?(request, urlRequest, response, data, result)
  847|      0|    }
  848|       |
  849|      0|    open func request(_ request: DataRequest, didParseResponse response: DataResponse<Data?, AFError>) {
  850|      0|        requestDidParseResponse?(request, response)
  851|      0|    }
  852|       |
  853|      0|    public func request(_ request: DataStreamRequest, didValidateRequest urlRequest: URLRequest?, response: HTTPURLResponse, withResult result: Request.ValidationResult) {
  854|      0|        requestDidValidateRequestResponseWithResult?(request, urlRequest, response, result)
  855|      0|    }
  856|       |
  857|      0|    open func request(_ request: UploadRequest, didCreateUploadable uploadable: UploadRequest.Uploadable) {
  858|      0|        requestDidCreateUploadable?(request, uploadable)
  859|      0|    }
  860|       |
  861|      0|    open func request(_ request: UploadRequest, didFailToCreateUploadableWithError error: AFError) {
  862|      0|        requestDidFailToCreateUploadableWithError?(request, error)
  863|      0|    }
  864|       |
  865|      0|    open func request(_ request: UploadRequest, didProvideInputStream stream: InputStream) {
  866|      0|        requestDidProvideInputStream?(request, stream)
  867|      0|    }
  868|       |
  869|      0|    open func request(_ request: DownloadRequest, didFinishDownloadingUsing task: URLSessionTask, with result: Result<URL, AFError>) {
  870|      0|        requestDidFinishDownloadingUsingTaskWithResult?(request, task, result)
  871|      0|    }
  872|       |
  873|      0|    open func request(_ request: DownloadRequest, didCreateDestinationURL url: URL) {
  874|      0|        requestDidCreateDestinationURL?(request, url)
  875|      0|    }
  876|       |
  877|       |    open func request(_ request: DownloadRequest,
  878|       |                      didValidateRequest urlRequest: URLRequest?,
  879|       |                      response: HTTPURLResponse,
  880|       |                      fileURL: URL?,
  881|      0|                      withResult result: Request.ValidationResult) {
  882|      0|        requestDidValidateRequestResponseFileURLWithResult?(request,
  883|      0|                                                            urlRequest,
  884|      0|                                                            response,
  885|      0|                                                            fileURL,
  886|      0|                                                            result)
  887|      0|    }
  888|       |
  889|      0|    open func request(_ request: DownloadRequest, didParseResponse response: DownloadResponse<URL?, AFError>) {
  890|      0|        requestDidParseDownloadResponse?(request, response)
  891|      0|    }
  892|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/HTTPHeaders.swift:
    1|       |//
    2|       |//  HTTPHeaders.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// An order-preserving and case-insensitive representation of HTTP headers.
   28|       |public struct HTTPHeaders {
   29|      0|    private var headers: [HTTPHeader] = []
   30|       |
   31|       |    /// Creates an empty instance.
   32|      0|    public init() {}
   33|       |
   34|       |    /// Creates an instance from an array of `HTTPHeader`s. Duplicate case-insensitive names are collapsed into the last
   35|       |    /// name and value encountered.
   36|      0|    public init(_ headers: [HTTPHeader]) {
   37|      0|        self.init()
   38|      0|
   39|      0|        headers.forEach { update($0) }
   40|      0|    }
   41|       |
   42|       |    /// Creates an instance from a `[String: String]`. Duplicate case-insensitive names are collapsed into the last name
   43|       |    /// and value encountered.
   44|      0|    public init(_ dictionary: [String: String]) {
   45|      0|        self.init()
   46|      0|
   47|      0|        dictionary.forEach { update(HTTPHeader(name: $0.key, value: $0.value)) }
   48|      0|    }
   49|       |
   50|       |    /// Case-insensitively updates or appends an `HTTPHeader` into the instance using the provided `name` and `value`.
   51|       |    ///
   52|       |    /// - Parameters:
   53|       |    ///   - name:  The `HTTPHeader` name.
   54|       |    ///   - value: The `HTTPHeader value.
   55|      0|    public mutating func add(name: String, value: String) {
   56|      0|        update(HTTPHeader(name: name, value: value))
   57|      0|    }
   58|       |
   59|       |    /// Case-insensitively updates or appends the provided `HTTPHeader` into the instance.
   60|       |    ///
   61|       |    /// - Parameter header: The `HTTPHeader` to update or append.
   62|      0|    public mutating func add(_ header: HTTPHeader) {
   63|      0|        update(header)
   64|      0|    }
   65|       |
   66|       |    /// Case-insensitively updates or appends an `HTTPHeader` into the instance using the provided `name` and `value`.
   67|       |    ///
   68|       |    /// - Parameters:
   69|       |    ///   - name:  The `HTTPHeader` name.
   70|       |    ///   - value: The `HTTPHeader value.
   71|      0|    public mutating func update(name: String, value: String) {
   72|      0|        update(HTTPHeader(name: name, value: value))
   73|      0|    }
   74|       |
   75|       |    /// Case-insensitively updates or appends the provided `HTTPHeader` into the instance.
   76|       |    ///
   77|       |    /// - Parameter header: The `HTTPHeader` to update or append.
   78|      0|    public mutating func update(_ header: HTTPHeader) {
   79|      0|        guard let index = headers.index(of: header.name) else {
   80|      0|            headers.append(header)
   81|      0|            return
   82|      0|        }
   83|      0|
   84|      0|        headers.replaceSubrange(index...index, with: [header])
   85|      0|    }
   86|       |
   87|       |    /// Case-insensitively removes an `HTTPHeader`, if it exists, from the instance.
   88|       |    ///
   89|       |    /// - Parameter name: The name of the `HTTPHeader` to remove.
   90|      0|    public mutating func remove(name: String) {
   91|      0|        guard let index = headers.index(of: name) else { return }
   92|      0|
   93|      0|        headers.remove(at: index)
   94|      0|    }
   95|       |
   96|       |    /// Sort the current instance by header name, case insensitively.
   97|      0|    public mutating func sort() {
   98|      0|        headers.sort { $0.name.lowercased() < $1.name.lowercased() }
   99|      0|    }
  100|       |
  101|       |    /// Returns an instance sorted by header name.
  102|       |    ///
  103|       |    /// - Returns: A copy of the current instance sorted by name.
  104|      0|    public func sorted() -> HTTPHeaders {
  105|      0|        var headers = self
  106|      0|        headers.sort()
  107|      0|
  108|      0|        return headers
  109|      0|    }
  110|       |
  111|       |    /// Case-insensitively find a header's value by name.
  112|       |    ///
  113|       |    /// - Parameter name: The name of the header to search for, case-insensitively.
  114|       |    ///
  115|       |    /// - Returns:        The value of header, if it exists.
  116|      0|    public func value(for name: String) -> String? {
  117|      0|        guard let index = headers.index(of: name) else { return nil }
  118|      0|
  119|      0|        return headers[index].value
  120|      0|    }
  121|       |
  122|       |    /// Case-insensitively access the header with the given name.
  123|       |    ///
  124|       |    /// - Parameter name: The name of the header.
  125|       |    public subscript(_ name: String) -> String? {
  126|      0|        get { value(for: name) }
  127|      0|        set {
  128|      0|            if let value = newValue {
  129|      0|                update(name: name, value: value)
  130|      0|            } else {
  131|      0|                remove(name: name)
  132|      0|            }
  133|      0|        }
  134|       |    }
  135|       |
  136|       |    /// The dictionary representation of all headers.
  137|       |    ///
  138|       |    /// This representation does not preserve the current order of the instance.
  139|      0|    public var dictionary: [String: String] {
  140|      0|        let namesAndValues = headers.map { ($0.name, $0.value) }
  141|      0|
  142|      0|        return Dictionary(namesAndValues, uniquingKeysWith: { _, last in last })
  143|      0|    }
  144|       |}
  145|       |
  146|       |extension HTTPHeaders: ExpressibleByDictionaryLiteral {
  147|      0|    public init(dictionaryLiteral elements: (String, String)...) {
  148|      0|        self.init()
  149|      0|
  150|      0|        elements.forEach { update(name: $0.0, value: $0.1) }
  151|      0|    }
  152|       |}
  153|       |
  154|       |extension HTTPHeaders: ExpressibleByArrayLiteral {
  155|      0|    public init(arrayLiteral elements: HTTPHeader...) {
  156|      0|        self.init(elements)
  157|      0|    }
  158|       |}
  159|       |
  160|       |extension HTTPHeaders: Sequence {
  161|      0|    public func makeIterator() -> IndexingIterator<[HTTPHeader]> {
  162|      0|        headers.makeIterator()
  163|      0|    }
  164|       |}
  165|       |
  166|       |extension HTTPHeaders: Collection {
  167|      0|    public var startIndex: Int {
  168|      0|        headers.startIndex
  169|      0|    }
  170|       |
  171|      0|    public var endIndex: Int {
  172|      0|        headers.endIndex
  173|      0|    }
  174|       |
  175|      0|    public subscript(position: Int) -> HTTPHeader {
  176|      0|        headers[position]
  177|      0|    }
  178|       |
  179|      0|    public func index(after i: Int) -> Int {
  180|      0|        headers.index(after: i)
  181|      0|    }
  182|       |}
  183|       |
  184|       |extension HTTPHeaders: CustomStringConvertible {
  185|      0|    public var description: String {
  186|      0|        headers.map { $0.description }
  187|      0|            .joined(separator: "\n")
  188|      0|    }
  189|       |}
  190|       |
  191|       |// MARK: - HTTPHeader
  192|       |
  193|       |/// A representation of a single HTTP header's name / value pair.
  194|       |public struct HTTPHeader: Hashable {
  195|       |    /// Name of the header.
  196|       |    public let name: String
  197|       |
  198|       |    /// Value of the header.
  199|       |    public let value: String
  200|       |
  201|       |    /// Creates an instance from the given `name` and `value`.
  202|       |    ///
  203|       |    /// - Parameters:
  204|       |    ///   - name:  The name of the header.
  205|       |    ///   - value: The value of the header.
  206|      0|    public init(name: String, value: String) {
  207|      0|        self.name = name
  208|      0|        self.value = value
  209|      0|    }
  210|       |}
  211|       |
  212|       |extension HTTPHeader: CustomStringConvertible {
  213|      0|    public var description: String {
  214|      0|        "\(name): \(value)"
  215|      0|    }
  216|       |}
  217|       |
  218|       |extension HTTPHeader {
  219|       |    /// Returns an `Accept` header.
  220|       |    ///
  221|       |    /// - Parameter value: The `Accept` value.
  222|       |    /// - Returns:         The header.
  223|      0|    public static func accept(_ value: String) -> HTTPHeader {
  224|      0|        HTTPHeader(name: "Accept", value: value)
  225|      0|    }
  226|       |
  227|       |    /// Returns an `Accept-Charset` header.
  228|       |    ///
  229|       |    /// - Parameter value: The `Accept-Charset` value.
  230|       |    /// - Returns:         The header.
  231|      0|    public static func acceptCharset(_ value: String) -> HTTPHeader {
  232|      0|        HTTPHeader(name: "Accept-Charset", value: value)
  233|      0|    }
  234|       |
  235|       |    /// Returns an `Accept-Language` header.
  236|       |    ///
  237|       |    /// Alamofire offers a default Accept-Language header that accumulates and encodes the system's preferred languages.
  238|       |    /// Use `HTTPHeader.defaultAcceptLanguage`.
  239|       |    ///
  240|       |    /// - Parameter value: The `Accept-Language` value.
  241|       |    ///
  242|       |    /// - Returns:         The header.
  243|      0|    public static func acceptLanguage(_ value: String) -> HTTPHeader {
  244|      0|        HTTPHeader(name: "Accept-Language", value: value)
  245|      0|    }
  246|       |
  247|       |    /// Returns an `Accept-Encoding` header.
  248|       |    ///
  249|       |    /// Alamofire offers a default accept encoding value that provides the most common values. Use
  250|       |    /// `HTTPHeader.defaultAcceptEncoding`.
  251|       |    ///
  252|       |    /// - Parameter value: The `Accept-Encoding` value.
  253|       |    ///
  254|       |    /// - Returns:         The header
  255|      0|    public static func acceptEncoding(_ value: String) -> HTTPHeader {
  256|      0|        HTTPHeader(name: "Accept-Encoding", value: value)
  257|      0|    }
  258|       |
  259|       |    /// Returns a `Basic` `Authorization` header using the `username` and `password` provided.
  260|       |    ///
  261|       |    /// - Parameters:
  262|       |    ///   - username: The username of the header.
  263|       |    ///   - password: The password of the header.
  264|       |    ///
  265|       |    /// - Returns:    The header.
  266|      0|    public static func authorization(username: String, password: String) -> HTTPHeader {
  267|      0|        let credential = Data("\(username):\(password)".utf8).base64EncodedString()
  268|      0|
  269|      0|        return authorization("Basic \(credential)")
  270|      0|    }
  271|       |
  272|       |    /// Returns a `Bearer` `Authorization` header using the `bearerToken` provided
  273|       |    ///
  274|       |    /// - Parameter bearerToken: The bearer token.
  275|       |    ///
  276|       |    /// - Returns:               The header.
  277|      0|    public static func authorization(bearerToken: String) -> HTTPHeader {
  278|      0|        authorization("Bearer \(bearerToken)")
  279|      0|    }
  280|       |
  281|       |    /// Returns an `Authorization` header.
  282|       |    ///
  283|       |    /// Alamofire provides built-in methods to produce `Authorization` headers. For a Basic `Authorization` header use
  284|       |    /// `HTTPHeader.authorization(username:password:)`. For a Bearer `Authorization` header, use
  285|       |    /// `HTTPHeader.authorization(bearerToken:)`.
  286|       |    ///
  287|       |    /// - Parameter value: The `Authorization` value.
  288|       |    ///
  289|       |    /// - Returns:         The header.
  290|      0|    public static func authorization(_ value: String) -> HTTPHeader {
  291|      0|        HTTPHeader(name: "Authorization", value: value)
  292|      0|    }
  293|       |
  294|       |    /// Returns a `Content-Disposition` header.
  295|       |    ///
  296|       |    /// - Parameter value: The `Content-Disposition` value.
  297|       |    ///
  298|       |    /// - Returns:         The header.
  299|      0|    public static func contentDisposition(_ value: String) -> HTTPHeader {
  300|      0|        HTTPHeader(name: "Content-Disposition", value: value)
  301|      0|    }
  302|       |
  303|       |    /// Returns a `Content-Type` header.
  304|       |    ///
  305|       |    /// All Alamofire `ParameterEncoding`s and `ParameterEncoder`s set the `Content-Type` of the request, so it may not be necessary to manually
  306|       |    /// set this value.
  307|       |    ///
  308|       |    /// - Parameter value: The `Content-Type` value.
  309|       |    ///
  310|       |    /// - Returns:         The header.
  311|      0|    public static func contentType(_ value: String) -> HTTPHeader {
  312|      0|        HTTPHeader(name: "Content-Type", value: value)
  313|      0|    }
  314|       |
  315|       |    /// Returns a `User-Agent` header.
  316|       |    ///
  317|       |    /// - Parameter value: The `User-Agent` value.
  318|       |    ///
  319|       |    /// - Returns:         The header.
  320|      0|    public static func userAgent(_ value: String) -> HTTPHeader {
  321|      0|        HTTPHeader(name: "User-Agent", value: value)
  322|      0|    }
  323|       |}
  324|       |
  325|       |extension Array where Element == HTTPHeader {
  326|       |    /// Case-insensitively finds the index of an `HTTPHeader` with the provided name, if it exists.
  327|      0|    func index(of name: String) -> Int? {
  328|      0|        let lowercasedName = name.lowercased()
  329|      0|        return firstIndex { $0.name.lowercased() == lowercasedName }
  330|      0|    }
  331|       |}
  332|       |
  333|       |// MARK: - Defaults
  334|       |
  335|       |extension HTTPHeaders {
  336|       |    /// The default set of `HTTPHeaders` used by Alamofire. Includes `Accept-Encoding`, `Accept-Language`, and
  337|       |    /// `User-Agent`.
  338|       |    public static let `default`: HTTPHeaders = [.defaultAcceptEncoding,
  339|       |                                                .defaultAcceptLanguage,
  340|       |                                                .defaultUserAgent]
  341|       |}
  342|       |
  343|       |extension HTTPHeader {
  344|       |    /// Returns Alamofire's default `Accept-Encoding` header, appropriate for the encodings supported by particular OS
  345|       |    /// versions.
  346|       |    ///
  347|       |    /// See the [Accept-Encoding HTTP header documentation](https://tools.ietf.org/html/rfc7230#section-4.2.3) .
  348|      0|    public static let defaultAcceptEncoding: HTTPHeader = {
  349|      0|        let encodings: [String]
  350|      0|        if #available(iOS 11.0, macOS 10.13, tvOS 11.0, watchOS 4.0, *) {
  351|      0|            encodings = ["br", "gzip", "deflate"]
  352|      0|        } else {
  353|      0|            encodings = ["gzip", "deflate"]
  354|      0|        }
  355|      0|
  356|      0|        return .acceptEncoding(encodings.qualityEncoded())
  357|      0|    }()
  358|       |
  359|       |    /// Returns Alamofire's default `Accept-Language` header, generated by querying `Locale` for the user's
  360|       |    /// `preferredLanguages`.
  361|       |    ///
  362|       |    /// See the [Accept-Language HTTP header documentation](https://tools.ietf.org/html/rfc7231#section-5.3.5).
  363|      0|    public static let defaultAcceptLanguage: HTTPHeader = {
  364|      0|        .acceptLanguage(Locale.preferredLanguages.prefix(6).qualityEncoded())
  365|      0|    }()
  366|       |
  367|       |    /// Returns Alamofire's default `User-Agent` header.
  368|       |    ///
  369|       |    /// See the [User-Agent header documentation](https://tools.ietf.org/html/rfc7231#section-5.5.3).
  370|       |    ///
  371|       |    /// Example: `iOS Example/1.0 (org.alamofire.iOS-Example; build:1; iOS 13.0.0) Alamofire/5.0.0`
  372|      0|    public static let defaultUserAgent: HTTPHeader = {
  373|      0|        let info = Bundle.main.infoDictionary
  374|      0|        let executable = (info?[kCFBundleExecutableKey as String] as? String) ??
  375|      0|            (ProcessInfo.processInfo.arguments.first?.split(separator: "/").last.map(String.init)) ??
  376|      0|            "Unknown"
  377|      0|        let bundle = info?[kCFBundleIdentifierKey as String] as? String ?? "Unknown"
  378|      0|        let appVersion = info?["CFBundleShortVersionString"] as? String ?? "Unknown"
  379|      0|        let appBuild = info?[kCFBundleVersionKey as String] as? String ?? "Unknown"
  380|      0|
  381|      0|        let osNameVersion: String = {
  382|      0|            let version = ProcessInfo.processInfo.operatingSystemVersion
  383|      0|            let versionString = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"
  384|      0|            let osName: String = {
  385|      0|                #if os(iOS)
  386|      0|                #if targetEnvironment(macCatalyst)
  387|      0|                return "macOS(Catalyst)"
  388|      0|                #else
  389|      0|                return "iOS"
  390|      0|                #endif
  391|      0|                #elseif os(watchOS)
  392|      0|                return "watchOS"
  393|      0|                #elseif os(tvOS)
  394|      0|                return "tvOS"
  395|      0|                #elseif os(macOS)
  396|      0|                return "macOS"
  397|      0|                #elseif os(Linux)
  398|      0|                return "Linux"
  399|      0|                #elseif os(Windows)
  400|      0|                return "Windows"
  401|      0|                #else
  402|      0|                return "Unknown"
  403|      0|                #endif
  404|      0|            }()
  405|      0|
  406|      0|            return "\(osName) \(versionString)"
  407|      0|        }()
  408|      0|
  409|      0|        let alamofireVersion = "Alamofire/\(version)"
  410|      0|
  411|      0|        let userAgent = "\(executable)/\(appVersion) (\(bundle); build:\(appBuild); \(osNameVersion)) \(alamofireVersion)"
  412|      0|
  413|      0|        return .userAgent(userAgent)
  414|      0|    }()
  415|       |}
  416|       |
  417|       |extension Collection where Element == String {
  418|      0|    func qualityEncoded() -> String {
  419|      0|        enumerated().map { index, encoding in
  420|      0|            let quality = 1.0 - (Double(index) * 0.1)
  421|      0|            return "\(encoding);q=\(quality)"
  422|      0|        }.joined(separator: ", ")
  423|      0|    }
  424|       |}
  425|       |
  426|       |// MARK: - System Type Extensions
  427|       |
  428|       |extension URLRequest {
  429|       |    /// Returns `allHTTPHeaderFields` as `HTTPHeaders`.
  430|       |    public var headers: HTTPHeaders {
  431|      0|        get { allHTTPHeaderFields.map(HTTPHeaders.init) ?? HTTPHeaders() }
  432|      0|        set { allHTTPHeaderFields = newValue.dictionary }
  433|       |    }
  434|       |}
  435|       |
  436|       |extension HTTPURLResponse {
  437|       |    /// Returns `allHeaderFields` as `HTTPHeaders`.
  438|      0|    public var headers: HTTPHeaders {
  439|      0|        (allHeaderFields as? [String: String]).map(HTTPHeaders.init) ?? HTTPHeaders()
  440|      0|    }
  441|       |}
  442|       |
  443|       |extension URLSessionConfiguration {
  444|       |    /// Returns `httpAdditionalHeaders` as `HTTPHeaders`.
  445|       |    public var headers: HTTPHeaders {
  446|      0|        get { (httpAdditionalHeaders as? [String: String]).map(HTTPHeaders.init) ?? HTTPHeaders() }
  447|      0|        set { httpAdditionalHeaders = newValue.dictionary }
  448|       |    }
  449|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/HTTPMethod.swift:
    1|       |//
    2|       |//  HTTPMethod.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |/// Type representing HTTP methods. Raw `String` value is stored and compared case-sensitively, so
   26|       |/// `HTTPMethod.get != HTTPMethod(rawValue: "get")`.
   27|       |///
   28|       |/// See https://tools.ietf.org/html/rfc7231#section-4.3
   29|       |public struct HTTPMethod: RawRepresentable, Equatable, Hashable {
   30|       |    /// `CONNECT` method.
   31|       |    public static let connect = HTTPMethod(rawValue: "CONNECT")
   32|       |    /// `DELETE` method.
   33|       |    public static let delete = HTTPMethod(rawValue: "DELETE")
   34|       |    /// `GET` method.
   35|       |    public static let get = HTTPMethod(rawValue: "GET")
   36|       |    /// `HEAD` method.
   37|       |    public static let head = HTTPMethod(rawValue: "HEAD")
   38|       |    /// `OPTIONS` method.
   39|       |    public static let options = HTTPMethod(rawValue: "OPTIONS")
   40|       |    /// `PATCH` method.
   41|       |    public static let patch = HTTPMethod(rawValue: "PATCH")
   42|       |    /// `POST` method.
   43|       |    public static let post = HTTPMethod(rawValue: "POST")
   44|       |    /// `PUT` method.
   45|       |    public static let put = HTTPMethod(rawValue: "PUT")
   46|       |    /// `TRACE` method.
   47|       |    public static let trace = HTTPMethod(rawValue: "TRACE")
   48|       |
   49|       |    public let rawValue: String
   50|       |
   51|      0|    public init(rawValue: String) {
   52|      0|        self.rawValue = rawValue
   53|      0|    }
   54|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/MultipartFormData.swift:
    1|       |//
    2|       |//  MultipartFormData.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |#if os(iOS) || os(watchOS) || os(tvOS)
   28|       |import MobileCoreServices
   29|       |#elseif os(macOS)
   30|       |import CoreServices
   31|       |#endif
   32|       |
   33|       |/// Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode
   34|       |/// multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead
   35|       |/// to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the
   36|       |/// data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for
   37|       |/// larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
   38|       |///
   39|       |/// For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
   40|       |/// and the w3 form documentation.
   41|       |///
   42|       |/// - https://www.ietf.org/rfc/rfc2388.txt
   43|       |/// - https://www.ietf.org/rfc/rfc2045.txt
   44|       |/// - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
   45|       |open class MultipartFormData {
   46|       |    // MARK: - Helper Types
   47|       |
   48|       |    enum EncodingCharacters {
   49|       |        static let crlf = "\r\n"
   50|       |    }
   51|       |
   52|       |    enum BoundaryGenerator {
   53|       |        enum BoundaryType {
   54|       |            case initial, encapsulated, final
   55|       |        }
   56|       |
   57|      0|        static func randomBoundary() -> String {
   58|      0|            let first = UInt32.random(in: UInt32.min...UInt32.max)
   59|      0|            let second = UInt32.random(in: UInt32.min...UInt32.max)
   60|      0|
   61|      0|            return String(format: "alamofire.boundary.%08x%08x", first, second)
   62|      0|        }
   63|       |
   64|      0|        static func boundaryData(forBoundaryType boundaryType: BoundaryType, boundary: String) -> Data {
   65|      0|            let boundaryText: String
   66|      0|
   67|      0|            switch boundaryType {
   68|      0|            case .initial:
   69|      0|                boundaryText = "--\(boundary)\(EncodingCharacters.crlf)"
   70|      0|            case .encapsulated:
   71|      0|                boundaryText = "\(EncodingCharacters.crlf)--\(boundary)\(EncodingCharacters.crlf)"
   72|      0|            case .final:
   73|      0|                boundaryText = "\(EncodingCharacters.crlf)--\(boundary)--\(EncodingCharacters.crlf)"
   74|      0|            }
   75|      0|
   76|      0|            return Data(boundaryText.utf8)
   77|      0|        }
   78|       |    }
   79|       |
   80|       |    class BodyPart {
   81|       |        let headers: HTTPHeaders
   82|       |        let bodyStream: InputStream
   83|       |        let bodyContentLength: UInt64
   84|       |        var hasInitialBoundary = false
   85|       |        var hasFinalBoundary = false
   86|       |
   87|      0|        init(headers: HTTPHeaders, bodyStream: InputStream, bodyContentLength: UInt64) {
   88|      0|            self.headers = headers
   89|      0|            self.bodyStream = bodyStream
   90|      0|            self.bodyContentLength = bodyContentLength
   91|      0|        }
   92|       |    }
   93|       |
   94|       |    // MARK: - Properties
   95|       |
   96|       |    /// Default memory threshold used when encoding `MultipartFormData`, in bytes.
   97|       |    public static let encodingMemoryThreshold: UInt64 = 10_000_000
   98|       |
   99|       |    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
  100|       |    open lazy var contentType: String = "multipart/form-data; boundary=\(self.boundary)"
  101|       |
  102|       |    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
  103|      0|    public var contentLength: UInt64 { bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
  104|       |
  105|       |    /// The boundary used to separate the body parts in the encoded form data.
  106|       |    public let boundary: String
  107|       |
  108|       |    let fileManager: FileManager
  109|       |
  110|       |    private var bodyParts: [BodyPart]
  111|       |    private var bodyPartError: AFError?
  112|       |    private let streamBufferSize: Int
  113|       |
  114|       |    // MARK: - Lifecycle
  115|       |
  116|       |    /// Creates an instance.
  117|       |    ///
  118|       |    /// - Parameters:
  119|       |    ///   - fileManager: `FileManager` to use for file operations, if needed.
  120|       |    ///   - boundary: Boundary `String` used to separate body parts.
  121|      0|    public init(fileManager: FileManager = .default, boundary: String? = nil) {
  122|      0|        self.fileManager = fileManager
  123|      0|        self.boundary = boundary ?? BoundaryGenerator.randomBoundary()
  124|      0|        bodyParts = []
  125|      0|
  126|      0|        //
  127|      0|        // The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more
  128|      0|        // information, please refer to the following article:
  129|      0|        //   - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
  130|      0|        //
  131|      0|        streamBufferSize = 1024
  132|      0|    }
  133|       |
  134|       |    // MARK: - Body Parts
  135|       |
  136|       |    /// Creates a body part from the data and appends it to the instance.
  137|       |    ///
  138|       |    /// The body part data will be encoded using the following format:
  139|       |    ///
  140|       |    /// - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
  141|       |    /// - `Content-Type: #{mimeType}` (HTTP Header)
  142|       |    /// - Encoded file data
  143|       |    /// - Multipart form boundary
  144|       |    ///
  145|       |    /// - Parameters:
  146|       |    ///   - data:     `Data` to encoding into the instance.
  147|       |    ///   - name:     Name to associate with the `Data` in the `Content-Disposition` HTTP header.
  148|       |    ///   - fileName: Filename to associate with the `Data` in the `Content-Disposition` HTTP header.
  149|       |    ///   - mimeType: MIME type to associate with the data in the `Content-Type` HTTP header.
  150|      0|    public func append(_ data: Data, withName name: String, fileName: String? = nil, mimeType: String? = nil) {
  151|      0|        let headers = contentHeaders(withName: name, fileName: fileName, mimeType: mimeType)
  152|      0|        let stream = InputStream(data: data)
  153|      0|        let length = UInt64(data.count)
  154|      0|
  155|      0|        append(stream, withLength: length, headers: headers)
  156|      0|    }
  157|       |
  158|       |    /// Creates a body part from the file and appends it to the instance.
  159|       |    ///
  160|       |    /// The body part data will be encoded using the following format:
  161|       |    ///
  162|       |    /// - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
  163|       |    /// - `Content-Type: #{generated mimeType}` (HTTP Header)
  164|       |    /// - Encoded file data
  165|       |    /// - Multipart form boundary
  166|       |    ///
  167|       |    /// The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
  168|       |    /// `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
  169|       |    /// system associated MIME type.
  170|       |    ///
  171|       |    /// - Parameters:
  172|       |    ///   - fileURL: `URL` of the file whose content will be encoded into the instance.
  173|       |    ///   - name:    Name to associate with the file content in the `Content-Disposition` HTTP header.
  174|      0|    public func append(_ fileURL: URL, withName name: String) {
  175|      0|        let fileName = fileURL.lastPathComponent
  176|      0|        let pathExtension = fileURL.pathExtension
  177|      0|
  178|      0|        if !fileName.isEmpty && !pathExtension.isEmpty {
  179|      0|            let mime = mimeType(forPathExtension: pathExtension)
  180|      0|            append(fileURL, withName: name, fileName: fileName, mimeType: mime)
  181|      0|        } else {
  182|      0|            setBodyPartError(withReason: .bodyPartFilenameInvalid(in: fileURL))
  183|      0|        }
  184|      0|    }
  185|       |
  186|       |    /// Creates a body part from the file and appends it to the instance.
  187|       |    ///
  188|       |    /// The body part data will be encoded using the following format:
  189|       |    ///
  190|       |    /// - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
  191|       |    /// - Content-Type: #{mimeType} (HTTP Header)
  192|       |    /// - Encoded file data
  193|       |    /// - Multipart form boundary
  194|       |    ///
  195|       |    /// - Parameters:
  196|       |    ///   - fileURL:  `URL` of the file whose content will be encoded into the instance.
  197|       |    ///   - name:     Name to associate with the file content in the `Content-Disposition` HTTP header.
  198|       |    ///   - fileName: Filename to associate with the file content in the `Content-Disposition` HTTP header.
  199|       |    ///   - mimeType: MIME type to associate with the file content in the `Content-Type` HTTP header.
  200|      0|    public func append(_ fileURL: URL, withName name: String, fileName: String, mimeType: String) {
  201|      0|        let headers = contentHeaders(withName: name, fileName: fileName, mimeType: mimeType)
  202|      0|
  203|      0|        //============================================================
  204|      0|        //                 Check 1 - is file URL?
  205|      0|        //============================================================
  206|      0|
  207|      0|        guard fileURL.isFileURL else {
  208|      0|            setBodyPartError(withReason: .bodyPartURLInvalid(url: fileURL))
  209|      0|            return
  210|      0|        }
  211|      0|
  212|      0|        //============================================================
  213|      0|        //              Check 2 - is file URL reachable?
  214|      0|        //============================================================
  215|      0|
  216|      0|        do {
  217|      0|            let isReachable = try fileURL.checkPromisedItemIsReachable()
  218|      0|            guard isReachable else {
  219|      0|                setBodyPartError(withReason: .bodyPartFileNotReachable(at: fileURL))
  220|      0|                return
  221|      0|            }
  222|      0|        } catch {
  223|      0|            setBodyPartError(withReason: .bodyPartFileNotReachableWithError(atURL: fileURL, error: error))
  224|      0|            return
  225|      0|        }
  226|      0|
  227|      0|        //============================================================
  228|      0|        //            Check 3 - is file URL a directory?
  229|      0|        //============================================================
  230|      0|
  231|      0|        var isDirectory: ObjCBool = false
  232|      0|        let path = fileURL.path
  233|      0|
  234|      0|        guard fileManager.fileExists(atPath: path, isDirectory: &isDirectory) && !isDirectory.boolValue else {
  235|      0|            setBodyPartError(withReason: .bodyPartFileIsDirectory(at: fileURL))
  236|      0|            return
  237|      0|        }
  238|      0|
  239|      0|        //============================================================
  240|      0|        //          Check 4 - can the file size be extracted?
  241|      0|        //============================================================
  242|      0|
  243|      0|        let bodyContentLength: UInt64
  244|      0|
  245|      0|        do {
  246|      0|            guard let fileSize = try fileManager.attributesOfItem(atPath: path)[.size] as? NSNumber else {
  247|      0|                setBodyPartError(withReason: .bodyPartFileSizeNotAvailable(at: fileURL))
  248|      0|                return
  249|      0|            }
  250|      0|
  251|      0|            bodyContentLength = fileSize.uint64Value
  252|      0|        } catch {
  253|      0|            setBodyPartError(withReason: .bodyPartFileSizeQueryFailedWithError(forURL: fileURL, error: error))
  254|      0|            return
  255|      0|        }
  256|      0|
  257|      0|        //============================================================
  258|      0|        //       Check 5 - can a stream be created from file URL?
  259|      0|        //============================================================
  260|      0|
  261|      0|        guard let stream = InputStream(url: fileURL) else {
  262|      0|            setBodyPartError(withReason: .bodyPartInputStreamCreationFailed(for: fileURL))
  263|      0|            return
  264|      0|        }
  265|      0|
  266|      0|        append(stream, withLength: bodyContentLength, headers: headers)
  267|      0|    }
  268|       |
  269|       |    /// Creates a body part from the stream and appends it to the instance.
  270|       |    ///
  271|       |    /// The body part data will be encoded using the following format:
  272|       |    ///
  273|       |    /// - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
  274|       |    /// - `Content-Type: #{mimeType}` (HTTP Header)
  275|       |    /// - Encoded stream data
  276|       |    /// - Multipart form boundary
  277|       |    ///
  278|       |    /// - Parameters:
  279|       |    ///   - stream:   `InputStream` to encode into the instance.
  280|       |    ///   - length:   Length, in bytes, of the stream.
  281|       |    ///   - name:     Name to associate with the stream content in the `Content-Disposition` HTTP header.
  282|       |    ///   - fileName: Filename to associate with the stream content in the `Content-Disposition` HTTP header.
  283|       |    ///   - mimeType: MIME type to associate with the stream content in the `Content-Type` HTTP header.
  284|       |    public func append(_ stream: InputStream,
  285|       |                       withLength length: UInt64,
  286|       |                       name: String,
  287|       |                       fileName: String,
  288|      0|                       mimeType: String) {
  289|      0|        let headers = contentHeaders(withName: name, fileName: fileName, mimeType: mimeType)
  290|      0|        append(stream, withLength: length, headers: headers)
  291|      0|    }
  292|       |
  293|       |    /// Creates a body part with the stream, length, and headers and appends it to the instance.
  294|       |    ///
  295|       |    /// The body part data will be encoded using the following format:
  296|       |    ///
  297|       |    /// - HTTP headers
  298|       |    /// - Encoded stream data
  299|       |    /// - Multipart form boundary
  300|       |    ///
  301|       |    /// - Parameters:
  302|       |    ///   - stream:  `InputStream` to encode into the instance.
  303|       |    ///   - length:  Length, in bytes, of the stream.
  304|       |    ///   - headers: `HTTPHeaders` for the body part.
  305|      0|    public func append(_ stream: InputStream, withLength length: UInt64, headers: HTTPHeaders) {
  306|      0|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
  307|      0|        bodyParts.append(bodyPart)
  308|      0|    }
  309|       |
  310|       |    // MARK: - Data Encoding
  311|       |
  312|       |    /// Encodes all appended body parts into a single `Data` value.
  313|       |    ///
  314|       |    /// - Note: This method will load all the appended body parts into memory all at the same time. This method should
  315|       |    ///         only be used when the encoded data will have a small memory footprint. For large data cases, please use
  316|       |    ///         the `writeEncodedData(to:))` method.
  317|       |    ///
  318|       |    /// - Returns: The encoded `Data`, if encoding is successful.
  319|       |    /// - Throws:  An `AFError` if encoding encounters an error.
  320|      0|    public func encode() throws -> Data {
  321|      0|        if let bodyPartError = bodyPartError {
  322|      0|            throw bodyPartError
  323|      0|        }
  324|      0|
  325|      0|        var encoded = Data()
  326|      0|
  327|      0|        bodyParts.first?.hasInitialBoundary = true
  328|      0|        bodyParts.last?.hasFinalBoundary = true
  329|      0|
  330|      0|        for bodyPart in bodyParts {
  331|      0|            let encodedData = try encode(bodyPart)
  332|      0|            encoded.append(encodedData)
  333|      0|        }
  334|      0|
  335|      0|        return encoded
  336|      0|    }
  337|       |
  338|       |    /// Writes all appended body parts to the given file `URL`.
  339|       |    ///
  340|       |    /// This process is facilitated by reading and writing with input and output streams, respectively. Thus,
  341|       |    /// this approach is very memory efficient and should be used for large body part data.
  342|       |    ///
  343|       |    /// - Parameter fileURL: File `URL` to which to write the form data.
  344|       |    /// - Throws:            An `AFError` if encoding encounters an error.
  345|      0|    public func writeEncodedData(to fileURL: URL) throws {
  346|      0|        if let bodyPartError = bodyPartError {
  347|      0|            throw bodyPartError
  348|      0|        }
  349|      0|
  350|      0|        if fileManager.fileExists(atPath: fileURL.path) {
  351|      0|            throw AFError.multipartEncodingFailed(reason: .outputStreamFileAlreadyExists(at: fileURL))
  352|      0|        } else if !fileURL.isFileURL {
  353|      0|            throw AFError.multipartEncodingFailed(reason: .outputStreamURLInvalid(url: fileURL))
  354|      0|        }
  355|      0|
  356|      0|        guard let outputStream = OutputStream(url: fileURL, append: false) else {
  357|      0|            throw AFError.multipartEncodingFailed(reason: .outputStreamCreationFailed(for: fileURL))
  358|      0|        }
  359|      0|
  360|      0|        outputStream.open()
  361|      0|        defer { outputStream.close() }
  362|      0|
  363|      0|        bodyParts.first?.hasInitialBoundary = true
  364|      0|        bodyParts.last?.hasFinalBoundary = true
  365|      0|
  366|      0|        for bodyPart in bodyParts {
  367|      0|            try write(bodyPart, to: outputStream)
  368|      0|        }
  369|      0|    }
  370|       |
  371|       |    // MARK: - Private - Body Part Encoding
  372|       |
  373|      0|    private func encode(_ bodyPart: BodyPart) throws -> Data {
  374|      0|        var encoded = Data()
  375|      0|
  376|      0|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
  377|      0|        encoded.append(initialData)
  378|      0|
  379|      0|        let headerData = encodeHeaders(for: bodyPart)
  380|      0|        encoded.append(headerData)
  381|      0|
  382|      0|        let bodyStreamData = try encodeBodyStream(for: bodyPart)
  383|      0|        encoded.append(bodyStreamData)
  384|      0|
  385|      0|        if bodyPart.hasFinalBoundary {
  386|      0|            encoded.append(finalBoundaryData())
  387|      0|        }
  388|      0|
  389|      0|        return encoded
  390|      0|    }
  391|       |
  392|      0|    private func encodeHeaders(for bodyPart: BodyPart) -> Data {
  393|      0|        let headerText = bodyPart.headers.map { "\($0.name): \($0.value)\(EncodingCharacters.crlf)" }
  394|      0|            .joined()
  395|      0|            + EncodingCharacters.crlf
  396|      0|
  397|      0|        return Data(headerText.utf8)
  398|      0|    }
  399|       |
  400|      0|    private func encodeBodyStream(for bodyPart: BodyPart) throws -> Data {
  401|      0|        let inputStream = bodyPart.bodyStream
  402|      0|        inputStream.open()
  403|      0|        defer { inputStream.close() }
  404|      0|
  405|      0|        var encoded = Data()
  406|      0|
  407|      0|        while inputStream.hasBytesAvailable {
  408|      0|            var buffer = [UInt8](repeating: 0, count: streamBufferSize)
  409|      0|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
  410|      0|
  411|      0|            if let error = inputStream.streamError {
  412|      0|                throw AFError.multipartEncodingFailed(reason: .inputStreamReadFailed(error: error))
  413|      0|            }
  414|      0|
  415|      0|            if bytesRead > 0 {
  416|      0|                encoded.append(buffer, count: bytesRead)
  417|      0|            } else {
  418|      0|                break
  419|      0|            }
  420|      0|        }
  421|      0|
  422|      0|        return encoded
  423|      0|    }
  424|       |
  425|       |    // MARK: - Private - Writing Body Part to Output Stream
  426|       |
  427|      0|    private func write(_ bodyPart: BodyPart, to outputStream: OutputStream) throws {
  428|      0|        try writeInitialBoundaryData(for: bodyPart, to: outputStream)
  429|      0|        try writeHeaderData(for: bodyPart, to: outputStream)
  430|      0|        try writeBodyStream(for: bodyPart, to: outputStream)
  431|      0|        try writeFinalBoundaryData(for: bodyPart, to: outputStream)
  432|      0|    }
  433|       |
  434|      0|    private func writeInitialBoundaryData(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  435|      0|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
  436|      0|        return try write(initialData, to: outputStream)
  437|      0|    }
  438|       |
  439|      0|    private func writeHeaderData(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  440|      0|        let headerData = encodeHeaders(for: bodyPart)
  441|      0|        return try write(headerData, to: outputStream)
  442|      0|    }
  443|       |
  444|      0|    private func writeBodyStream(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  445|      0|        let inputStream = bodyPart.bodyStream
  446|      0|
  447|      0|        inputStream.open()
  448|      0|        defer { inputStream.close() }
  449|      0|
  450|      0|        while inputStream.hasBytesAvailable {
  451|      0|            var buffer = [UInt8](repeating: 0, count: streamBufferSize)
  452|      0|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
  453|      0|
  454|      0|            if let streamError = inputStream.streamError {
  455|      0|                throw AFError.multipartEncodingFailed(reason: .inputStreamReadFailed(error: streamError))
  456|      0|            }
  457|      0|
  458|      0|            if bytesRead > 0 {
  459|      0|                if buffer.count != bytesRead {
  460|      0|                    buffer = Array(buffer[0..<bytesRead])
  461|      0|                }
  462|      0|
  463|      0|                try write(&buffer, to: outputStream)
  464|      0|            } else {
  465|      0|                break
  466|      0|            }
  467|      0|        }
  468|      0|    }
  469|       |
  470|      0|    private func writeFinalBoundaryData(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  471|      0|        if bodyPart.hasFinalBoundary {
  472|      0|            return try write(finalBoundaryData(), to: outputStream)
  473|      0|        }
  474|      0|    }
  475|       |
  476|       |    // MARK: - Private - Writing Buffered Data to Output Stream
  477|       |
  478|      0|    private func write(_ data: Data, to outputStream: OutputStream) throws {
  479|      0|        var buffer = [UInt8](repeating: 0, count: data.count)
  480|      0|        data.copyBytes(to: &buffer, count: data.count)
  481|      0|
  482|      0|        return try write(&buffer, to: outputStream)
  483|      0|    }
  484|       |
  485|      0|    private func write(_ buffer: inout [UInt8], to outputStream: OutputStream) throws {
  486|      0|        var bytesToWrite = buffer.count
  487|      0|
  488|      0|        while bytesToWrite > 0, outputStream.hasSpaceAvailable {
  489|      0|            let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
  490|      0|
  491|      0|            if let error = outputStream.streamError {
  492|      0|                throw AFError.multipartEncodingFailed(reason: .outputStreamWriteFailed(error: error))
  493|      0|            }
  494|      0|
  495|      0|            bytesToWrite -= bytesWritten
  496|      0|
  497|      0|            if bytesToWrite > 0 {
  498|      0|                buffer = Array(buffer[bytesWritten..<buffer.count])
  499|      0|            }
  500|      0|        }
  501|      0|    }
  502|       |
  503|       |    // MARK: - Private - Mime Type
  504|       |
  505|      0|    private func mimeType(forPathExtension pathExtension: String) -> String {
  506|      0|        if
  507|      0|            let id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension as CFString, nil)?.takeRetainedValue(),
  508|      0|            let contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue() {
  509|      0|            return contentType as String
  510|      0|        }
  511|      0|
  512|      0|        return "application/octet-stream"
  513|      0|    }
  514|       |
  515|       |    // MARK: - Private - Content Headers
  516|       |
  517|      0|    private func contentHeaders(withName name: String, fileName: String? = nil, mimeType: String? = nil) -> HTTPHeaders {
  518|      0|        var disposition = "form-data; name=\"\(name)\""
  519|      0|        if let fileName = fileName { disposition += "; filename=\"\(fileName)\"" }
  520|      0|
  521|      0|        var headers: HTTPHeaders = [.contentDisposition(disposition)]
  522|      0|        if let mimeType = mimeType { headers.add(.contentType(mimeType)) }
  523|      0|
  524|      0|        return headers
  525|      0|    }
  526|       |
  527|       |    // MARK: - Private - Boundary Encoding
  528|       |
  529|      0|    private func initialBoundaryData() -> Data {
  530|      0|        BoundaryGenerator.boundaryData(forBoundaryType: .initial, boundary: boundary)
  531|      0|    }
  532|       |
  533|      0|    private func encapsulatedBoundaryData() -> Data {
  534|      0|        BoundaryGenerator.boundaryData(forBoundaryType: .encapsulated, boundary: boundary)
  535|      0|    }
  536|       |
  537|      0|    private func finalBoundaryData() -> Data {
  538|      0|        BoundaryGenerator.boundaryData(forBoundaryType: .final, boundary: boundary)
  539|      0|    }
  540|       |
  541|       |    // MARK: - Private - Errors
  542|       |
  543|      0|    private func setBodyPartError(withReason reason: AFError.MultipartEncodingFailureReason) {
  544|      0|        guard bodyPartError == nil else { return }
  545|      0|        bodyPartError = AFError.multipartEncodingFailed(reason: reason)
  546|      0|    }
  547|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/MultipartUpload.swift:
    1|       |//
    2|       |//  MultipartUpload.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Internal type which encapsulates a `MultipartFormData` upload.
   28|       |final class MultipartUpload {
   29|      0|    lazy var result = Result { try build() }
   30|       |
   31|       |    let isInBackgroundSession: Bool
   32|       |    let multipartFormData: MultipartFormData
   33|       |    let encodingMemoryThreshold: UInt64
   34|       |    let request: URLRequestConvertible
   35|       |    let fileManager: FileManager
   36|       |
   37|       |    init(isInBackgroundSession: Bool,
   38|       |         encodingMemoryThreshold: UInt64,
   39|       |         request: URLRequestConvertible,
   40|      0|         multipartFormData: MultipartFormData) {
   41|      0|        self.isInBackgroundSession = isInBackgroundSession
   42|      0|        self.encodingMemoryThreshold = encodingMemoryThreshold
   43|      0|        self.request = request
   44|      0|        fileManager = multipartFormData.fileManager
   45|      0|        self.multipartFormData = multipartFormData
   46|      0|    }
   47|       |
   48|      0|    func build() throws -> (request: URLRequest, uploadable: UploadRequest.Uploadable) {
   49|      0|        var urlRequest = try request.asURLRequest()
   50|      0|        urlRequest.setValue(multipartFormData.contentType, forHTTPHeaderField: "Content-Type")
   51|      0|
   52|      0|        let uploadable: UploadRequest.Uploadable
   53|      0|        if multipartFormData.contentLength < encodingMemoryThreshold && !isInBackgroundSession {
   54|      0|            let data = try multipartFormData.encode()
   55|      0|
   56|      0|            uploadable = .data(data)
   57|      0|        } else {
   58|      0|            let tempDirectoryURL = fileManager.temporaryDirectory
   59|      0|            let directoryURL = tempDirectoryURL.appendingPathComponent("org.alamofire.manager/multipart.form.data")
   60|      0|            let fileName = UUID().uuidString
   61|      0|            let fileURL = directoryURL.appendingPathComponent(fileName)
   62|      0|
   63|      0|            try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
   64|      0|
   65|      0|            do {
   66|      0|                try multipartFormData.writeEncodedData(to: fileURL)
   67|      0|            } catch {
   68|      0|                // Cleanup after attempted write if it fails.
   69|      0|                try? fileManager.removeItem(at: fileURL)
   70|      0|                throw error
   71|      0|            }
   72|      0|
   73|      0|            uploadable = .file(fileURL, shouldRemove: true)
   74|      0|        }
   75|      0|
   76|      0|        return (request: urlRequest, uploadable: uploadable)
   77|      0|    }
   78|       |}
   79|       |
   80|       |extension MultipartUpload: UploadConvertible {
   81|      0|    func asURLRequest() throws -> URLRequest {
   82|      0|        try result.get().request
   83|      0|    }
   84|       |
   85|      0|    func createUploadable() throws -> UploadRequest.Uploadable {
   86|      0|        try result.get().uploadable
   87|      0|    }
   88|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/NetworkReachabilityManager.swift:
    1|       |//
    2|       |//  NetworkReachabilityManager.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |#if !(os(watchOS) || os(Linux))
   26|       |
   27|       |import Foundation
   28|       |import SystemConfiguration
   29|       |
   30|       |/// The `NetworkReachabilityManager` class listens for reachability changes of hosts and addresses for both cellular and
   31|       |/// WiFi network interfaces.
   32|       |///
   33|       |/// Reachability can be used to determine background information about why a network operation failed, or to retry
   34|       |/// network requests when a connection is established. It should not be used to prevent a user from initiating a network
   35|       |/// request, as it's possible that an initial request may be required to establish reachability.
   36|       |open class NetworkReachabilityManager {
   37|       |    /// Defines the various states of network reachability.
   38|       |    public enum NetworkReachabilityStatus {
   39|       |        /// It is unknown whether the network is reachable.
   40|       |        case unknown
   41|       |        /// The network is not reachable.
   42|       |        case notReachable
   43|       |        /// The network is reachable on the associated `ConnectionType`.
   44|       |        case reachable(ConnectionType)
   45|       |
   46|      0|        init(_ flags: SCNetworkReachabilityFlags) {
   47|      0|            guard flags.isActuallyReachable else { self = .notReachable; return }
   48|      0|
   49|      0|            var networkStatus: NetworkReachabilityStatus = .reachable(.ethernetOrWiFi)
   50|      0|
   51|      0|            if flags.isCellular { networkStatus = .reachable(.cellular) }
   52|      0|
   53|      0|            self = networkStatus
   54|      0|        }
   55|       |
   56|       |        /// Defines the various connection types detected by reachability flags.
   57|       |        public enum ConnectionType {
   58|       |            /// The connection type is either over Ethernet or WiFi.
   59|       |            case ethernetOrWiFi
   60|       |            /// The connection type is a cellular connection.
   61|       |            case cellular
   62|       |        }
   63|       |    }
   64|       |
   65|       |    /// A closure executed when the network reachability status changes. The closure takes a single argument: the
   66|       |    /// network reachability status.
   67|       |    public typealias Listener = (NetworkReachabilityStatus) -> Void
   68|       |
   69|       |    /// Default `NetworkReachabilityManager` for the zero address and a `listenerQueue` of `.main`.
   70|       |    public static let `default` = NetworkReachabilityManager()
   71|       |
   72|       |    // MARK: - Properties
   73|       |
   74|       |    /// Whether the network is currently reachable.
   75|      0|    open var isReachable: Bool { isReachableOnCellular || isReachableOnEthernetOrWiFi }
   76|       |
   77|       |    /// Whether the network is currently reachable over the cellular interface.
   78|       |    ///
   79|       |    /// - Note: Using this property to decide whether to make a high or low bandwidth request is not recommended.
   80|       |    ///         Instead, set the `allowsCellularAccess` on any `URLRequest`s being issued.
   81|       |    ///
   82|      0|    open var isReachableOnCellular: Bool { status == .reachable(.cellular) }
   83|       |
   84|       |    /// Whether the network is currently reachable over Ethernet or WiFi interface.
   85|      0|    open var isReachableOnEthernetOrWiFi: Bool { status == .reachable(.ethernetOrWiFi) }
   86|       |
   87|       |    /// `DispatchQueue` on which reachability will update.
   88|      0|    public let reachabilityQueue = DispatchQueue(label: "org.alamofire.reachabilityQueue")
   89|       |
   90|       |    /// Flags of the current reachability type, if any.
   91|      0|    open var flags: SCNetworkReachabilityFlags? {
   92|      0|        var flags = SCNetworkReachabilityFlags()
   93|      0|
   94|      0|        return (SCNetworkReachabilityGetFlags(reachability, &flags)) ? flags : nil
   95|      0|    }
   96|       |
   97|       |    /// The current network reachability status.
   98|      0|    open var status: NetworkReachabilityStatus {
   99|      0|        flags.map(NetworkReachabilityStatus.init) ?? .unknown
  100|      0|    }
  101|       |
  102|       |    /// Mutable state storage.
  103|       |    struct MutableState {
  104|       |        /// A closure executed when the network reachability status changes.
  105|       |        var listener: Listener?
  106|       |        /// `DispatchQueue` on which listeners will be called.
  107|       |        var listenerQueue: DispatchQueue?
  108|       |        /// Previously calculated status.
  109|       |        var previousStatus: NetworkReachabilityStatus?
  110|       |    }
  111|       |
  112|       |    /// `SCNetworkReachability` instance providing notifications.
  113|       |    private let reachability: SCNetworkReachability
  114|       |
  115|       |    /// Protected storage for mutable state.
  116|       |    @Protected
  117|      0|    private var mutableState = MutableState()
  118|       |
  119|       |    // MARK: - Initialization
  120|       |
  121|       |    /// Creates an instance with the specified host.
  122|       |    ///
  123|       |    /// - Note: The `host` value must *not* contain a scheme, just the hostname.
  124|       |    ///
  125|       |    /// - Parameters:
  126|       |    ///   - host:          Host used to evaluate network reachability. Must *not* include the scheme (e.g. `https`).
  127|      0|    public convenience init?(host: String) {
  128|      0|        guard let reachability = SCNetworkReachabilityCreateWithName(nil, host) else { return nil }
  129|      0|
  130|      0|        self.init(reachability: reachability)
  131|      0|    }
  132|       |
  133|       |    /// Creates an instance that monitors the address 0.0.0.0.
  134|       |    ///
  135|       |    /// Reachability treats the 0.0.0.0 address as a special token that causes it to monitor the general routing
  136|       |    /// status of the device, both IPv4 and IPv6.
  137|      0|    public convenience init?() {
  138|      0|        var zero = sockaddr()
  139|      0|        zero.sa_len = UInt8(MemoryLayout<sockaddr>.size)
  140|      0|        zero.sa_family = sa_family_t(AF_INET)
  141|      0|
  142|      0|        guard let reachability = SCNetworkReachabilityCreateWithAddress(nil, &zero) else { return nil }
  143|      0|
  144|      0|        self.init(reachability: reachability)
  145|      0|    }
  146|       |
  147|      0|    private init(reachability: SCNetworkReachability) {
  148|      0|        self.reachability = reachability
  149|      0|    }
  150|       |
  151|      0|    deinit {
  152|      0|        stopListening()
  153|      0|    }
  154|       |
  155|       |    // MARK: - Listening
  156|       |
  157|       |    /// Starts listening for changes in network reachability status.
  158|       |    ///
  159|       |    /// - Note: Stops and removes any existing listener.
  160|       |    ///
  161|       |    /// - Parameters:
  162|       |    ///   - queue:    `DispatchQueue` on which to call the `listener` closure. `.main` by default.
  163|       |    ///   - listener: `Listener` closure called when reachability changes.
  164|       |    ///
  165|       |    /// - Returns: `true` if listening was started successfully, `false` otherwise.
  166|       |    @discardableResult
  167|       |    open func startListening(onQueue queue: DispatchQueue = .main,
  168|      0|                             onUpdatePerforming listener: @escaping Listener) -> Bool {
  169|      0|        stopListening()
  170|      0|
  171|      0|        $mutableState.write { state in
  172|      0|            state.listenerQueue = queue
  173|      0|            state.listener = listener
  174|      0|        }
  175|      0|
  176|      0|        var context = SCNetworkReachabilityContext(version: 0,
  177|      0|                                                   info: Unmanaged.passUnretained(self).toOpaque(),
  178|      0|                                                   retain: nil,
  179|      0|                                                   release: nil,
  180|      0|                                                   copyDescription: nil)
  181|      0|        let callback: SCNetworkReachabilityCallBack = { _, flags, info in
  182|      0|            guard let info = info else { return }
  183|      0|
  184|      0|            let instance = Unmanaged<NetworkReachabilityManager>.fromOpaque(info).takeUnretainedValue()
  185|      0|            instance.notifyListener(flags)
  186|      0|        }
  187|      0|
  188|      0|        let queueAdded = SCNetworkReachabilitySetDispatchQueue(reachability, reachabilityQueue)
  189|      0|        let callbackAdded = SCNetworkReachabilitySetCallback(reachability, callback, &context)
  190|      0|
  191|      0|        // Manually call listener to give initial state, since the framework may not.
  192|      0|        if let currentFlags = flags {
  193|      0|            reachabilityQueue.async {
  194|      0|                self.notifyListener(currentFlags)
  195|      0|            }
  196|      0|        }
  197|      0|
  198|      0|        return callbackAdded && queueAdded
  199|      0|    }
  200|       |
  201|       |    /// Stops listening for changes in network reachability status.
  202|      0|    open func stopListening() {
  203|      0|        SCNetworkReachabilitySetCallback(reachability, nil, nil)
  204|      0|        SCNetworkReachabilitySetDispatchQueue(reachability, nil)
  205|      0|        $mutableState.write { state in
  206|      0|            state.listener = nil
  207|      0|            state.listenerQueue = nil
  208|      0|            state.previousStatus = nil
  209|      0|        }
  210|      0|    }
  211|       |
  212|       |    // MARK: - Internal - Listener Notification
  213|       |
  214|       |    /// Calls the `listener` closure of the `listenerQueue` if the computed status hasn't changed.
  215|       |    ///
  216|       |    /// - Note: Should only be called from the `reachabilityQueue`.
  217|       |    ///
  218|       |    /// - Parameter flags: `SCNetworkReachabilityFlags` to use to calculate the status.
  219|      0|    func notifyListener(_ flags: SCNetworkReachabilityFlags) {
  220|      0|        let newStatus = NetworkReachabilityStatus(flags)
  221|      0|
  222|      0|        $mutableState.write { state in
  223|      0|            guard state.previousStatus != newStatus else { return }
  224|      0|
  225|      0|            state.previousStatus = newStatus
  226|      0|
  227|      0|            let listener = state.listener
  228|      0|            state.listenerQueue?.async { listener?(newStatus) }
  229|      0|        }
  230|      0|    }
  231|       |}
  232|       |
  233|       |// MARK: -
  234|       |
  235|       |extension NetworkReachabilityManager.NetworkReachabilityStatus: Equatable {}
  236|       |
  237|       |extension SCNetworkReachabilityFlags {
  238|      0|    var isReachable: Bool { contains(.reachable) }
  239|      0|    var isConnectionRequired: Bool { contains(.connectionRequired) }
  240|      0|    var canConnectAutomatically: Bool { contains(.connectionOnDemand) || contains(.connectionOnTraffic) }
  241|      0|    var canConnectWithoutUserInteraction: Bool { canConnectAutomatically && !contains(.interventionRequired) }
  242|      0|    var isActuallyReachable: Bool { isReachable && (!isConnectionRequired || canConnectWithoutUserInteraction) }
  243|      0|    var isCellular: Bool {
  244|      0|        #if os(iOS) || os(tvOS)
  245|      0|        return contains(.isWWAN)
  246|      0|        #else
  247|      0|        return false
  248|      0|        #endif
  249|      0|    }
  250|       |
  251|       |    /// Human readable `String` for all states, to help with debugging.
  252|      0|    var readableDescription: String {
  253|      0|        let W = isCellular ? "W" : "-"
  254|      0|        let R = isReachable ? "R" : "-"
  255|      0|        let c = isConnectionRequired ? "c" : "-"
  256|      0|        let t = contains(.transientConnection) ? "t" : "-"
  257|      0|        let i = contains(.interventionRequired) ? "i" : "-"
  258|      0|        let C = contains(.connectionOnTraffic) ? "C" : "-"
  259|      0|        let D = contains(.connectionOnDemand) ? "D" : "-"
  260|      0|        let l = contains(.isLocalAddress) ? "l" : "-"
  261|      0|        let d = contains(.isDirect) ? "d" : "-"
  262|      0|        let a = contains(.connectionAutomatic) ? "a" : "-"
  263|      0|
  264|      0|        return "\(W)\(R) \(c)\(t)\(i)\(C)\(D)\(l)\(d)\(a)"
  265|      0|    }
  266|       |}
  267|       |#endif

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Notifications.swift:
    1|       |//
    2|       |//  Notifications.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension Request {
   28|       |    /// Posted when a `Request` is resumed. The `Notification` contains the resumed `Request`.
   29|       |    public static let didResumeNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didResume")
   30|       |    /// Posted when a `Request` is suspended. The `Notification` contains the suspended `Request`.
   31|       |    public static let didSuspendNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didSuspend")
   32|       |    /// Posted when a `Request` is cancelled. The `Notification` contains the cancelled `Request`.
   33|       |    public static let didCancelNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didCancel")
   34|       |    /// Posted when a `Request` is finished. The `Notification` contains the completed `Request`.
   35|       |    public static let didFinishNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didFinish")
   36|       |
   37|       |    /// Posted when a `URLSessionTask` is resumed. The `Notification` contains the `Request` associated with the `URLSessionTask`.
   38|       |    public static let didResumeTaskNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didResumeTask")
   39|       |    /// Posted when a `URLSessionTask` is suspended. The `Notification` contains the `Request` associated with the `URLSessionTask`.
   40|       |    public static let didSuspendTaskNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didSuspendTask")
   41|       |    /// Posted when a `URLSessionTask` is cancelled. The `Notification` contains the `Request` associated with the `URLSessionTask`.
   42|       |    public static let didCancelTaskNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didCancelTask")
   43|       |    /// Posted when a `URLSessionTask` is completed. The `Notification` contains the `Request` associated with the `URLSessionTask`.
   44|       |    public static let didCompleteTaskNotification = Notification.Name(rawValue: "org.alamofire.notification.name.request.didCompleteTask")
   45|       |}
   46|       |
   47|       |// MARK: -
   48|       |
   49|       |extension Notification {
   50|       |    /// The `Request` contained by the instance's `userInfo`, `nil` otherwise.
   51|      0|    public var request: Request? {
   52|      0|        userInfo?[String.requestKey] as? Request
   53|      0|    }
   54|       |
   55|       |    /// Convenience initializer for a `Notification` containing a `Request` payload.
   56|       |    ///
   57|       |    /// - Parameters:
   58|       |    ///   - name:    The name of the notification.
   59|       |    ///   - request: The `Request` payload.
   60|      0|    init(name: Notification.Name, request: Request) {
   61|      0|        self.init(name: name, object: nil, userInfo: [String.requestKey: request])
   62|      0|    }
   63|       |}
   64|       |
   65|       |extension NotificationCenter {
   66|       |    /// Convenience function for posting notifications with `Request` payloads.
   67|       |    ///
   68|       |    /// - Parameters:
   69|       |    ///   - name:    The name of the notification.
   70|       |    ///   - request: The `Request` payload.
   71|      0|    func postNotification(named name: Notification.Name, with request: Request) {
   72|      0|        let notification = Notification(name: name, request: request)
   73|      0|        post(notification)
   74|      0|    }
   75|       |}
   76|       |
   77|       |extension String {
   78|       |    /// User info dictionary key representing the `Request` associated with the notification.
   79|       |    fileprivate static let requestKey = "org.alamofire.notification.key.request"
   80|       |}
   81|       |
   82|       |/// `EventMonitor` that provides Alamofire's notifications.
   83|       |public final class AlamofireNotifications: EventMonitor {
   84|      0|    public func requestDidResume(_ request: Request) {
   85|      0|        NotificationCenter.default.postNotification(named: Request.didResumeNotification, with: request)
   86|      0|    }
   87|       |
   88|      0|    public func requestDidSuspend(_ request: Request) {
   89|      0|        NotificationCenter.default.postNotification(named: Request.didSuspendNotification, with: request)
   90|      0|    }
   91|       |
   92|      0|    public func requestDidCancel(_ request: Request) {
   93|      0|        NotificationCenter.default.postNotification(named: Request.didCancelNotification, with: request)
   94|      0|    }
   95|       |
   96|      0|    public func requestDidFinish(_ request: Request) {
   97|      0|        NotificationCenter.default.postNotification(named: Request.didFinishNotification, with: request)
   98|      0|    }
   99|       |
  100|      0|    public func request(_ request: Request, didResumeTask task: URLSessionTask) {
  101|      0|        NotificationCenter.default.postNotification(named: Request.didResumeTaskNotification, with: request)
  102|      0|    }
  103|       |
  104|      0|    public func request(_ request: Request, didSuspendTask task: URLSessionTask) {
  105|      0|        NotificationCenter.default.postNotification(named: Request.didSuspendTaskNotification, with: request)
  106|      0|    }
  107|       |
  108|      0|    public func request(_ request: Request, didCancelTask task: URLSessionTask) {
  109|      0|        NotificationCenter.default.postNotification(named: Request.didCancelTaskNotification, with: request)
  110|      0|    }
  111|       |
  112|      0|    public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) {
  113|      0|        NotificationCenter.default.postNotification(named: Request.didCompleteTaskNotification, with: request)
  114|      0|    }
  115|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/OperationQueue+Alamofire.swift:
    1|       |//
    2|       |//  OperationQueue+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension OperationQueue {
   28|       |    /// Creates an instance using the provided parameters.
   29|       |    ///
   30|       |    /// - Parameters:
   31|       |    ///   - qualityOfService:            `QualityOfService` to be applied to the queue. `.default` by default.
   32|       |    ///   - maxConcurrentOperationCount: Maximum concurrent operations.
   33|       |    ///                                  `OperationQueue.defaultMaxConcurrentOperationCount` by default.
   34|       |    ///   - underlyingQueue: Underlying  `DispatchQueue`. `nil` by default.
   35|       |    ///   - name:                        Name for the queue. `nil` by default.
   36|       |    ///   - startSuspended:              Whether the queue starts suspended. `false` by default.
   37|       |    convenience init(qualityOfService: QualityOfService = .default,
   38|       |                     maxConcurrentOperationCount: Int = OperationQueue.defaultMaxConcurrentOperationCount,
   39|       |                     underlyingQueue: DispatchQueue? = nil,
   40|       |                     name: String? = nil,
   41|      0|                     startSuspended: Bool = false) {
   42|      0|        self.init()
   43|      0|        self.qualityOfService = qualityOfService
   44|      0|        self.maxConcurrentOperationCount = maxConcurrentOperationCount
   45|      0|        self.underlyingQueue = underlyingQueue
   46|      0|        self.name = name
   47|      0|        isSuspended = startSuspended
   48|      0|    }
   49|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/ParameterEncoder.swift:
    1|       |//
    2|       |//  ParameterEncoder.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A type that can encode any `Encodable` type into a `URLRequest`.
   28|       |public protocol ParameterEncoder {
   29|       |    /// Encode the provided `Encodable` parameters into `request`.
   30|       |    ///
   31|       |    /// - Parameters:
   32|       |    ///   - parameters: The `Encodable` parameter value.
   33|       |    ///   - request:    The `URLRequest` into which to encode the parameters.
   34|       |    ///
   35|       |    /// - Returns:      A `URLRequest` with the result of the encoding.
   36|       |    /// - Throws:       An `Error` when encoding fails. For Alamofire provided encoders, this will be an instance of
   37|       |    ///                 `AFError.parameterEncoderFailed` with an associated `ParameterEncoderFailureReason`.
   38|       |    func encode<Parameters: Encodable>(_ parameters: Parameters?, into request: URLRequest) throws -> URLRequest
   39|       |}
   40|       |
   41|       |/// A `ParameterEncoder` that encodes types as JSON body data.
   42|       |///
   43|       |/// If no `Content-Type` header is already set on the provided `URLRequest`s, it's set to `application/json`.
   44|       |open class JSONParameterEncoder: ParameterEncoder {
   45|       |    /// Returns an encoder with default parameters.
   46|      0|    public static var `default`: JSONParameterEncoder { JSONParameterEncoder() }
   47|       |
   48|       |    /// Returns an encoder with `JSONEncoder.outputFormatting` set to `.prettyPrinted`.
   49|      0|    public static var prettyPrinted: JSONParameterEncoder {
   50|      0|        let encoder = JSONEncoder()
   51|      0|        encoder.outputFormatting = .prettyPrinted
   52|      0|
   53|      0|        return JSONParameterEncoder(encoder: encoder)
   54|      0|    }
   55|       |
   56|       |    /// Returns an encoder with `JSONEncoder.outputFormatting` set to `.sortedKeys`.
   57|       |    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
   58|      0|    public static var sortedKeys: JSONParameterEncoder {
   59|      0|        let encoder = JSONEncoder()
   60|      0|        encoder.outputFormatting = .sortedKeys
   61|      0|
   62|      0|        return JSONParameterEncoder(encoder: encoder)
   63|      0|    }
   64|       |
   65|       |    /// `JSONEncoder` used to encode parameters.
   66|       |    public let encoder: JSONEncoder
   67|       |
   68|       |    /// Creates an instance with the provided `JSONEncoder`.
   69|       |    ///
   70|       |    /// - Parameter encoder: The `JSONEncoder`. `JSONEncoder()` by default.
   71|      0|    public init(encoder: JSONEncoder = JSONEncoder()) {
   72|      0|        self.encoder = encoder
   73|      0|    }
   74|       |
   75|       |    open func encode<Parameters: Encodable>(_ parameters: Parameters?,
   76|      0|                                            into request: URLRequest) throws -> URLRequest {
   77|      0|        guard let parameters = parameters else { return request }
   78|      0|
   79|      0|        var request = request
   80|      0|
   81|      0|        do {
   82|      0|            let data = try encoder.encode(parameters)
   83|      0|            request.httpBody = data
   84|      0|            if request.headers["Content-Type"] == nil {
   85|      0|                request.headers.update(.contentType("application/json"))
   86|      0|            }
   87|      0|        } catch {
   88|      0|            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
   89|      0|        }
   90|      0|
   91|      0|        return request
   92|      0|    }
   93|       |}
   94|       |
   95|       |/// A `ParameterEncoder` that encodes types as URL-encoded query strings to be set on the URL or as body data, depending
   96|       |/// on the `Destination` set.
   97|       |///
   98|       |/// If no `Content-Type` header is already set on the provided `URLRequest`s, it will be set to
   99|       |/// `application/x-www-form-urlencoded; charset=utf-8`.
  100|       |///
  101|       |/// Encoding behavior can be customized by passing an instance of `URLEncodedFormEncoder` to the initializer.
  102|       |open class URLEncodedFormParameterEncoder: ParameterEncoder {
  103|       |    /// Defines where the URL-encoded string should be set for each `URLRequest`.
  104|       |    public enum Destination {
  105|       |        /// Applies the encoded query string to any existing query string for `.get`, `.head`, and `.delete` request.
  106|       |        /// Sets it to the `httpBody` for all other methods.
  107|       |        case methodDependent
  108|       |        /// Applies the encoded query string to any existing query string from the `URLRequest`.
  109|       |        case queryString
  110|       |        /// Applies the encoded query string to the `httpBody` of the `URLRequest`.
  111|       |        case httpBody
  112|       |
  113|       |        /// Determines whether the URL-encoded string should be applied to the `URLRequest`'s `url`.
  114|       |        ///
  115|       |        /// - Parameter method: The `HTTPMethod`.
  116|       |        ///
  117|       |        /// - Returns:          Whether the URL-encoded string should be applied to a `URL`.
  118|      0|        func encodesParametersInURL(for method: HTTPMethod) -> Bool {
  119|      0|            switch self {
  120|      0|            case .methodDependent: return [.get, .head, .delete].contains(method)
  121|      0|            case .queryString: return true
  122|      0|            case .httpBody: return false
  123|      0|            }
  124|      0|        }
  125|       |    }
  126|       |
  127|       |    /// Returns an encoder with default parameters.
  128|      0|    public static var `default`: URLEncodedFormParameterEncoder { URLEncodedFormParameterEncoder() }
  129|       |
  130|       |    /// The `URLEncodedFormEncoder` to use.
  131|       |    public let encoder: URLEncodedFormEncoder
  132|       |
  133|       |    /// The `Destination` for the URL-encoded string.
  134|       |    public let destination: Destination
  135|       |
  136|       |    /// Creates an instance with the provided `URLEncodedFormEncoder` instance and `Destination` value.
  137|       |    ///
  138|       |    /// - Parameters:
  139|       |    ///   - encoder:     The `URLEncodedFormEncoder`. `URLEncodedFormEncoder()` by default.
  140|       |    ///   - destination: The `Destination`. `.methodDependent` by default.
  141|      0|    public init(encoder: URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: Destination = .methodDependent) {
  142|      0|        self.encoder = encoder
  143|      0|        self.destination = destination
  144|      0|    }
  145|       |
  146|       |    open func encode<Parameters: Encodable>(_ parameters: Parameters?,
  147|      0|                                            into request: URLRequest) throws -> URLRequest {
  148|      0|        guard let parameters = parameters else { return request }
  149|      0|
  150|      0|        var request = request
  151|      0|
  152|      0|        guard let url = request.url else {
  153|      0|            throw AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.url))
  154|      0|        }
  155|      0|
  156|      0|        guard let method = request.method else {
  157|      0|            let rawValue = request.method?.rawValue ?? "nil"
  158|      0|            throw AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.httpMethod(rawValue: rawValue)))
  159|      0|        }
  160|      0|
  161|      0|        if destination.encodesParametersInURL(for: method),
  162|      0|           var components = URLComponents(url: url, resolvingAgainstBaseURL: false) {
  163|      0|            let query: String = try Result<String, Error> { try encoder.encode(parameters) }
  164|      0|                .mapError { AFError.parameterEncoderFailed(reason: .encoderFailed(error: $0)) }.get()
  165|      0|            let newQueryString = [components.percentEncodedQuery, query].compactMap { $0 }.joinedWithAmpersands()
  166|      0|            components.percentEncodedQuery = newQueryString.isEmpty ? nil : newQueryString
  167|      0|
  168|      0|            guard let newURL = components.url else {
  169|      0|                throw AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.url))
  170|      0|            }
  171|      0|
  172|      0|            request.url = newURL
  173|      0|        } else {
  174|      0|            if request.headers["Content-Type"] == nil {
  175|      0|                request.headers.update(.contentType("application/x-www-form-urlencoded; charset=utf-8"))
  176|      0|            }
  177|      0|
  178|      0|            request.httpBody = try Result<Data, Error> { try encoder.encode(parameters) }
  179|      0|                .mapError { AFError.parameterEncoderFailed(reason: .encoderFailed(error: $0)) }.get()
  180|      0|        }
  181|      0|
  182|      0|        return request
  183|      0|    }
  184|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/ParameterEncoding.swift:
    1|       |//
    2|       |//  ParameterEncoding.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A dictionary of parameters to apply to a `URLRequest`.
   28|       |public typealias Parameters = [String: Any]
   29|       |
   30|       |/// A type used to define how a set of parameters are applied to a `URLRequest`.
   31|       |public protocol ParameterEncoding {
   32|       |    /// Creates a `URLRequest` by encoding parameters and applying them on the passed request.
   33|       |    ///
   34|       |    /// - Parameters:
   35|       |    ///   - urlRequest: `URLRequestConvertible` value onto which parameters will be encoded.
   36|       |    ///   - parameters: `Parameters` to encode onto the request.
   37|       |    ///
   38|       |    /// - Returns:      The encoded `URLRequest`.
   39|       |    /// - Throws:       Any `Error` produced during parameter encoding.
   40|       |    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest
   41|       |}
   42|       |
   43|       |// MARK: -
   44|       |
   45|       |/// Creates a url-encoded query string to be set as or appended to any existing URL query string or set as the HTTP
   46|       |/// body of the URL request. Whether the query string is set or appended to any existing URL query string or set as
   47|       |/// the HTTP body depends on the destination of the encoding.
   48|       |///
   49|       |/// The `Content-Type` HTTP header field of an encoded request with HTTP body is set to
   50|       |/// `application/x-www-form-urlencoded; charset=utf-8`.
   51|       |///
   52|       |/// There is no published specification for how to encode collection types. By default the convention of appending
   53|       |/// `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for
   54|       |/// nested dictionary values (`foo[bar]=baz`) is used. Optionally, `ArrayEncoding` can be used to omit the
   55|       |/// square brackets appended to array keys.
   56|       |///
   57|       |/// `BoolEncoding` can be used to configure how boolean values are encoded. The default behavior is to encode
   58|       |/// `true` as 1 and `false` as 0.
   59|       |public struct URLEncoding: ParameterEncoding {
   60|       |    // MARK: Helper Types
   61|       |
   62|       |    /// Defines whether the url-encoded query string is applied to the existing query string or HTTP body of the
   63|       |    /// resulting URL request.
   64|       |    public enum Destination {
   65|       |        /// Applies encoded query string result to existing query string for `GET`, `HEAD` and `DELETE` requests and
   66|       |        /// sets as the HTTP body for requests with any other HTTP method.
   67|       |        case methodDependent
   68|       |        /// Sets or appends encoded query string result to existing query string.
   69|       |        case queryString
   70|       |        /// Sets encoded query string result as the HTTP body of the URL request.
   71|       |        case httpBody
   72|       |
   73|      0|        func encodesParametersInURL(for method: HTTPMethod) -> Bool {
   74|      0|            switch self {
   75|      0|            case .methodDependent: return [.get, .head, .delete].contains(method)
   76|      0|            case .queryString: return true
   77|      0|            case .httpBody: return false
   78|      0|            }
   79|      0|        }
   80|       |    }
   81|       |
   82|       |    /// Configures how `Array` parameters are encoded.
   83|       |    public enum ArrayEncoding {
   84|       |        /// An empty set of square brackets is appended to the key for every value. This is the default behavior.
   85|       |        case brackets
   86|       |        /// No brackets are appended. The key is encoded as is.
   87|       |        case noBrackets
   88|       |
   89|      0|        func encode(key: String) -> String {
   90|      0|            switch self {
   91|      0|            case .brackets:
   92|      0|                return "\(key)[]"
   93|      0|            case .noBrackets:
   94|      0|                return key
   95|      0|            }
   96|      0|        }
   97|       |    }
   98|       |
   99|       |    /// Configures how `Bool` parameters are encoded.
  100|       |    public enum BoolEncoding {
  101|       |        /// Encode `true` as `1` and `false` as `0`. This is the default behavior.
  102|       |        case numeric
  103|       |        /// Encode `true` and `false` as string literals.
  104|       |        case literal
  105|       |
  106|      0|        func encode(value: Bool) -> String {
  107|      0|            switch self {
  108|      0|            case .numeric:
  109|      0|                return value ? "1" : "0"
  110|      0|            case .literal:
  111|      0|                return value ? "true" : "false"
  112|      0|            }
  113|      0|        }
  114|       |    }
  115|       |
  116|       |    // MARK: Properties
  117|       |
  118|       |    /// Returns a default `URLEncoding` instance with a `.methodDependent` destination.
  119|      0|    public static var `default`: URLEncoding { URLEncoding() }
  120|       |
  121|       |    /// Returns a `URLEncoding` instance with a `.queryString` destination.
  122|      0|    public static var queryString: URLEncoding { URLEncoding(destination: .queryString) }
  123|       |
  124|       |    /// Returns a `URLEncoding` instance with an `.httpBody` destination.
  125|      0|    public static var httpBody: URLEncoding { URLEncoding(destination: .httpBody) }
  126|       |
  127|       |    /// The destination defining where the encoded query string is to be applied to the URL request.
  128|       |    public let destination: Destination
  129|       |
  130|       |    /// The encoding to use for `Array` parameters.
  131|       |    public let arrayEncoding: ArrayEncoding
  132|       |
  133|       |    /// The encoding to use for `Bool` parameters.
  134|       |    public let boolEncoding: BoolEncoding
  135|       |
  136|       |    // MARK: Initialization
  137|       |
  138|       |    /// Creates an instance using the specified parameters.
  139|       |    ///
  140|       |    /// - Parameters:
  141|       |    ///   - destination:   `Destination` defining where the encoded query string will be applied. `.methodDependent` by
  142|       |    ///                    default.
  143|       |    ///   - arrayEncoding: `ArrayEncoding` to use. `.brackets` by default.
  144|       |    ///   - boolEncoding:  `BoolEncoding` to use. `.numeric` by default.
  145|       |    public init(destination: Destination = .methodDependent,
  146|       |                arrayEncoding: ArrayEncoding = .brackets,
  147|      0|                boolEncoding: BoolEncoding = .numeric) {
  148|      0|        self.destination = destination
  149|      0|        self.arrayEncoding = arrayEncoding
  150|      0|        self.boolEncoding = boolEncoding
  151|      0|    }
  152|       |
  153|       |    // MARK: Encoding
  154|       |
  155|      0|    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
  156|      0|        var urlRequest = try urlRequest.asURLRequest()
  157|      0|
  158|      0|        guard let parameters = parameters else { return urlRequest }
  159|      0|
  160|      0|        if let method = urlRequest.method, destination.encodesParametersInURL(for: method) {
  161|      0|            guard let url = urlRequest.url else {
  162|      0|                throw AFError.parameterEncodingFailed(reason: .missingURL)
  163|      0|            }
  164|      0|
  165|      0|            if var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false), !parameters.isEmpty {
  166|      0|                let percentEncodedQuery = (urlComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
  167|      0|                urlComponents.percentEncodedQuery = percentEncodedQuery
  168|      0|                urlRequest.url = urlComponents.url
  169|      0|            }
  170|      0|        } else {
  171|      0|            if urlRequest.headers["Content-Type"] == nil {
  172|      0|                urlRequest.headers.update(.contentType("application/x-www-form-urlencoded; charset=utf-8"))
  173|      0|            }
  174|      0|
  175|      0|            urlRequest.httpBody = Data(query(parameters).utf8)
  176|      0|        }
  177|      0|
  178|      0|        return urlRequest
  179|      0|    }
  180|       |
  181|       |    /// Creates a percent-escaped, URL encoded query string components from the given key-value pair recursively.
  182|       |    ///
  183|       |    /// - Parameters:
  184|       |    ///   - key:   Key of the query component.
  185|       |    ///   - value: Value of the query component.
  186|       |    ///
  187|       |    /// - Returns: The percent-escaped, URL encoded query string components.
  188|      0|    public func queryComponents(fromKey key: String, value: Any) -> [(String, String)] {
  189|      0|        var components: [(String, String)] = []
  190|      0|        switch value {
  191|      0|        case let dictionary as [String: Any]:
  192|      0|            for (nestedKey, value) in dictionary {
  193|      0|                components += queryComponents(fromKey: "\(key)[\(nestedKey)]", value: value)
  194|      0|            }
  195|      0|        case let array as [Any]:
  196|      0|            for value in array {
  197|      0|                components += queryComponents(fromKey: arrayEncoding.encode(key: key), value: value)
  198|      0|            }
  199|      0|        case let number as NSNumber:
  200|      0|            if number.isBool {
  201|      0|                components.append((escape(key), escape(boolEncoding.encode(value: number.boolValue))))
  202|      0|            } else {
  203|      0|                components.append((escape(key), escape("\(number)")))
  204|      0|            }
  205|      0|        case let bool as Bool:
  206|      0|            components.append((escape(key), escape(boolEncoding.encode(value: bool))))
  207|      0|        default:
  208|      0|            components.append((escape(key), escape("\(value)")))
  209|      0|        }
  210|      0|        return components
  211|      0|    }
  212|       |
  213|       |    /// Creates a percent-escaped string following RFC 3986 for a query string key or value.
  214|       |    ///
  215|       |    /// - Parameter string: `String` to be percent-escaped.
  216|       |    ///
  217|       |    /// - Returns:          The percent-escaped `String`.
  218|      0|    public func escape(_ string: String) -> String {
  219|      0|        string.addingPercentEncoding(withAllowedCharacters: .afURLQueryAllowed) ?? string
  220|      0|    }
  221|       |
  222|      0|    private func query(_ parameters: [String: Any]) -> String {
  223|      0|        var components: [(String, String)] = []
  224|      0|
  225|      0|        for key in parameters.keys.sorted(by: <) {
  ------------------
  | Unexecuted instantiation: $s9Alamofire11URLEncodingV5query33_07E29AB6DA2856B846193FCC509DA12DLLySSSDySSypGFSbSS_SStcSSmcfu_
  ------------------
  | Unexecuted instantiation: $s9Alamofire11URLEncodingV5query33_07E29AB6DA2856B846193FCC509DA12DLLySSSDySSypGFSbSS_SStcSSmcfu_SbSS_SStcfu0_
  ------------------
  226|      0|            let value = parameters[key]!
  227|      0|            components += queryComponents(fromKey: key, value: value)
  228|      0|        }
  229|      0|        return components.map { "\($0)=\($1)" }.joined(separator: "&")
  230|      0|    }
  231|       |}
  232|       |
  233|       |// MARK: -
  234|       |
  235|       |/// Uses `JSONSerialization` to create a JSON representation of the parameters object, which is set as the body of the
  236|       |/// request. The `Content-Type` HTTP header field of an encoded request is set to `application/json`.
  237|       |public struct JSONEncoding: ParameterEncoding {
  238|       |    // MARK: Properties
  239|       |
  240|       |    /// Returns a `JSONEncoding` instance with default writing options.
  241|      0|    public static var `default`: JSONEncoding { JSONEncoding() }
  242|       |
  243|       |    /// Returns a `JSONEncoding` instance with `.prettyPrinted` writing options.
  244|      0|    public static var prettyPrinted: JSONEncoding { JSONEncoding(options: .prettyPrinted) }
  245|       |
  246|       |    /// The options for writing the parameters as JSON data.
  247|       |    public let options: JSONSerialization.WritingOptions
  248|       |
  249|       |    // MARK: Initialization
  250|       |
  251|       |    /// Creates an instance using the specified `WritingOptions`.
  252|       |    ///
  253|       |    /// - Parameter options: `JSONSerialization.WritingOptions` to use.
  254|      0|    public init(options: JSONSerialization.WritingOptions = []) {
  255|      0|        self.options = options
  256|      0|    }
  257|       |
  258|       |    // MARK: Encoding
  259|       |
  260|      0|    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
  261|      0|        var urlRequest = try urlRequest.asURLRequest()
  262|      0|
  263|      0|        guard let parameters = parameters else { return urlRequest }
  264|      0|
  265|      0|        do {
  266|      0|            let data = try JSONSerialization.data(withJSONObject: parameters, options: options)
  267|      0|
  268|      0|            if urlRequest.headers["Content-Type"] == nil {
  269|      0|                urlRequest.headers.update(.contentType("application/json"))
  270|      0|            }
  271|      0|
  272|      0|            urlRequest.httpBody = data
  273|      0|        } catch {
  274|      0|            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
  275|      0|        }
  276|      0|
  277|      0|        return urlRequest
  278|      0|    }
  279|       |
  280|       |    /// Encodes any JSON compatible object into a `URLRequest`.
  281|       |    ///
  282|       |    /// - Parameters:
  283|       |    ///   - urlRequest: `URLRequestConvertible` value into which the object will be encoded.
  284|       |    ///   - jsonObject: `Any` value (must be JSON compatible` to be encoded into the `URLRequest`. `nil` by default.
  285|       |    ///
  286|       |    /// - Returns:      The encoded `URLRequest`.
  287|       |    /// - Throws:       Any `Error` produced during encoding.
  288|      0|    public func encode(_ urlRequest: URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> URLRequest {
  289|      0|        var urlRequest = try urlRequest.asURLRequest()
  290|      0|
  291|      0|        guard let jsonObject = jsonObject else { return urlRequest }
  292|      0|
  293|      0|        do {
  294|      0|            let data = try JSONSerialization.data(withJSONObject: jsonObject, options: options)
  295|      0|
  296|      0|            if urlRequest.headers["Content-Type"] == nil {
  297|      0|                urlRequest.headers.update(.contentType("application/json"))
  298|      0|            }
  299|      0|
  300|      0|            urlRequest.httpBody = data
  301|      0|        } catch {
  302|      0|            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
  303|      0|        }
  304|      0|
  305|      0|        return urlRequest
  306|      0|    }
  307|       |}
  308|       |
  309|       |// MARK: -
  310|       |
  311|       |extension NSNumber {
  312|      0|    fileprivate var isBool: Bool {
  313|      0|        // Use Obj-C type encoding to check whether the underlying type is a `Bool`, as it's guaranteed as part of
  314|      0|        // swift-corelibs-foundation, per [this discussion on the Swift forums](https://forums.swift.org/t/alamofire-on-linux-possible-but-not-release-ready/34553/22).
  315|      0|        String(cString: objCType) == "c"
  316|      0|    }
  317|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Protected.swift:
    1|       |//
    2|       |//  Protected.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2020 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |private protocol Lock {
   28|       |    func lock()
   29|       |    func unlock()
   30|       |}
   31|       |
   32|       |extension Lock {
   33|       |    /// Executes a closure returning a value while acquiring the lock.
   34|       |    ///
   35|       |    /// - Parameter closure: The closure to run.
   36|       |    ///
   37|       |    /// - Returns:           The value the closure generated.
   38|      0|    func around<T>(_ closure: () -> T) -> T {
   39|      0|        lock(); defer { unlock() }
   40|      0|        return closure()
   41|      0|    }
   42|       |
   43|       |    /// Execute a closure while acquiring the lock.
   44|       |    ///
   45|       |    /// - Parameter closure: The closure to run.
   46|      0|    func around(_ closure: () -> Void) {
   47|      0|        lock(); defer { unlock() }
   48|      0|        closure()
   49|      0|    }
   50|       |}
   51|       |
   52|       |#if os(Linux)
   53|       |/// A `pthread_mutex_t` wrapper.
   54|       |final class MutexLock: Lock {
   55|       |    private var mutex: UnsafeMutablePointer<pthread_mutex_t>
   56|       |
   57|       |    init() {
   58|       |        mutex = .allocate(capacity: 1)
   59|       |
   60|       |        var attr = pthread_mutexattr_t()
   61|       |        pthread_mutexattr_init(&attr)
   62|       |        pthread_mutexattr_settype(&attr, .init(PTHREAD_MUTEX_ERRORCHECK))
   63|       |
   64|       |        let error = pthread_mutex_init(mutex, &attr)
   65|       |        precondition(error == 0, "Failed to create pthread_mutex")
   66|       |    }
   67|       |
   68|       |    deinit {
   69|       |        let error = pthread_mutex_destroy(mutex)
   70|       |        precondition(error == 0, "Failed to destroy pthread_mutex")
   71|       |    }
   72|       |
   73|       |    fileprivate func lock() {
   74|       |        let error = pthread_mutex_lock(mutex)
   75|       |        precondition(error == 0, "Failed to lock pthread_mutex")
   76|       |    }
   77|       |
   78|       |    fileprivate func unlock() {
   79|       |        let error = pthread_mutex_unlock(mutex)
   80|       |        precondition(error == 0, "Failed to unlock pthread_mutex")
   81|       |    }
   82|       |}
   83|       |#endif
   84|       |
   85|       |#if os(macOS) || os(iOS) || os(watchOS) || os(tvOS)
   86|       |/// An `os_unfair_lock` wrapper.
   87|       |final class UnfairLock: Lock {
   88|       |    private let unfairLock: os_unfair_lock_t
   89|       |
   90|      0|    init() {
   91|      0|        unfairLock = .allocate(capacity: 1)
   92|      0|        unfairLock.initialize(to: os_unfair_lock())
   93|      0|    }
   94|       |
   95|      0|    deinit {
   96|      0|        unfairLock.deinitialize(count: 1)
   97|      0|        unfairLock.deallocate()
   98|      0|    }
   99|       |
  100|      0|    fileprivate func lock() {
  101|      0|        os_unfair_lock_lock(unfairLock)
  102|      0|    }
  103|       |
  104|      0|    fileprivate func unlock() {
  105|      0|        os_unfair_lock_unlock(unfairLock)
  106|      0|    }
  107|       |}
  108|       |#endif
  109|       |
  110|       |/// A thread-safe wrapper around a value.
  111|       |@propertyWrapper
  112|       |@dynamicMemberLookup
  113|       |final class Protected<T> {
  114|       |    #if os(macOS) || os(iOS) || os(watchOS) || os(tvOS)
  115|      0|    private let lock = UnfairLock()
  116|       |    #elseif os(Linux)
  117|       |    private let lock = MutexLock()
  118|       |    #endif
  119|       |    private var value: T
  120|       |
  121|      0|    init(_ value: T) {
  122|      0|        self.value = value
  123|      0|    }
  124|       |
  125|       |    /// The contained value. Unsafe for anything more than direct read or write.
  126|       |    var wrappedValue: T {
  127|      0|        get { lock.around { value } }
  128|      0|        set { lock.around { value = newValue } }
  129|       |    }
  130|       |
  131|      0|    var projectedValue: Protected<T> { self }
  132|       |
  133|      0|    init(wrappedValue: T) {
  134|      0|        value = wrappedValue
  135|      0|    }
  136|       |
  137|       |    /// Synchronously read or transform the contained value.
  138|       |    ///
  139|       |    /// - Parameter closure: The closure to execute.
  140|       |    ///
  141|       |    /// - Returns:           The return value of the closure passed.
  142|      0|    func read<U>(_ closure: (T) -> U) -> U {
  143|      0|        lock.around { closure(self.value) }
  144|      0|    }
  145|       |
  146|       |    /// Synchronously modify the protected value.
  147|       |    ///
  148|       |    /// - Parameter closure: The closure to execute.
  149|       |    ///
  150|       |    /// - Returns:           The modified value.
  151|       |    @discardableResult
  152|      0|    func write<U>(_ closure: (inout T) -> U) -> U {
  153|      0|        lock.around { closure(&self.value) }
  154|      0|    }
  155|       |
  156|       |    subscript<Property>(dynamicMember keyPath: WritableKeyPath<T, Property>) -> Property {
  157|      0|        get { lock.around { value[keyPath: keyPath] } }
  158|      0|        set { lock.around { value[keyPath: keyPath] = newValue } }
  159|       |    }
  160|       |}
  161|       |
  162|       |extension Protected where T: RangeReplaceableCollection {
  163|       |    /// Adds a new element to the end of this protected collection.
  164|       |    ///
  165|       |    /// - Parameter newElement: The `Element` to append.
  166|      0|    func append(_ newElement: T.Element) {
  167|      0|        write { (ward: inout T) in
  168|      0|            ward.append(newElement)
  169|      0|        }
  170|      0|    }
  171|       |
  172|       |    /// Adds the elements of a sequence to the end of this protected collection.
  173|       |    ///
  174|       |    /// - Parameter newElements: The `Sequence` to append.
  175|      0|    func append<S: Sequence>(contentsOf newElements: S) where S.Element == T.Element {
  176|      0|        write { (ward: inout T) in
  177|      0|            ward.append(contentsOf: newElements)
  178|      0|        }
  179|      0|    }
  180|       |
  181|       |    /// Add the elements of a collection to the end of the protected collection.
  182|       |    ///
  183|       |    /// - Parameter newElements: The `Collection` to append.
  184|      0|    func append<C: Collection>(contentsOf newElements: C) where C.Element == T.Element {
  185|      0|        write { (ward: inout T) in
  186|      0|            ward.append(contentsOf: newElements)
  187|      0|        }
  188|      0|    }
  189|       |}
  190|       |
  191|       |extension Protected where T == Data? {
  192|       |    /// Adds the contents of a `Data` value to the end of the protected `Data`.
  193|       |    ///
  194|       |    /// - Parameter data: The `Data` to be appended.
  195|      0|    func append(_ data: Data) {
  196|      0|        write { (ward: inout T) in
  197|      0|            ward?.append(data)
  198|      0|        }
  199|      0|    }
  200|       |}
  201|       |
  202|       |extension Protected where T == Request.MutableState {
  203|       |    /// Attempts to transition to the passed `State`.
  204|       |    ///
  205|       |    /// - Parameter state: The `State` to attempt transition to.
  206|       |    ///
  207|       |    /// - Returns:         Whether the transition occurred.
  208|      0|    func attemptToTransitionTo(_ state: Request.State) -> Bool {
  209|      0|        lock.around {
  210|      0|            guard value.state.canTransitionTo(state) else { return false }
  211|      0|
  212|      0|            value.state = state
  213|      0|
  214|      0|            return true
  215|      0|        }
  216|      0|    }
  217|       |
  218|       |    /// Perform a closure while locked with the provided `Request.State`.
  219|       |    ///
  220|       |    /// - Parameter perform: The closure to perform while locked.
  221|      0|    func withState(perform: (Request.State) -> Void) {
  222|      0|        lock.around { perform(value.state) }
  223|      0|    }
  224|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/RedirectHandler.swift:
    1|       |//
    2|       |//  RedirectHandler.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A type that handles how an HTTP redirect response from a remote server should be redirected to the new request.
   28|       |public protocol RedirectHandler {
   29|       |    /// Determines how the HTTP redirect response should be redirected to the new request.
   30|       |    ///
   31|       |    /// The `completion` closure should be passed one of three possible options:
   32|       |    ///
   33|       |    ///   1. The new request specified by the redirect (this is the most common use case).
   34|       |    ///   2. A modified version of the new request (you may want to route it somewhere else).
   35|       |    ///   3. A `nil` value to deny the redirect request and return the body of the redirect response.
   36|       |    ///
   37|       |    /// - Parameters:
   38|       |    ///   - task:       The `URLSessionTask` whose request resulted in a redirect.
   39|       |    ///   - request:    The `URLRequest` to the new location specified by the redirect response.
   40|       |    ///   - response:   The `HTTPURLResponse` containing the server's response to the original request.
   41|       |    ///   - completion: The closure to execute containing the new `URLRequest`, a modified `URLRequest`, or `nil`.
   42|       |    func task(_ task: URLSessionTask,
   43|       |              willBeRedirectedTo request: URLRequest,
   44|       |              for response: HTTPURLResponse,
   45|       |              completion: @escaping (URLRequest?) -> Void)
   46|       |}
   47|       |
   48|       |// MARK: -
   49|       |
   50|       |/// `Redirector` is a convenience `RedirectHandler` making it easy to follow, not follow, or modify a redirect.
   51|       |public struct Redirector {
   52|       |    /// Defines the behavior of the `Redirector` type.
   53|       |    public enum Behavior {
   54|       |        /// Follow the redirect as defined in the response.
   55|       |        case follow
   56|       |        /// Do not follow the redirect defined in the response.
   57|       |        case doNotFollow
   58|       |        /// Modify the redirect request defined in the response.
   59|       |        case modify((URLSessionTask, URLRequest, HTTPURLResponse) -> URLRequest?)
   60|       |    }
   61|       |
   62|       |    /// Returns a `Redirector` with a `.follow` `Behavior`.
   63|       |    public static let follow = Redirector(behavior: .follow)
   64|       |    /// Returns a `Redirector` with a `.doNotFollow` `Behavior`.
   65|       |    public static let doNotFollow = Redirector(behavior: .doNotFollow)
   66|       |
   67|       |    /// The `Behavior` of the `Redirector`.
   68|       |    public let behavior: Behavior
   69|       |
   70|       |    /// Creates a `Redirector` instance from the `Behavior`.
   71|       |    ///
   72|       |    /// - Parameter behavior: The `Behavior`.
   73|      0|    public init(behavior: Behavior) {
   74|      0|        self.behavior = behavior
   75|      0|    }
   76|       |}
   77|       |
   78|       |// MARK: -
   79|       |
   80|       |extension Redirector: RedirectHandler {
   81|       |    public func task(_ task: URLSessionTask,
   82|       |                     willBeRedirectedTo request: URLRequest,
   83|       |                     for response: HTTPURLResponse,
   84|      0|                     completion: @escaping (URLRequest?) -> Void) {
   85|      0|        switch behavior {
   86|      0|        case .follow:
   87|      0|            completion(request)
   88|      0|        case .doNotFollow:
   89|      0|            completion(nil)
   90|      0|        case let .modify(closure):
   91|      0|            let request = closure(task, request, response)
   92|      0|            completion(request)
   93|      0|        }
   94|      0|    }
   95|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Request.swift:
    1|       |//
    2|       |//  Request.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2020 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// `Request` is the common superclass of all Alamofire request types and provides common state, delegate, and callback
   28|       |/// handling.
   29|       |public class Request {
   30|       |    /// State of the `Request`, with managed transitions between states set when calling `resume()`, `suspend()`, or
   31|       |    /// `cancel()` on the `Request`.
   32|       |    public enum State {
   33|       |        /// Initial state of the `Request`.
   34|       |        case initialized
   35|       |        /// `State` set when `resume()` is called. Any tasks created for the `Request` will have `resume()` called on
   36|       |        /// them in this state.
   37|       |        case resumed
   38|       |        /// `State` set when `suspend()` is called. Any tasks created for the `Request` will have `suspend()` called on
   39|       |        /// them in this state.
   40|       |        case suspended
   41|       |        /// `State` set when `cancel()` is called. Any tasks created for the `Request` will have `cancel()` called on
   42|       |        /// them. Unlike `resumed` or `suspended`, once in the `cancelled` state, the `Request` can no longer transition
   43|       |        /// to any other state.
   44|       |        case cancelled
   45|       |        /// `State` set when all response serialization completion closures have been cleared on the `Request` and
   46|       |        /// enqueued on their respective queues.
   47|       |        case finished
   48|       |
   49|       |        /// Determines whether `self` can be transitioned to the provided `State`.
   50|      0|        func canTransitionTo(_ state: State) -> Bool {
   51|      0|            switch (self, state) {
   52|      0|            case (.initialized, _):
   53|      0|                return true
   54|      0|            case (_, .initialized), (.cancelled, _), (.finished, _):
   55|      0|                return false
   56|      0|            case (.resumed, .cancelled), (.suspended, .cancelled), (.resumed, .suspended), (.suspended, .resumed):
   57|      0|                return true
   58|      0|            case (.suspended, .suspended), (.resumed, .resumed):
   59|      0|                return false
   60|      0|            case (_, .finished):
   61|      0|                return true
   62|      0|            }
   63|      0|        }
   64|       |    }
   65|       |
   66|       |    // MARK: - Initial State
   67|       |
   68|       |    /// `UUID` providing a unique identifier for the `Request`, used in the `Hashable` and `Equatable` conformances.
   69|       |    public let id: UUID
   70|       |    /// The serial queue for all internal async actions.
   71|       |    public let underlyingQueue: DispatchQueue
   72|       |    /// The queue used for all serialization actions. By default it's a serial queue that targets `underlyingQueue`.
   73|       |    public let serializationQueue: DispatchQueue
   74|       |    /// `EventMonitor` used for event callbacks.
   75|       |    public let eventMonitor: EventMonitor?
   76|       |    /// The `Request`'s interceptor.
   77|       |    public let interceptor: RequestInterceptor?
   78|       |    /// The `Request`'s delegate.
   79|       |    public private(set) weak var delegate: RequestDelegate?
   80|       |
   81|       |    // MARK: - Mutable State
   82|       |
   83|       |    /// Type encapsulating all mutable state that may need to be accessed from anything other than the `underlyingQueue`.
   84|       |    struct MutableState {
   85|       |        /// State of the `Request`.
   86|      0|        var state: State = .initialized
   87|       |        /// `ProgressHandler` and `DispatchQueue` provided for upload progress callbacks.
   88|       |        var uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?
   89|       |        /// `ProgressHandler` and `DispatchQueue` provided for download progress callbacks.
   90|       |        var downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?
   91|       |        /// `RedirectHandler` provided for to handle request redirection.
   92|       |        var redirectHandler: RedirectHandler?
   93|       |        /// `CachedResponseHandler` provided to handle response caching.
   94|       |        var cachedResponseHandler: CachedResponseHandler?
   95|       |        /// Queue and closure called when the `Request` is able to create a cURL description of itself.
   96|       |        var cURLHandler: (queue: DispatchQueue, handler: (String) -> Void)?
   97|       |        /// Queue and closure called when the `Request` creates a `URLRequest`.
   98|       |        var urlRequestHandler: (queue: DispatchQueue, handler: (URLRequest) -> Void)?
   99|       |        /// Queue and closure called when the `Request` creates a `URLSessionTask`.
  100|       |        var urlSessionTaskHandler: (queue: DispatchQueue, handler: (URLSessionTask) -> Void)?
  101|       |        /// Response serialization closures that handle response parsing.
  102|      0|        var responseSerializers: [() -> Void] = []
  103|       |        /// Response serialization completion closures executed once all response serializers are complete.
  104|      0|        var responseSerializerCompletions: [() -> Void] = []
  105|       |        /// Whether response serializer processing is finished.
  106|       |        var responseSerializerProcessingFinished = false
  107|       |        /// `URLCredential` used for authentication challenges.
  108|       |        var credential: URLCredential?
  109|       |        /// All `URLRequest`s created by Alamofire on behalf of the `Request`.
  110|      0|        var requests: [URLRequest] = []
  111|       |        /// All `URLSessionTask`s created by Alamofire on behalf of the `Request`.
  112|      0|        var tasks: [URLSessionTask] = []
  113|       |        /// All `URLSessionTaskMetrics` values gathered by Alamofire on behalf of the `Request`. Should correspond
  114|       |        /// exactly the the `tasks` created.
  115|      0|        var metrics: [URLSessionTaskMetrics] = []
  116|       |        /// Number of times any retriers provided retried the `Request`.
  117|       |        var retryCount = 0
  118|       |        /// Final `AFError` for the `Request`, whether from various internal Alamofire calls or as a result of a `task`.
  119|       |        var error: AFError?
  120|       |        /// Whether the instance has had `finish()` called and is running the serializers. Should be replaced with a
  121|       |        /// representation in the state machine in the future.
  122|       |        var isFinishing = false
  123|       |    }
  124|       |
  125|       |    /// Protected `MutableState` value that provides thread-safe access to state values.
  126|       |    @Protected
  127|      0|    fileprivate var mutableState = MutableState()
  128|       |
  129|       |    /// `State` of the `Request`.
  130|      0|    public var state: State { mutableState.state }
  131|       |    /// Returns whether `state` is `.initialized`.
  132|      0|    public var isInitialized: Bool { state == .initialized }
  133|       |    /// Returns whether `state is `.resumed`.
  134|      0|    public var isResumed: Bool { state == .resumed }
  135|       |    /// Returns whether `state` is `.suspended`.
  136|      0|    public var isSuspended: Bool { state == .suspended }
  137|       |    /// Returns whether `state` is `.cancelled`.
  138|      0|    public var isCancelled: Bool { state == .cancelled }
  139|       |    /// Returns whether `state` is `.finished`.
  140|      0|    public var isFinished: Bool { state == .finished }
  141|       |
  142|       |    // MARK: Progress
  143|       |
  144|       |    /// Closure type executed when monitoring the upload or download progress of a request.
  145|       |    public typealias ProgressHandler = (Progress) -> Void
  146|       |
  147|       |    /// `Progress` of the upload of the body of the executed `URLRequest`. Reset to `0` if the `Request` is retried.
  148|      0|    public let uploadProgress = Progress(totalUnitCount: 0)
  149|       |    /// `Progress` of the download of any response data. Reset to `0` if the `Request` is retried.
  150|      0|    public let downloadProgress = Progress(totalUnitCount: 0)
  151|       |    /// `ProgressHandler` called when `uploadProgress` is updated, on the provided `DispatchQueue`.
  152|       |    fileprivate var uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)? {
  153|      0|        get { mutableState.uploadProgressHandler }
  154|      0|        set { mutableState.uploadProgressHandler = newValue }
  155|       |    }
  156|       |
  157|       |    /// `ProgressHandler` called when `downloadProgress` is updated, on the provided `DispatchQueue`.
  158|       |    fileprivate var downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)? {
  159|      0|        get { mutableState.downloadProgressHandler }
  160|      0|        set { mutableState.downloadProgressHandler = newValue }
  161|       |    }
  162|       |
  163|       |    // MARK: Redirect Handling
  164|       |
  165|       |    /// `RedirectHandler` set on the instance.
  166|       |    public private(set) var redirectHandler: RedirectHandler? {
  167|      0|        get { mutableState.redirectHandler }
  168|      0|        set { mutableState.redirectHandler = newValue }
  169|       |    }
  170|       |
  171|       |    // MARK: Cached Response Handling
  172|       |
  173|       |    /// `CachedResponseHandler` set on the instance.
  174|       |    public private(set) var cachedResponseHandler: CachedResponseHandler? {
  175|      0|        get { mutableState.cachedResponseHandler }
  176|      0|        set { mutableState.cachedResponseHandler = newValue }
  177|       |    }
  178|       |
  179|       |    // MARK: URLCredential
  180|       |
  181|       |    /// `URLCredential` used for authentication challenges. Created by calling one of the `authenticate` methods.
  182|       |    public private(set) var credential: URLCredential? {
  183|      0|        get { mutableState.credential }
  184|      0|        set { mutableState.credential = newValue }
  185|       |    }
  186|       |
  187|       |    // MARK: Validators
  188|       |
  189|       |    /// `Validator` callback closures that store the validation calls enqueued.
  190|       |    @Protected
  191|      0|    fileprivate var validators: [() -> Void] = []
  192|       |
  193|       |    // MARK: URLRequests
  194|       |
  195|       |    /// All `URLRequests` created on behalf of the `Request`, including original and adapted requests.
  196|      0|    public var requests: [URLRequest] { mutableState.requests }
  197|       |    /// First `URLRequest` created on behalf of the `Request`. May not be the first one actually executed.
  198|      0|    public var firstRequest: URLRequest? { requests.first }
  199|       |    /// Last `URLRequest` created on behalf of the `Request`.
  200|      0|    public var lastRequest: URLRequest? { requests.last }
  201|       |    /// Current `URLRequest` created on behalf of the `Request`.
  202|      0|    public var request: URLRequest? { lastRequest }
  203|       |
  204|       |    /// `URLRequest`s from all of the `URLSessionTask`s executed on behalf of the `Request`. May be different from
  205|       |    /// `requests` due to `URLSession` manipulation.
  206|      0|    public var performedRequests: [URLRequest] { $mutableState.read { $0.tasks.compactMap { $0.currentRequest } } }
  207|       |
  208|       |    // MARK: HTTPURLResponse
  209|       |
  210|       |    /// `HTTPURLResponse` received from the server, if any. If the `Request` was retried, this is the response of the
  211|       |    /// last `URLSessionTask`.
  212|      0|    public var response: HTTPURLResponse? { lastTask?.response as? HTTPURLResponse }
  213|       |
  214|       |    // MARK: Tasks
  215|       |
  216|       |    /// All `URLSessionTask`s created on behalf of the `Request`.
  217|      0|    public var tasks: [URLSessionTask] { mutableState.tasks }
  218|       |    /// First `URLSessionTask` created on behalf of the `Request`.
  219|      0|    public var firstTask: URLSessionTask? { tasks.first }
  220|       |    /// Last `URLSessionTask` crated on behalf of the `Request`.
  221|      0|    public var lastTask: URLSessionTask? { tasks.last }
  222|       |    /// Current `URLSessionTask` created on behalf of the `Request`.
  223|      0|    public var task: URLSessionTask? { lastTask }
  224|       |
  225|       |    // MARK: Metrics
  226|       |
  227|       |    /// All `URLSessionTaskMetrics` gathered on behalf of the `Request`. Should correspond to the `tasks` created.
  228|      0|    public var allMetrics: [URLSessionTaskMetrics] { mutableState.metrics }
  229|       |    /// First `URLSessionTaskMetrics` gathered on behalf of the `Request`.
  230|      0|    public var firstMetrics: URLSessionTaskMetrics? { allMetrics.first }
  231|       |    /// Last `URLSessionTaskMetrics` gathered on behalf of the `Request`.
  232|      0|    public var lastMetrics: URLSessionTaskMetrics? { allMetrics.last }
  233|       |    /// Current `URLSessionTaskMetrics` gathered on behalf of the `Request`.
  234|      0|    public var metrics: URLSessionTaskMetrics? { lastMetrics }
  235|       |
  236|       |    // MARK: Retry Count
  237|       |
  238|       |    /// Number of times the `Request` has been retried.
  239|      0|    public var retryCount: Int { mutableState.retryCount }
  240|       |
  241|       |    // MARK: Error
  242|       |
  243|       |    /// `Error` returned from Alamofire internally, from the network request directly, or any validators executed.
  244|       |    public fileprivate(set) var error: AFError? {
  245|      0|        get { mutableState.error }
  246|      0|        set { mutableState.error = newValue }
  247|       |    }
  248|       |
  249|       |    /// Default initializer for the `Request` superclass.
  250|       |    ///
  251|       |    /// - Parameters:
  252|       |    ///   - id:                 `UUID` used for the `Hashable` and `Equatable` implementations. `UUID()` by default.
  253|       |    ///   - underlyingQueue:    `DispatchQueue` on which all internal `Request` work is performed.
  254|       |    ///   - serializationQueue: `DispatchQueue` on which all serialization work is performed. By default targets
  255|       |    ///                         `underlyingQueue`, but can be passed another queue from a `Session`.
  256|       |    ///   - eventMonitor:       `EventMonitor` called for event callbacks from internal `Request` actions.
  257|       |    ///   - interceptor:        `RequestInterceptor` used throughout the request lifecycle.
  258|       |    ///   - delegate:           `RequestDelegate` that provides an interface to actions not performed by the `Request`.
  259|       |    init(id: UUID = UUID(),
  260|       |         underlyingQueue: DispatchQueue,
  261|       |         serializationQueue: DispatchQueue,
  262|       |         eventMonitor: EventMonitor?,
  263|       |         interceptor: RequestInterceptor?,
  264|      0|         delegate: RequestDelegate) {
  265|      0|        self.id = id
  266|      0|        self.underlyingQueue = underlyingQueue
  267|      0|        self.serializationQueue = serializationQueue
  268|      0|        self.eventMonitor = eventMonitor
  269|      0|        self.interceptor = interceptor
  270|      0|        self.delegate = delegate
  271|      0|    }
  272|       |
  273|       |    // MARK: - Internal Event API
  274|       |
  275|       |    // All API must be called from underlyingQueue.
  276|       |
  277|       |    /// Called when an initial `URLRequest` has been created on behalf of the instance. If a `RequestAdapter` is active,
  278|       |    /// the `URLRequest` will be adapted before being issued.
  279|       |    ///
  280|       |    /// - Parameter request: The `URLRequest` created.
  281|      0|    func didCreateInitialURLRequest(_ request: URLRequest) {
  282|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  283|      0|
  284|      0|        $mutableState.write { $0.requests.append(request) }
  285|      0|
  286|      0|        eventMonitor?.request(self, didCreateInitialURLRequest: request)
  287|      0|    }
  288|       |
  289|       |    /// Called when initial `URLRequest` creation has failed, typically through a `URLRequestConvertible`.
  290|       |    ///
  291|       |    /// - Note: Triggers retry.
  292|       |    ///
  293|       |    /// - Parameter error: `AFError` thrown from the failed creation.
  294|      0|    func didFailToCreateURLRequest(with error: AFError) {
  295|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  296|      0|
  297|      0|        self.error = error
  298|      0|
  299|      0|        eventMonitor?.request(self, didFailToCreateURLRequestWithError: error)
  300|      0|
  301|      0|        callCURLHandlerIfNecessary()
  302|      0|
  303|      0|        retryOrFinish(error: error)
  304|      0|    }
  305|       |
  306|       |    /// Called when a `RequestAdapter` has successfully adapted a `URLRequest`.
  307|       |    ///
  308|       |    /// - Parameters:
  309|       |    ///   - initialRequest: The `URLRequest` that was adapted.
  310|       |    ///   - adaptedRequest: The `URLRequest` returned by the `RequestAdapter`.
  311|      0|    func didAdaptInitialRequest(_ initialRequest: URLRequest, to adaptedRequest: URLRequest) {
  312|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  313|      0|
  314|      0|        $mutableState.write { $0.requests.append(adaptedRequest) }
  315|      0|
  316|      0|        eventMonitor?.request(self, didAdaptInitialRequest: initialRequest, to: adaptedRequest)
  317|      0|    }
  318|       |
  319|       |    /// Called when a `RequestAdapter` fails to adapt a `URLRequest`.
  320|       |    ///
  321|       |    /// - Note: Triggers retry.
  322|       |    ///
  323|       |    /// - Parameters:
  324|       |    ///   - request: The `URLRequest` the adapter was called with.
  325|       |    ///   - error:   The `AFError` returned by the `RequestAdapter`.
  326|      0|    func didFailToAdaptURLRequest(_ request: URLRequest, withError error: AFError) {
  327|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  328|      0|
  329|      0|        self.error = error
  330|      0|
  331|      0|        eventMonitor?.request(self, didFailToAdaptURLRequest: request, withError: error)
  332|      0|
  333|      0|        callCURLHandlerIfNecessary()
  334|      0|
  335|      0|        retryOrFinish(error: error)
  336|      0|    }
  337|       |
  338|       |    /// Final `URLRequest` has been created for the instance.
  339|       |    ///
  340|       |    /// - Parameter request: The `URLRequest` created.
  341|      0|    func didCreateURLRequest(_ request: URLRequest) {
  342|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  343|      0|
  344|      0|        $mutableState.read { state in
  345|      0|            state.urlRequestHandler?.queue.async { state.urlRequestHandler?.handler(request) }
  346|      0|        }
  347|      0|
  348|      0|        eventMonitor?.request(self, didCreateURLRequest: request)
  349|      0|
  350|      0|        callCURLHandlerIfNecessary()
  351|      0|    }
  352|       |
  353|       |    /// Asynchronously calls any stored `cURLHandler` and then removes it from `mutableState`.
  354|      0|    private func callCURLHandlerIfNecessary() {
  355|      0|        $mutableState.write { mutableState in
  356|      0|            guard let cURLHandler = mutableState.cURLHandler else { return }
  357|      0|
  358|      0|            cURLHandler.queue.async { cURLHandler.handler(self.cURLDescription()) }
  359|      0|
  360|      0|            mutableState.cURLHandler = nil
  361|      0|        }
  362|      0|    }
  363|       |
  364|       |    /// Called when a `URLSessionTask` is created on behalf of the instance.
  365|       |    ///
  366|       |    /// - Parameter task: The `URLSessionTask` created.
  367|      0|    func didCreateTask(_ task: URLSessionTask) {
  368|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  369|      0|
  370|      0|        $mutableState.write { state in
  371|      0|            state.tasks.append(task)
  372|      0|
  373|      0|            guard let urlSessionTaskHandler = state.urlSessionTaskHandler else { return }
  374|      0|
  375|      0|            urlSessionTaskHandler.queue.async { urlSessionTaskHandler.handler(task) }
  376|      0|        }
  377|      0|
  378|      0|        eventMonitor?.request(self, didCreateTask: task)
  379|      0|    }
  380|       |
  381|       |    /// Called when resumption is completed.
  382|      0|    func didResume() {
  383|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  384|      0|
  385|      0|        eventMonitor?.requestDidResume(self)
  386|      0|    }
  387|       |
  388|       |    /// Called when a `URLSessionTask` is resumed on behalf of the instance.
  389|       |    ///
  390|       |    /// - Parameter task: The `URLSessionTask` resumed.
  391|      0|    func didResumeTask(_ task: URLSessionTask) {
  392|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  393|      0|
  394|      0|        eventMonitor?.request(self, didResumeTask: task)
  395|      0|    }
  396|       |
  397|       |    /// Called when suspension is completed.
  398|      0|    func didSuspend() {
  399|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  400|      0|
  401|      0|        eventMonitor?.requestDidSuspend(self)
  402|      0|    }
  403|       |
  404|       |    /// Called when a `URLSessionTask` is suspended on behalf of the instance.
  405|       |    ///
  406|       |    /// - Parameter task: The `URLSessionTask` suspended.
  407|      0|    func didSuspendTask(_ task: URLSessionTask) {
  408|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  409|      0|
  410|      0|        eventMonitor?.request(self, didSuspendTask: task)
  411|      0|    }
  412|       |
  413|       |    /// Called when cancellation is completed, sets `error` to `AFError.explicitlyCancelled`.
  414|      0|    func didCancel() {
  415|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  416|      0|
  417|      0|        error = error ?? AFError.explicitlyCancelled
  418|      0|
  419|      0|        eventMonitor?.requestDidCancel(self)
  420|      0|    }
  421|       |
  422|       |    /// Called when a `URLSessionTask` is cancelled on behalf of the instance.
  423|       |    ///
  424|       |    /// - Parameter task: The `URLSessionTask` cancelled.
  425|      0|    func didCancelTask(_ task: URLSessionTask) {
  426|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  427|      0|
  428|      0|        eventMonitor?.request(self, didCancelTask: task)
  429|      0|    }
  430|       |
  431|       |    /// Called when a `URLSessionTaskMetrics` value is gathered on behalf of the instance.
  432|       |    ///
  433|       |    /// - Parameter metrics: The `URLSessionTaskMetrics` gathered.
  434|      0|    func didGatherMetrics(_ metrics: URLSessionTaskMetrics) {
  435|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  436|      0|
  437|      0|        $mutableState.write { $0.metrics.append(metrics) }
  438|      0|
  439|      0|        eventMonitor?.request(self, didGatherMetrics: metrics)
  440|      0|    }
  441|       |
  442|       |    /// Called when a `URLSessionTask` fails before it is finished, typically during certificate pinning.
  443|       |    ///
  444|       |    /// - Parameters:
  445|       |    ///   - task:  The `URLSessionTask` which failed.
  446|       |    ///   - error: The early failure `AFError`.
  447|      0|    func didFailTask(_ task: URLSessionTask, earlyWithError error: AFError) {
  448|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  449|      0|
  450|      0|        self.error = error
  451|      0|
  452|      0|        // Task will still complete, so didCompleteTask(_:with:) will handle retry.
  453|      0|        eventMonitor?.request(self, didFailTask: task, earlyWithError: error)
  454|      0|    }
  455|       |
  456|       |    /// Called when a `URLSessionTask` completes. All tasks will eventually call this method.
  457|       |    ///
  458|       |    /// - Note: Response validation is synchronously triggered in this step.
  459|       |    ///
  460|       |    /// - Parameters:
  461|       |    ///   - task:  The `URLSessionTask` which completed.
  462|       |    ///   - error: The `AFError` `task` may have completed with. If `error` has already been set on the instance, this
  463|       |    ///            value is ignored.
  464|      0|    func didCompleteTask(_ task: URLSessionTask, with error: AFError?) {
  465|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  466|      0|
  467|      0|        self.error = self.error ?? error
  468|      0|
  469|      0|        validators.forEach { $0() }
  470|      0|
  471|      0|        eventMonitor?.request(self, didCompleteTask: task, with: error)
  472|      0|
  473|      0|        retryOrFinish(error: self.error)
  474|      0|    }
  475|       |
  476|       |    /// Called when the `RequestDelegate` is going to retry this `Request`. Calls `reset()`.
  477|      0|    func prepareForRetry() {
  478|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  479|      0|
  480|      0|        $mutableState.write { $0.retryCount += 1 }
  481|      0|
  482|      0|        reset()
  483|      0|
  484|      0|        eventMonitor?.requestIsRetrying(self)
  485|      0|    }
  486|       |
  487|       |    /// Called to determine whether retry will be triggered for the particular error, or whether the instance should
  488|       |    /// call `finish()`.
  489|       |    ///
  490|       |    /// - Parameter error: The possible `AFError` which may trigger retry.
  491|      0|    func retryOrFinish(error: AFError?) {
  492|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  493|      0|
  494|      0|        guard let error = error, let delegate = delegate else { finish(); return }
  495|      0|
  496|      0|        delegate.retryResult(for: self, dueTo: error) { retryResult in
  497|      0|            switch retryResult {
  498|      0|            case .doNotRetry:
  499|      0|                self.finish()
  500|      0|            case let .doNotRetryWithError(retryError):
  501|      0|                self.finish(error: retryError.asAFError(orFailWith: "Received retryError was not already AFError"))
  502|      0|            case .retry, .retryWithDelay:
  503|      0|                delegate.retryRequest(self, withDelay: retryResult.delay)
  504|      0|            }
  505|      0|        }
  506|      0|    }
  507|       |
  508|       |    /// Finishes this `Request` and starts the response serializers.
  509|       |    ///
  510|       |    /// - Parameter error: The possible `Error` with which the instance will finish.
  511|      0|    func finish(error: AFError? = nil) {
  512|      0|        dispatchPrecondition(condition: .onQueue(underlyingQueue))
  513|      0|
  514|      0|        guard !mutableState.isFinishing else { return }
  515|      0|
  516|      0|        mutableState.isFinishing = true
  517|      0|
  518|      0|        if let error = error { self.error = error }
  519|      0|
  520|      0|        // Start response handlers
  521|      0|        processNextResponseSerializer()
  522|      0|
  523|      0|        eventMonitor?.requestDidFinish(self)
  524|      0|    }
  525|       |
  526|       |    /// Appends the response serialization closure to the instance.
  527|       |    ///
  528|       |    ///  - Note: This method will also `resume` the instance if `delegate.startImmediately` returns `true`.
  529|       |    ///
  530|       |    /// - Parameter closure: The closure containing the response serialization call.
  531|      0|    func appendResponseSerializer(_ closure: @escaping () -> Void) {
  532|      0|        $mutableState.write { mutableState in
  533|      0|            mutableState.responseSerializers.append(closure)
  534|      0|
  535|      0|            if mutableState.state == .finished {
  536|      0|                mutableState.state = .resumed
  537|      0|            }
  538|      0|
  539|      0|            if mutableState.responseSerializerProcessingFinished {
  540|      0|                underlyingQueue.async { self.processNextResponseSerializer() }
  541|      0|            }
  542|      0|
  543|      0|            if mutableState.state.canTransitionTo(.resumed) {
  544|      0|                underlyingQueue.async { if self.delegate?.startImmediately == true { self.resume() } }
  545|      0|            }
  546|      0|        }
  547|      0|    }
  548|       |
  549|       |    /// Returns the next response serializer closure to execute if there's one left.
  550|       |    ///
  551|       |    /// - Returns: The next response serialization closure, if there is one.
  552|      0|    func nextResponseSerializer() -> (() -> Void)? {
  553|      0|        var responseSerializer: (() -> Void)?
  554|      0|
  555|      0|        $mutableState.write { mutableState in
  556|      0|            let responseSerializerIndex = mutableState.responseSerializerCompletions.count
  557|      0|
  558|      0|            if responseSerializerIndex < mutableState.responseSerializers.count {
  559|      0|                responseSerializer = mutableState.responseSerializers[responseSerializerIndex]
  560|      0|            }
  561|      0|        }
  562|      0|
  563|      0|        return responseSerializer
  564|      0|    }
  565|       |
  566|       |    /// Processes the next response serializer and calls all completions if response serialization is complete.
  567|      0|    func processNextResponseSerializer() {
  568|      0|        guard let responseSerializer = nextResponseSerializer() else {
  569|      0|            // Execute all response serializer completions and clear them
  570|      0|            var completions: [() -> Void] = []
  571|      0|
  572|      0|            $mutableState.write { mutableState in
  573|      0|                completions = mutableState.responseSerializerCompletions
  574|      0|
  575|      0|                // Clear out all response serializers and response serializer completions in mutable state since the
  576|      0|                // request is complete. It's important to do this prior to calling the completion closures in case
  577|      0|                // the completions call back into the request triggering a re-processing of the response serializers.
  578|      0|                // An example of how this can happen is by calling cancel inside a response completion closure.
  579|      0|                mutableState.responseSerializers.removeAll()
  580|      0|                mutableState.responseSerializerCompletions.removeAll()
  581|      0|
  582|      0|                if mutableState.state.canTransitionTo(.finished) {
  583|      0|                    mutableState.state = .finished
  584|      0|                }
  585|      0|
  586|      0|                mutableState.responseSerializerProcessingFinished = true
  587|      0|                mutableState.isFinishing = false
  588|      0|            }
  589|      0|
  590|      0|            completions.forEach { $0() }
  591|      0|
  592|      0|            // Cleanup the request
  593|      0|            cleanup()
  594|      0|
  595|      0|            return
  596|      0|        }
  597|      0|
  598|      0|        serializationQueue.async { responseSerializer() }
  599|      0|    }
  600|       |
  601|       |    /// Notifies the `Request` that the response serializer is complete.
  602|       |    ///
  603|       |    /// - Parameter completion: The completion handler provided with the response serializer, called when all serializers
  604|       |    ///                         are complete.
  605|      0|    func responseSerializerDidComplete(completion: @escaping () -> Void) {
  606|      0|        $mutableState.write { $0.responseSerializerCompletions.append(completion) }
  607|      0|        processNextResponseSerializer()
  608|      0|    }
  609|       |
  610|       |    /// Resets all task and response serializer related state for retry.
  611|      0|    func reset() {
  612|      0|        error = nil
  613|      0|
  614|      0|        uploadProgress.totalUnitCount = 0
  615|      0|        uploadProgress.completedUnitCount = 0
  616|      0|        downloadProgress.totalUnitCount = 0
  617|      0|        downloadProgress.completedUnitCount = 0
  618|      0|
  619|      0|        $mutableState.write { state in
  620|      0|            state.isFinishing = false
  621|      0|            state.responseSerializerCompletions = []
  622|      0|        }
  623|      0|    }
  624|       |
  625|       |    /// Called when updating the upload progress.
  626|       |    ///
  627|       |    /// - Parameters:
  628|       |    ///   - totalBytesSent: Total bytes sent so far.
  629|       |    ///   - totalBytesExpectedToSend: Total bytes expected to send.
  630|      0|    func updateUploadProgress(totalBytesSent: Int64, totalBytesExpectedToSend: Int64) {
  631|      0|        uploadProgress.totalUnitCount = totalBytesExpectedToSend
  632|      0|        uploadProgress.completedUnitCount = totalBytesSent
  633|      0|
  634|      0|        uploadProgressHandler?.queue.async { self.uploadProgressHandler?.handler(self.uploadProgress) }
  635|      0|    }
  636|       |
  637|       |    /// Perform a closure on the current `state` while locked.
  638|       |    ///
  639|       |    /// - Parameter perform: The closure to perform.
  640|      0|    func withState(perform: (State) -> Void) {
  641|      0|        $mutableState.withState(perform: perform)
  642|      0|    }
  643|       |
  644|       |    // MARK: Task Creation
  645|       |
  646|       |    /// Called when creating a `URLSessionTask` for this `Request`. Subclasses must override.
  647|       |    ///
  648|       |    /// - Parameters:
  649|       |    ///   - request: `URLRequest` to use to create the `URLSessionTask`.
  650|       |    ///   - session: `URLSession` which creates the `URLSessionTask`.
  651|       |    ///
  652|       |    /// - Returns:   The `URLSessionTask` created.
  653|      0|    func task(for request: URLRequest, using session: URLSession) -> URLSessionTask {
  654|      0|        fatalError("Subclasses must override.")
  655|      0|    }
  656|       |
  657|       |    // MARK: - Public API
  658|       |
  659|       |    // These APIs are callable from any queue.
  660|       |
  661|       |    // MARK: State
  662|       |
  663|       |    /// Cancels the instance. Once cancelled, a `Request` can no longer be resumed or suspended.
  664|       |    ///
  665|       |    /// - Returns: The instance.
  666|       |    @discardableResult
  667|      0|    public func cancel() -> Self {
  668|      0|        $mutableState.write { mutableState in
  669|      0|            guard mutableState.state.canTransitionTo(.cancelled) else { return }
  670|      0|
  671|      0|            mutableState.state = .cancelled
  672|      0|
  673|      0|            underlyingQueue.async { self.didCancel() }
  674|      0|
  675|      0|            guard let task = mutableState.tasks.last, task.state != .completed else {
  676|      0|                underlyingQueue.async { self.finish() }
  677|      0|                return
  678|      0|            }
  679|      0|
  680|      0|            // Resume to ensure metrics are gathered.
  681|      0|            task.resume()
  682|      0|            task.cancel()
  683|      0|            underlyingQueue.async { self.didCancelTask(task) }
  684|      0|        }
  685|      0|
  686|      0|        return self
  687|      0|    }
  688|       |
  689|       |    /// Suspends the instance.
  690|       |    ///
  691|       |    /// - Returns: The instance.
  692|       |    @discardableResult
  693|      0|    public func suspend() -> Self {
  694|      0|        $mutableState.write { mutableState in
  695|      0|            guard mutableState.state.canTransitionTo(.suspended) else { return }
  696|      0|
  697|      0|            mutableState.state = .suspended
  698|      0|
  699|      0|            underlyingQueue.async { self.didSuspend() }
  700|      0|
  701|      0|            guard let task = mutableState.tasks.last, task.state != .completed else { return }
  702|      0|
  703|      0|            task.suspend()
  704|      0|            underlyingQueue.async { self.didSuspendTask(task) }
  705|      0|        }
  706|      0|
  707|      0|        return self
  708|      0|    }
  709|       |
  710|       |    /// Resumes the instance.
  711|       |    ///
  712|       |    /// - Returns: The instance.
  713|       |    @discardableResult
  714|      0|    public func resume() -> Self {
  715|      0|        $mutableState.write { mutableState in
  716|      0|            guard mutableState.state.canTransitionTo(.resumed) else { return }
  717|      0|
  718|      0|            mutableState.state = .resumed
  719|      0|
  720|      0|            underlyingQueue.async { self.didResume() }
  721|      0|
  722|      0|            guard let task = mutableState.tasks.last, task.state != .completed else { return }
  723|      0|
  724|      0|            task.resume()
  725|      0|            underlyingQueue.async { self.didResumeTask(task) }
  726|      0|        }
  727|      0|
  728|      0|        return self
  729|      0|    }
  730|       |
  731|       |    // MARK: - Closure API
  732|       |
  733|       |    /// Associates a credential using the provided values with the instance.
  734|       |    ///
  735|       |    /// - Parameters:
  736|       |    ///   - username:    The username.
  737|       |    ///   - password:    The password.
  738|       |    ///   - persistence: The `URLCredential.Persistence` for the created `URLCredential`. `.forSession` by default.
  739|       |    ///
  740|       |    /// - Returns:       The instance.
  741|       |    @discardableResult
  742|      0|    public func authenticate(username: String, password: String, persistence: URLCredential.Persistence = .forSession) -> Self {
  743|      0|        let credential = URLCredential(user: username, password: password, persistence: persistence)
  744|      0|
  745|      0|        return authenticate(with: credential)
  746|      0|    }
  747|       |
  748|       |    /// Associates the provided credential with the instance.
  749|       |    ///
  750|       |    /// - Parameter credential: The `URLCredential`.
  751|       |    ///
  752|       |    /// - Returns:              The instance.
  753|       |    @discardableResult
  754|      0|    public func authenticate(with credential: URLCredential) -> Self {
  755|      0|        mutableState.credential = credential
  756|      0|
  757|      0|        return self
  758|      0|    }
  759|       |
  760|       |    /// Sets a closure to be called periodically during the lifecycle of the instance as data is read from the server.
  761|       |    ///
  762|       |    /// - Note: Only the last closure provided is used.
  763|       |    ///
  764|       |    /// - Parameters:
  765|       |    ///   - queue:   The `DispatchQueue` to execute the closure on. `.main` by default.
  766|       |    ///   - closure: The closure to be executed periodically as data is read from the server.
  767|       |    ///
  768|       |    /// - Returns:   The instance.
  769|       |    @discardableResult
  770|      0|    public func downloadProgress(queue: DispatchQueue = .main, closure: @escaping ProgressHandler) -> Self {
  771|      0|        mutableState.downloadProgressHandler = (handler: closure, queue: queue)
  772|      0|
  773|      0|        return self
  774|      0|    }
  775|       |
  776|       |    /// Sets a closure to be called periodically during the lifecycle of the instance as data is sent to the server.
  777|       |    ///
  778|       |    /// - Note: Only the last closure provided is used.
  779|       |    ///
  780|       |    /// - Parameters:
  781|       |    ///   - queue:   The `DispatchQueue` to execute the closure on. `.main` by default.
  782|       |    ///   - closure: The closure to be executed periodically as data is sent to the server.
  783|       |    ///
  784|       |    /// - Returns:   The instance.
  785|       |    @discardableResult
  786|      0|    public func uploadProgress(queue: DispatchQueue = .main, closure: @escaping ProgressHandler) -> Self {
  787|      0|        mutableState.uploadProgressHandler = (handler: closure, queue: queue)
  788|      0|
  789|      0|        return self
  790|      0|    }
  791|       |
  792|       |    // MARK: Redirects
  793|       |
  794|       |    /// Sets the redirect handler for the instance which will be used if a redirect response is encountered.
  795|       |    ///
  796|       |    /// - Note: Attempting to set the redirect handler more than once is a logic error and will crash.
  797|       |    ///
  798|       |    /// - Parameter handler: The `RedirectHandler`.
  799|       |    ///
  800|       |    /// - Returns:           The instance.
  801|       |    @discardableResult
  802|      0|    public func redirect(using handler: RedirectHandler) -> Self {
  803|      0|        $mutableState.write { mutableState in
  804|      0|            precondition(mutableState.redirectHandler == nil, "Redirect handler has already been set.")
  805|      0|            mutableState.redirectHandler = handler
  806|      0|        }
  807|      0|
  808|      0|        return self
  809|      0|    }
  810|       |
  811|       |    // MARK: Cached Responses
  812|       |
  813|       |    /// Sets the cached response handler for the `Request` which will be used when attempting to cache a response.
  814|       |    ///
  815|       |    /// - Note: Attempting to set the cache handler more than once is a logic error and will crash.
  816|       |    ///
  817|       |    /// - Parameter handler: The `CachedResponseHandler`.
  818|       |    ///
  819|       |    /// - Returns:           The instance.
  820|       |    @discardableResult
  821|      0|    public func cacheResponse(using handler: CachedResponseHandler) -> Self {
  822|      0|        $mutableState.write { mutableState in
  823|      0|            precondition(mutableState.cachedResponseHandler == nil, "Cached response handler has already been set.")
  824|      0|            mutableState.cachedResponseHandler = handler
  825|      0|        }
  826|      0|
  827|      0|        return self
  828|      0|    }
  829|       |
  830|       |    // MARK: - Lifetime APIs
  831|       |
  832|       |    /// Sets a handler to be called when the cURL description of the request is available.
  833|       |    ///
  834|       |    /// - Note: When waiting for a `Request`'s `URLRequest` to be created, only the last `handler` will be called.
  835|       |    ///
  836|       |    /// - Parameters:
  837|       |    ///   - queue:   `DispatchQueue` on which `handler` will be called.
  838|       |    ///   - handler: Closure to be called when the cURL description is available.
  839|       |    ///
  840|       |    /// - Returns:           The instance.
  841|       |    @discardableResult
  842|      0|    public func cURLDescription(on queue: DispatchQueue, calling handler: @escaping (String) -> Void) -> Self {
  843|      0|        $mutableState.write { mutableState in
  844|      0|            if mutableState.requests.last != nil {
  845|      0|                queue.async { handler(self.cURLDescription()) }
  846|      0|            } else {
  847|      0|                mutableState.cURLHandler = (queue, handler)
  848|      0|            }
  849|      0|        }
  850|      0|
  851|      0|        return self
  852|      0|    }
  853|       |
  854|       |    /// Sets a handler to be called when the cURL description of the request is available.
  855|       |    ///
  856|       |    /// - Note: When waiting for a `Request`'s `URLRequest` to be created, only the last `handler` will be called.
  857|       |    ///
  858|       |    /// - Parameter handler: Closure to be called when the cURL description is available. Called on the instance's
  859|       |    ///                      `underlyingQueue` by default.
  860|       |    ///
  861|       |    /// - Returns:           The instance.
  862|       |    @discardableResult
  863|      0|    public func cURLDescription(calling handler: @escaping (String) -> Void) -> Self {
  864|      0|        $mutableState.write { mutableState in
  865|      0|            if mutableState.requests.last != nil {
  866|      0|                underlyingQueue.async { handler(self.cURLDescription()) }
  867|      0|            } else {
  868|      0|                mutableState.cURLHandler = (underlyingQueue, handler)
  869|      0|            }
  870|      0|        }
  871|      0|
  872|      0|        return self
  873|      0|    }
  874|       |
  875|       |    /// Sets a closure to called whenever Alamofire creates a `URLRequest` for this instance.
  876|       |    ///
  877|       |    /// - Note: This closure will be called multiple times if the instance adapts incoming `URLRequest`s or is retried.
  878|       |    ///
  879|       |    /// - Parameters:
  880|       |    ///   - queue:   `DispatchQueue` on which `handler` will be called. `.main` by default.
  881|       |    ///   - handler: Closure to be called when a `URLRequest` is available.
  882|       |    ///
  883|       |    /// - Returns:   The instance.
  884|       |    @discardableResult
  885|      0|    public func onURLRequestCreation(on queue: DispatchQueue = .main, perform handler: @escaping (URLRequest) -> Void) -> Self {
  886|      0|        $mutableState.write { state in
  887|      0|            if let request = state.requests.last {
  888|      0|                queue.async { handler(request) }
  889|      0|            }
  890|      0|
  891|      0|            state.urlRequestHandler = (queue, handler)
  892|      0|        }
  893|      0|
  894|      0|        return self
  895|      0|    }
  896|       |
  897|       |    /// Sets a closure to be called whenever the instance creates a `URLSessionTask`.
  898|       |    ///
  899|       |    /// - Note: This API should only be used to provide `URLSessionTask`s to existing API, like `NSFileProvider`. It
  900|       |    ///         **SHOULD NOT** be used to interact with tasks directly, as that may be break Alamofire features.
  901|       |    ///         Additionally, this closure may be called multiple times if the instance is retried.
  902|       |    ///
  903|       |    /// - Parameters:
  904|       |    ///   - queue:   `DispatchQueue` on which `handler` will be called. `.main` by default.
  905|       |    ///   - handler: Closure to be called when the `URLSessionTask` is available.
  906|       |    ///
  907|       |    /// - Returns:   The instance.
  908|       |    @discardableResult
  909|      0|    public func onURLSessionTaskCreation(on queue: DispatchQueue = .main, perform handler: @escaping (URLSessionTask) -> Void) -> Self {
  910|      0|        $mutableState.write { state in
  911|      0|            if let task = state.tasks.last {
  912|      0|                queue.async { handler(task) }
  913|      0|            }
  914|      0|
  915|      0|            state.urlSessionTaskHandler = (queue, handler)
  916|      0|        }
  917|      0|
  918|      0|        return self
  919|      0|    }
  920|       |
  921|       |    // MARK: Cleanup
  922|       |
  923|       |    /// Final cleanup step executed when the instance finishes response serialization.
  924|      0|    func cleanup() {
  925|      0|        delegate?.cleanup(after: self)
  926|      0|        // No-op: override in subclass
  927|      0|    }
  928|       |}
  929|       |
  930|       |// MARK: - Protocol Conformances
  931|       |
  932|       |extension Request: Equatable {
  933|      0|    public static func ==(lhs: Request, rhs: Request) -> Bool {
  934|      0|        lhs.id == rhs.id
  935|      0|    }
  936|       |}
  937|       |
  938|       |extension Request: Hashable {
  939|      0|    public func hash(into hasher: inout Hasher) {
  940|      0|        hasher.combine(id)
  941|      0|    }
  942|       |}
  943|       |
  944|       |extension Request: CustomStringConvertible {
  945|       |    /// A textual representation of this instance, including the `HTTPMethod` and `URL` if the `URLRequest` has been
  946|       |    /// created, as well as the response status code, if a response has been received.
  947|      0|    public var description: String {
  948|      0|        guard let request = performedRequests.last ?? lastRequest,
  949|      0|              let url = request.url,
  950|      0|              let method = request.httpMethod else { return "No request created yet." }
  951|      0|
  952|      0|        let requestDescription = "\(method) \(url.absoluteString)"
  953|      0|
  954|      0|        return response.map { "\(requestDescription) (\($0.statusCode))" } ?? requestDescription
  955|      0|    }
  956|       |}
  957|       |
  958|       |extension Request {
  959|       |    /// cURL representation of the instance.
  960|       |    ///
  961|       |    /// - Returns: The cURL equivalent of the instance.
  962|      0|    public func cURLDescription() -> String {
  963|      0|        guard
  964|      0|            let request = lastRequest,
  965|      0|            let url = request.url,
  966|      0|            let host = url.host,
  967|      0|            let method = request.httpMethod else { return "$ curl command could not be created" }
  968|      0|
  969|      0|        var components = ["$ curl -v"]
  970|      0|
  971|      0|        components.append("-X \(method)")
  972|      0|
  973|      0|        if let credentialStorage = delegate?.sessionConfiguration.urlCredentialStorage {
  974|      0|            let protectionSpace = URLProtectionSpace(host: host,
  975|      0|                                                     port: url.port ?? 0,
  976|      0|                                                     protocol: url.scheme,
  977|      0|                                                     realm: host,
  978|      0|                                                     authenticationMethod: NSURLAuthenticationMethodHTTPBasic)
  979|      0|
  980|      0|            if let credentials = credentialStorage.credentials(for: protectionSpace)?.values {
  981|      0|                for credential in credentials {
  982|      0|                    guard let user = credential.user, let password = credential.password else { continue }
  983|      0|                    components.append("-u \(user):\(password)")
  984|      0|                }
  985|      0|            } else {
  986|      0|                if let credential = credential, let user = credential.user, let password = credential.password {
  987|      0|                    components.append("-u \(user):\(password)")
  988|      0|                }
  989|      0|            }
  990|      0|        }
  991|      0|
  992|      0|        if let configuration = delegate?.sessionConfiguration, configuration.httpShouldSetCookies {
  993|      0|            if
  994|      0|                let cookieStorage = configuration.httpCookieStorage,
  995|      0|                let cookies = cookieStorage.cookies(for: url), !cookies.isEmpty {
  996|      0|                let allCookies = cookies.map { "\($0.name)=\($0.value)" }.joined(separator: ";")
  997|      0|
  998|      0|                components.append("-b \"\(allCookies)\"")
  999|      0|            }
 1000|      0|        }
 1001|      0|
 1002|      0|        var headers = HTTPHeaders()
 1003|      0|
 1004|      0|        if let sessionHeaders = delegate?.sessionConfiguration.headers {
 1005|      0|            for header in sessionHeaders where header.name != "Cookie" {
 1006|      0|                headers[header.name] = header.value
 1007|      0|            }
 1008|      0|        }
 1009|      0|
 1010|      0|        for header in request.headers where header.name != "Cookie" {
 1011|      0|            headers[header.name] = header.value
 1012|      0|        }
 1013|      0|
 1014|      0|        for header in headers {
 1015|      0|            let escapedValue = header.value.replacingOccurrences(of: "\"", with: "\\\"")
 1016|      0|            components.append("-H \"\(header.name): \(escapedValue)\"")
 1017|      0|        }
 1018|      0|
 1019|      0|        if let httpBodyData = request.httpBody {
 1020|      0|            let httpBody = String(decoding: httpBodyData, as: UTF8.self)
 1021|      0|            var escapedBody = httpBody.replacingOccurrences(of: "\\\"", with: "\\\\\"")
 1022|      0|            escapedBody = escapedBody.replacingOccurrences(of: "\"", with: "\\\"")
 1023|      0|
 1024|      0|            components.append("-d \"\(escapedBody)\"")
 1025|      0|        }
 1026|      0|
 1027|      0|        components.append("\"\(url.absoluteString)\"")
 1028|      0|
 1029|      0|        return components.joined(separator: " \\\n\t")
 1030|      0|    }
 1031|       |}
 1032|       |
 1033|       |/// Protocol abstraction for `Request`'s communication back to the `SessionDelegate`.
 1034|       |public protocol RequestDelegate: AnyObject {
 1035|       |    /// `URLSessionConfiguration` used to create the underlying `URLSessionTask`s.
 1036|       |    var sessionConfiguration: URLSessionConfiguration { get }
 1037|       |
 1038|       |    /// Determines whether the `Request` should automatically call `resume()` when adding the first response handler.
 1039|       |    var startImmediately: Bool { get }
 1040|       |
 1041|       |    /// Notifies the delegate the `Request` has reached a point where it needs cleanup.
 1042|       |    ///
 1043|       |    /// - Parameter request: The `Request` to cleanup after.
 1044|       |    func cleanup(after request: Request)
 1045|       |
 1046|       |    /// Asynchronously ask the delegate whether a `Request` will be retried.
 1047|       |    ///
 1048|       |    /// - Parameters:
 1049|       |    ///   - request:    `Request` which failed.
 1050|       |    ///   - error:      `Error` which produced the failure.
 1051|       |    ///   - completion: Closure taking the `RetryResult` for evaluation.
 1052|       |    func retryResult(for request: Request, dueTo error: AFError, completion: @escaping (RetryResult) -> Void)
 1053|       |
 1054|       |    /// Asynchronously retry the `Request`.
 1055|       |    ///
 1056|       |    /// - Parameters:
 1057|       |    ///   - request:   `Request` which will be retried.
 1058|       |    ///   - timeDelay: `TimeInterval` after which the retry will be triggered.
 1059|       |    func retryRequest(_ request: Request, withDelay timeDelay: TimeInterval?)
 1060|       |}
 1061|       |
 1062|       |// MARK: - Subclasses
 1063|       |
 1064|       |// MARK: - DataRequest
 1065|       |
 1066|       |/// `Request` subclass which handles in-memory `Data` download using `URLSessionDataTask`.
 1067|       |public class DataRequest: Request {
 1068|       |    /// `URLRequestConvertible` value used to create `URLRequest`s for this instance.
 1069|       |    public let convertible: URLRequestConvertible
 1070|       |    /// `Data` read from the server so far.
 1071|      0|    public var data: Data? { mutableData }
 1072|       |
 1073|       |    /// Protected storage for the `Data` read by the instance.
 1074|       |    @Protected
 1075|       |    private var mutableData: Data? = nil
 1076|       |
 1077|       |    /// Creates a `DataRequest` using the provided parameters.
 1078|       |    ///
 1079|       |    /// - Parameters:
 1080|       |    ///   - id:                 `UUID` used for the `Hashable` and `Equatable` implementations. `UUID()` by default.
 1081|       |    ///   - convertible:        `URLRequestConvertible` value used to create `URLRequest`s for this instance.
 1082|       |    ///   - underlyingQueue:    `DispatchQueue` on which all internal `Request` work is performed.
 1083|       |    ///   - serializationQueue: `DispatchQueue` on which all serialization work is performed. By default targets
 1084|       |    ///                         `underlyingQueue`, but can be passed another queue from a `Session`.
 1085|       |    ///   - eventMonitor:       `EventMonitor` called for event callbacks from internal `Request` actions.
 1086|       |    ///   - interceptor:        `RequestInterceptor` used throughout the request lifecycle.
 1087|       |    ///   - delegate:           `RequestDelegate` that provides an interface to actions not performed by the `Request`.
 1088|       |    init(id: UUID = UUID(),
 1089|       |         convertible: URLRequestConvertible,
 1090|       |         underlyingQueue: DispatchQueue,
 1091|       |         serializationQueue: DispatchQueue,
 1092|       |         eventMonitor: EventMonitor?,
 1093|       |         interceptor: RequestInterceptor?,
 1094|      0|         delegate: RequestDelegate) {
 1095|      0|        self.convertible = convertible
 1096|      0|
 1097|      0|        super.init(id: id,
 1098|      0|                   underlyingQueue: underlyingQueue,
 1099|      0|                   serializationQueue: serializationQueue,
 1100|      0|                   eventMonitor: eventMonitor,
 1101|      0|                   interceptor: interceptor,
 1102|      0|                   delegate: delegate)
 1103|      0|    }
 1104|       |
 1105|      0|    override func reset() {
 1106|      0|        super.reset()
 1107|      0|
 1108|      0|        mutableData = nil
 1109|      0|    }
 1110|       |
 1111|       |    /// Called when `Data` is received by this instance.
 1112|       |    ///
 1113|       |    /// - Note: Also calls `updateDownloadProgress`.
 1114|       |    ///
 1115|       |    /// - Parameter data: The `Data` received.
 1116|      0|    func didReceive(data: Data) {
 1117|      0|        if self.data == nil {
 1118|      0|            mutableData = data
 1119|      0|        } else {
 1120|      0|            $mutableData.write { $0?.append(data) }
 1121|      0|        }
 1122|      0|
 1123|      0|        updateDownloadProgress()
 1124|      0|    }
 1125|       |
 1126|      0|    override func task(for request: URLRequest, using session: URLSession) -> URLSessionTask {
 1127|      0|        let copiedRequest = request
 1128|      0|        return session.dataTask(with: copiedRequest)
 1129|      0|    }
 1130|       |
 1131|       |    /// Called to updated the `downloadProgress` of the instance.
 1132|      0|    func updateDownloadProgress() {
 1133|      0|        let totalBytesReceived = Int64(data?.count ?? 0)
 1134|      0|        let totalBytesExpected = task?.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
 1135|      0|
 1136|      0|        downloadProgress.totalUnitCount = totalBytesExpected
 1137|      0|        downloadProgress.completedUnitCount = totalBytesReceived
 1138|      0|
 1139|      0|        downloadProgressHandler?.queue.async { self.downloadProgressHandler?.handler(self.downloadProgress) }
 1140|      0|    }
 1141|       |
 1142|       |    /// Validates the request, using the specified closure.
 1143|       |    ///
 1144|       |    /// - Note: If validation fails, subsequent calls to response handlers will have an associated error.
 1145|       |    ///
 1146|       |    /// - Parameter validation: `Validation` closure used to validate the response.
 1147|       |    ///
 1148|       |    /// - Returns:              The instance.
 1149|       |    @discardableResult
 1150|      0|    public func validate(_ validation: @escaping Validation) -> Self {
 1151|      0|        let validator: () -> Void = { [unowned self] in
 1152|      0|            guard self.error == nil, let response = self.response else { return }
 1153|      0|
 1154|      0|            let result = validation(self.request, response, self.data)
 1155|      0|
 1156|      0|            if case let .failure(error) = result { self.error = error.asAFError(or: .responseValidationFailed(reason: .customValidationFailed(error: error))) }
 1157|      0|
 1158|      0|            self.eventMonitor?.request(self,
 1159|      0|                                       didValidateRequest: self.request,
 1160|      0|                                       response: response,
 1161|      0|                                       data: self.data,
 1162|      0|                                       withResult: result)
 1163|      0|        }
 1164|      0|
 1165|      0|        $validators.write { $0.append(validator) }
 1166|      0|
 1167|      0|        return self
 1168|      0|    }
 1169|       |}
 1170|       |
 1171|       |// MARK: - DataStreamRequest
 1172|       |
 1173|       |/// `Request` subclass which streams HTTP response `Data` through a `Handler` closure.
 1174|       |public final class DataStreamRequest: Request {
 1175|       |    /// Closure type handling `DataStreamRequest.Stream` values.
 1176|       |    public typealias Handler<Success, Failure: Error> = (Stream<Success, Failure>) throws -> Void
 1177|       |
 1178|       |    /// Type encapsulating an `Event` as it flows through the stream, as well as a `CancellationToken` which can be used
 1179|       |    /// to stop the stream at any time.
 1180|       |    public struct Stream<Success, Failure: Error> {
 1181|       |        /// Latest `Event` from the stream.
 1182|       |        public let event: Event<Success, Failure>
 1183|       |        /// Token used to cancel the stream.
 1184|       |        public let token: CancellationToken
 1185|       |
 1186|       |        /// Cancel the ongoing stream by canceling the underlying `DataStreamRequest`.
 1187|      0|        public func cancel() {
 1188|      0|            token.cancel()
 1189|      0|        }
 1190|       |    }
 1191|       |
 1192|       |    /// Type representing an event flowing through the stream. Contains either the `Result` of processing streamed
 1193|       |    /// `Data` or the completion of the stream.
 1194|       |    public enum Event<Success, Failure: Error> {
 1195|       |        /// Output produced every time the instance receives additional `Data`. The associated value contains the
 1196|       |        /// `Result` of processing the incoming `Data`.
 1197|       |        case stream(Result<Success, Failure>)
 1198|       |        /// Output produced when the instance has completed, whether due to stream end, cancellation, or an error.
 1199|       |        /// Associated `Completion` value contains the final state.
 1200|       |        case complete(Completion)
 1201|       |    }
 1202|       |
 1203|       |    /// Value containing the state of a `DataStreamRequest` when the stream was completed.
 1204|       |    public struct Completion {
 1205|       |        /// Last `URLRequest` issued by the instance.
 1206|       |        public let request: URLRequest?
 1207|       |        /// Last `HTTPURLResponse` received by the instance.
 1208|       |        public let response: HTTPURLResponse?
 1209|       |        /// Last `URLSessionTaskMetrics` produced for the instance.
 1210|       |        public let metrics: URLSessionTaskMetrics?
 1211|       |        /// `AFError` produced for the instance, if any.
 1212|       |        public let error: AFError?
 1213|       |    }
 1214|       |
 1215|       |    /// Type used to cancel an ongoing stream.
 1216|       |    public struct CancellationToken {
 1217|       |        weak var request: DataStreamRequest?
 1218|       |
 1219|      0|        init(_ request: DataStreamRequest) {
 1220|      0|            self.request = request
 1221|      0|        }
 1222|       |
 1223|       |        /// Cancel the ongoing stream by canceling the underlying `DataStreamRequest`.
 1224|      0|        public func cancel() {
 1225|      0|            request?.cancel()
 1226|      0|        }
 1227|       |    }
 1228|       |
 1229|       |    /// `URLRequestConvertible` value used to create `URLRequest`s for this instance.
 1230|       |    public let convertible: URLRequestConvertible
 1231|       |    /// Whether or not the instance will be cancelled if stream parsing encounters an error.
 1232|       |    public let automaticallyCancelOnStreamError: Bool
 1233|       |
 1234|       |    /// Internal mutable state specific to this type.
 1235|       |    struct StreamMutableState {
 1236|       |        /// `OutputStream` bound to the `InputStream` produced by `asInputStream`, if it has been called.
 1237|       |        var outputStream: OutputStream?
 1238|       |        /// Stream closures called as `Data` is received.
 1239|      0|        var streams: [(_ data: Data) -> Void] = []
 1240|       |        /// Number of currently executing streams. Used to ensure completions are only fired after all streams are
 1241|       |        /// enqueued.
 1242|       |        var numberOfExecutingStreams = 0
 1243|       |        /// Completion calls enqueued while streams are still executing.
 1244|      0|        var enqueuedCompletionEvents: [() -> Void] = []
 1245|       |    }
 1246|       |
 1247|       |    @Protected
 1248|      0|    var streamMutableState = StreamMutableState()
 1249|       |
 1250|       |    /// Creates a `DataStreamRequest` using the provided parameters.
 1251|       |    ///
 1252|       |    /// - Parameters:
 1253|       |    ///   - id:                               `UUID` used for the `Hashable` and `Equatable` implementations. `UUID()`
 1254|       |    ///                                        by default.
 1255|       |    ///   - convertible:                      `URLRequestConvertible` value used to create `URLRequest`s for this
 1256|       |    ///                                        instance.
 1257|       |    ///   - automaticallyCancelOnStreamError: `Bool` indicating whether the instance will be cancelled when an `Error`
 1258|       |    ///                                       is thrown while serializing stream `Data`.
 1259|       |    ///   - underlyingQueue:                  `DispatchQueue` on which all internal `Request` work is performed.
 1260|       |    ///   - serializationQueue:               `DispatchQueue` on which all serialization work is performed. By default
 1261|       |    ///                                       targets
 1262|       |    ///                                       `underlyingQueue`, but can be passed another queue from a `Session`.
 1263|       |    ///   - eventMonitor:                     `EventMonitor` called for event callbacks from internal `Request` actions.
 1264|       |    ///   - interceptor:                      `RequestInterceptor` used throughout the request lifecycle.
 1265|       |    ///   - delegate:                         `RequestDelegate` that provides an interface to actions not performed by
 1266|       |    ///                                       the `Request`.
 1267|       |    init(id: UUID = UUID(),
 1268|       |         convertible: URLRequestConvertible,
 1269|       |         automaticallyCancelOnStreamError: Bool,
 1270|       |         underlyingQueue: DispatchQueue,
 1271|       |         serializationQueue: DispatchQueue,
 1272|       |         eventMonitor: EventMonitor?,
 1273|       |         interceptor: RequestInterceptor?,
 1274|      0|         delegate: RequestDelegate) {
 1275|      0|        self.convertible = convertible
 1276|      0|        self.automaticallyCancelOnStreamError = automaticallyCancelOnStreamError
 1277|      0|
 1278|      0|        super.init(id: id,
 1279|      0|                   underlyingQueue: underlyingQueue,
 1280|      0|                   serializationQueue: serializationQueue,
 1281|      0|                   eventMonitor: eventMonitor,
 1282|      0|                   interceptor: interceptor,
 1283|      0|                   delegate: delegate)
 1284|      0|    }
 1285|       |
 1286|      0|    override func task(for request: URLRequest, using session: URLSession) -> URLSessionTask {
 1287|      0|        let copiedRequest = request
 1288|      0|        return session.dataTask(with: copiedRequest)
 1289|      0|    }
 1290|       |
 1291|      0|    override func finish(error: AFError? = nil) {
 1292|      0|        $streamMutableState.write { state in
 1293|      0|            state.outputStream?.close()
 1294|      0|        }
 1295|      0|
 1296|      0|        super.finish(error: error)
 1297|      0|    }
 1298|       |
 1299|      0|    func didReceive(data: Data) {
 1300|      0|        $streamMutableState.write { state in
 1301|      0|            if let stream = state.outputStream {
 1302|      0|                underlyingQueue.async {
 1303|      0|                    var bytes = Array(data)
 1304|      0|                    stream.write(&bytes, maxLength: bytes.count)
 1305|      0|                }
 1306|      0|            }
 1307|      0|            state.numberOfExecutingStreams += state.streams.count
 1308|      0|            let localState = state
 1309|      0|            underlyingQueue.async { localState.streams.forEach { $0(data) } }
 1310|      0|        }
 1311|      0|    }
 1312|       |
 1313|       |    /// Validates the `URLRequest` and `HTTPURLResponse` received for the instance using the provided `Validation` closure.
 1314|       |    ///
 1315|       |    /// - Parameter validation: `Validation` closure used to validate the request and response.
 1316|       |    ///
 1317|       |    /// - Returns:              The `DataStreamRequest`.
 1318|       |    @discardableResult
 1319|      0|    public func validate(_ validation: @escaping Validation) -> Self {
 1320|      0|        let validator: () -> Void = { [unowned self] in
 1321|      0|            guard self.error == nil, let response = self.response else { return }
 1322|      0|
 1323|      0|            let result = validation(self.request, response)
 1324|      0|
 1325|      0|            if case let .failure(error) = result {
 1326|      0|                self.error = error.asAFError(or: .responseValidationFailed(reason: .customValidationFailed(error: error)))
 1327|      0|            }
 1328|      0|
 1329|      0|            self.eventMonitor?.request(self,
 1330|      0|                                       didValidateRequest: self.request,
 1331|      0|                                       response: response,
 1332|      0|                                       withResult: result)
 1333|      0|        }
 1334|      0|
 1335|      0|        $validators.write { $0.append(validator) }
 1336|      0|
 1337|      0|        return self
 1338|      0|    }
 1339|       |
 1340|       |    /// Produces an `InputStream` that receives the `Data` received by the instance.
 1341|       |    ///
 1342|       |    /// - Note: The `InputStream` produced by this method must have `open()` called before being able to read `Data`.
 1343|       |    ///         Additionally, this method will automatically call `resume()` on the instance, regardless of whether or
 1344|       |    ///         not the creating session has `startRequestsImmediately` set to `true`.
 1345|       |    ///
 1346|       |    /// - Parameter bufferSize: Size, in bytes, of the buffer between the `OutputStream` and `InputStream`.
 1347|       |    ///
 1348|       |    /// - Returns:              The `InputStream` bound to the internal `OutboundStream`.
 1349|      0|    public func asInputStream(bufferSize: Int = 1024) -> InputStream? {
 1350|      0|        defer { resume() }
 1351|      0|
 1352|      0|        var inputStream: InputStream?
 1353|      0|        $streamMutableState.write { state in
 1354|      0|            Foundation.Stream.getBoundStreams(withBufferSize: bufferSize,
 1355|      0|                                              inputStream: &inputStream,
 1356|      0|                                              outputStream: &state.outputStream)
 1357|      0|            state.outputStream?.open()
 1358|      0|        }
 1359|      0|
 1360|      0|        return inputStream
 1361|      0|    }
 1362|       |
 1363|      0|    func capturingError(from closure: () throws -> Void) {
 1364|      0|        do {
 1365|      0|            try closure()
 1366|      0|        } catch {
 1367|      0|            self.error = error.asAFError(or: .responseSerializationFailed(reason: .customSerializationFailed(error: error)))
 1368|      0|            cancel()
 1369|      0|        }
 1370|      0|    }
 1371|       |
 1372|       |    func appendStreamCompletion<Success, Failure>(on queue: DispatchQueue,
 1373|      0|                                                  stream: @escaping Handler<Success, Failure>) {
 1374|      0|        appendResponseSerializer {
 1375|      0|            self.underlyingQueue.async {
 1376|      0|                self.responseSerializerDidComplete {
 1377|      0|                    self.$streamMutableState.write { state in
 1378|      0|                        guard state.numberOfExecutingStreams == 0 else {
 1379|      0|                            state.enqueuedCompletionEvents.append {
 1380|      0|                                self.enqueueCompletion(on: queue, stream: stream)
 1381|      0|                            }
 1382|      0|
 1383|      0|                            return
 1384|      0|                        }
 1385|      0|
 1386|      0|                        self.enqueueCompletion(on: queue, stream: stream)
 1387|      0|                    }
 1388|      0|                }
 1389|      0|            }
 1390|      0|        }
 1391|      0|    }
 1392|       |
 1393|       |    func enqueueCompletion<Success, Failure>(on queue: DispatchQueue,
 1394|      0|                                             stream: @escaping Handler<Success, Failure>) {
 1395|      0|        queue.async {
 1396|      0|            do {
 1397|      0|                let completion = Completion(request: self.request,
 1398|      0|                                            response: self.response,
 1399|      0|                                            metrics: self.metrics,
 1400|      0|                                            error: self.error)
 1401|      0|                try stream(.init(event: .complete(completion), token: .init(self)))
 1402|      0|            } catch {
 1403|      0|                // Ignore error, as errors on Completion can't be handled anyway.
 1404|      0|            }
 1405|      0|        }
 1406|      0|    }
 1407|       |}
 1408|       |
 1409|       |extension DataStreamRequest.Stream {
 1410|       |    /// Incoming `Result` values from `Event.stream`.
 1411|      0|    public var result: Result<Success, Failure>? {
 1412|      0|        guard case let .stream(result) = event else { return nil }
 1413|      0|
 1414|      0|        return result
 1415|      0|    }
 1416|       |
 1417|       |    /// `Success` value of the instance, if any.
 1418|      0|    public var value: Success? {
 1419|      0|        guard case let .success(value) = result else { return nil }
 1420|      0|
 1421|      0|        return value
 1422|      0|    }
 1423|       |
 1424|       |    /// `Failure` value of the instance, if any.
 1425|      0|    public var error: Failure? {
 1426|      0|        guard case let .failure(error) = result else { return nil }
 1427|      0|
 1428|      0|        return error
 1429|      0|    }
 1430|       |
 1431|       |    /// `Completion` value of the instance, if any.
 1432|      0|    public var completion: DataStreamRequest.Completion? {
 1433|      0|        guard case let .complete(completion) = event else { return nil }
 1434|      0|
 1435|      0|        return completion
 1436|      0|    }
 1437|       |}
 1438|       |
 1439|       |// MARK: - DownloadRequest
 1440|       |
 1441|       |/// `Request` subclass which downloads `Data` to a file on disk using `URLSessionDownloadTask`.
 1442|       |public class DownloadRequest: Request {
 1443|       |    /// A set of options to be executed prior to moving a downloaded file from the temporary `URL` to the destination
 1444|       |    /// `URL`.
 1445|       |    public struct Options: OptionSet {
 1446|       |        /// Specifies that intermediate directories for the destination URL should be created.
 1447|       |        public static let createIntermediateDirectories = Options(rawValue: 1 << 0)
 1448|       |        /// Specifies that any previous file at the destination `URL` should be removed.
 1449|       |        public static let removePreviousFile = Options(rawValue: 1 << 1)
 1450|       |
 1451|       |        public let rawValue: Int
 1452|       |
 1453|      0|        public init(rawValue: Int) {
 1454|      0|            self.rawValue = rawValue
 1455|      0|        }
 1456|       |    }
 1457|       |
 1458|       |    // MARK: Destination
 1459|       |
 1460|       |    /// A closure executed once a `DownloadRequest` has successfully completed in order to determine where to move the
 1461|       |    /// temporary file written to during the download process. The closure takes two arguments: the temporary file URL
 1462|       |    /// and the `HTTPURLResponse`, and returns two values: the file URL where the temporary file should be moved and
 1463|       |    /// the options defining how the file should be moved.
 1464|       |    ///
 1465|       |    /// - Note: Downloads from a local `file://` `URL`s do not use the `Destination` closure, as those downloads do not
 1466|       |    ///         return an `HTTPURLResponse`. Instead the file is merely moved within the temporary directory.
 1467|       |    public typealias Destination = (_ temporaryURL: URL,
 1468|       |                                    _ response: HTTPURLResponse) -> (destinationURL: URL, options: Options)
 1469|       |
 1470|       |    /// Creates a download file destination closure which uses the default file manager to move the temporary file to a
 1471|       |    /// file URL in the first available directory with the specified search path directory and search path domain mask.
 1472|       |    ///
 1473|       |    /// - Parameters:
 1474|       |    ///   - directory: The search path directory. `.documentDirectory` by default.
 1475|       |    ///   - domain:    The search path domain mask. `.userDomainMask` by default.
 1476|       |    ///   - options:   `DownloadRequest.Options` used when moving the downloaded file to its destination. None by
 1477|       |    ///                default.
 1478|       |    /// - Returns: The `Destination` closure.
 1479|       |    public class func suggestedDownloadDestination(for directory: FileManager.SearchPathDirectory = .documentDirectory,
 1480|       |                                                   in domain: FileManager.SearchPathDomainMask = .userDomainMask,
 1481|      0|                                                   options: Options = []) -> Destination {
 1482|      0|        { temporaryURL, response in
 1483|      0|            let directoryURLs = FileManager.default.urls(for: directory, in: domain)
 1484|      0|            let url = directoryURLs.first?.appendingPathComponent(response.suggestedFilename!) ?? temporaryURL
 1485|      0|
 1486|      0|            return (url, options)
 1487|      0|        }
 1488|      0|    }
 1489|       |
 1490|       |    /// Default `Destination` used by Alamofire to ensure all downloads persist. This `Destination` prepends
 1491|       |    /// `Alamofire_` to the automatically generated download name and moves it within the temporary directory. Files
 1492|       |    /// with this destination must be additionally moved if they should survive the system reclamation of temporary
 1493|       |    /// space.
 1494|      0|    static let defaultDestination: Destination = { url, _ in
 1495|      0|        (defaultDestinationURL(url), [])
 1496|      0|    }
 1497|       |
 1498|       |    /// Default `URL` creation closure. Creates a `URL` in the temporary directory with `Alamofire_` prepended to the
 1499|       |    /// provided file name.
 1500|      0|    static let defaultDestinationURL: (URL) -> URL = { url in
 1501|      0|        let filename = "Alamofire_\(url.lastPathComponent)"
 1502|      0|        let destination = url.deletingLastPathComponent().appendingPathComponent(filename)
 1503|      0|
 1504|      0|        return destination
 1505|      0|    }
 1506|       |
 1507|       |    // MARK: Downloadable
 1508|       |
 1509|       |    /// Type describing the source used to create the underlying `URLSessionDownloadTask`.
 1510|       |    public enum Downloadable {
 1511|       |        /// Download should be started from the `URLRequest` produced by the associated `URLRequestConvertible` value.
 1512|       |        case request(URLRequestConvertible)
 1513|       |        /// Download should be started from the associated resume `Data` value.
 1514|       |        case resumeData(Data)
 1515|       |    }
 1516|       |
 1517|       |    // MARK: Mutable State
 1518|       |
 1519|       |    /// Type containing all mutable state for `DownloadRequest` instances.
 1520|       |    private struct DownloadRequestMutableState {
 1521|       |        /// Possible resume `Data` produced when cancelling the instance.
 1522|       |        var resumeData: Data?
 1523|       |        /// `URL` to which `Data` is being downloaded.
 1524|       |        var fileURL: URL?
 1525|       |    }
 1526|       |
 1527|       |    /// Protected mutable state specific to `DownloadRequest`.
 1528|       |    @Protected
 1529|      0|    private var mutableDownloadState = DownloadRequestMutableState()
 1530|       |
 1531|       |    /// If the download is resumable and eventually cancelled, this value may be used to resume the download using the
 1532|       |    /// `download(resumingWith data:)` API.
 1533|       |    ///
 1534|       |    /// - Note: For more information about `resumeData`, see [Apple's documentation](https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel).
 1535|      0|    public var resumeData: Data? { mutableDownloadState.resumeData }
 1536|       |    /// If the download is successful, the `URL` where the file was downloaded.
 1537|      0|    public var fileURL: URL? { mutableDownloadState.fileURL }
 1538|       |
 1539|       |    // MARK: Initial State
 1540|       |
 1541|       |    /// `Downloadable` value used for this instance.
 1542|       |    public let downloadable: Downloadable
 1543|       |    /// The `Destination` to which the downloaded file is moved.
 1544|       |    let destination: Destination
 1545|       |
 1546|       |    /// Creates a `DownloadRequest` using the provided parameters.
 1547|       |    ///
 1548|       |    /// - Parameters:
 1549|       |    ///   - id:                 `UUID` used for the `Hashable` and `Equatable` implementations. `UUID()` by default.
 1550|       |    ///   - downloadable:       `Downloadable` value used to create `URLSessionDownloadTasks` for the instance.
 1551|       |    ///   - underlyingQueue:    `DispatchQueue` on which all internal `Request` work is performed.
 1552|       |    ///   - serializationQueue: `DispatchQueue` on which all serialization work is performed. By default targets
 1553|       |    ///                         `underlyingQueue`, but can be passed another queue from a `Session`.
 1554|       |    ///   - eventMonitor:       `EventMonitor` called for event callbacks from internal `Request` actions.
 1555|       |    ///   - interceptor:        `RequestInterceptor` used throughout the request lifecycle.
 1556|       |    ///   - delegate:           `RequestDelegate` that provides an interface to actions not performed by the `Request`
 1557|       |    ///   - destination:        `Destination` closure used to move the downloaded file to its final location.
 1558|       |    init(id: UUID = UUID(),
 1559|       |         downloadable: Downloadable,
 1560|       |         underlyingQueue: DispatchQueue,
 1561|       |         serializationQueue: DispatchQueue,
 1562|       |         eventMonitor: EventMonitor?,
 1563|       |         interceptor: RequestInterceptor?,
 1564|       |         delegate: RequestDelegate,
 1565|      0|         destination: @escaping Destination) {
 1566|      0|        self.downloadable = downloadable
 1567|      0|        self.destination = destination
 1568|      0|
 1569|      0|        super.init(id: id,
 1570|      0|                   underlyingQueue: underlyingQueue,
 1571|      0|                   serializationQueue: serializationQueue,
 1572|      0|                   eventMonitor: eventMonitor,
 1573|      0|                   interceptor: interceptor,
 1574|      0|                   delegate: delegate)
 1575|      0|    }
 1576|       |
 1577|      0|    override func reset() {
 1578|      0|        super.reset()
 1579|      0|
 1580|      0|        $mutableDownloadState.write {
 1581|      0|            $0.resumeData = nil
 1582|      0|            $0.fileURL = nil
 1583|      0|        }
 1584|      0|    }
 1585|       |
 1586|       |    /// Called when a download has finished.
 1587|       |    ///
 1588|       |    /// - Parameters:
 1589|       |    ///   - task:   `URLSessionTask` that finished the download.
 1590|       |    ///   - result: `Result` of the automatic move to `destination`.
 1591|      0|    func didFinishDownloading(using task: URLSessionTask, with result: Result<URL, AFError>) {
 1592|      0|        eventMonitor?.request(self, didFinishDownloadingUsing: task, with: result)
 1593|      0|
 1594|      0|        switch result {
 1595|      0|        case let .success(url): mutableDownloadState.fileURL = url
 1596|      0|        case let .failure(error): self.error = error
 1597|      0|        }
 1598|      0|    }
 1599|       |
 1600|       |    /// Updates the `downloadProgress` using the provided values.
 1601|       |    ///
 1602|       |    /// - Parameters:
 1603|       |    ///   - bytesWritten:              Total bytes written so far.
 1604|       |    ///   - totalBytesExpectedToWrite: Total bytes expected to write.
 1605|      0|    func updateDownloadProgress(bytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
 1606|      0|        downloadProgress.totalUnitCount = totalBytesExpectedToWrite
 1607|      0|        downloadProgress.completedUnitCount += bytesWritten
 1608|      0|
 1609|      0|        downloadProgressHandler?.queue.async { self.downloadProgressHandler?.handler(self.downloadProgress) }
 1610|      0|    }
 1611|       |
 1612|      0|    override func task(for request: URLRequest, using session: URLSession) -> URLSessionTask {
 1613|      0|        session.downloadTask(with: request)
 1614|      0|    }
 1615|       |
 1616|       |    /// Creates a `URLSessionTask` from the provided resume data.
 1617|       |    ///
 1618|       |    /// - Parameters:
 1619|       |    ///   - data:    `Data` used to resume the download.
 1620|       |    ///   - session: `URLSession` used to create the `URLSessionTask`.
 1621|       |    ///
 1622|       |    /// - Returns:   The `URLSessionTask` created.
 1623|      0|    public func task(forResumeData data: Data, using session: URLSession) -> URLSessionTask {
 1624|      0|        session.downloadTask(withResumeData: data)
 1625|      0|    }
 1626|       |
 1627|       |    /// Cancels the instance. Once cancelled, a `DownloadRequest` can no longer be resumed or suspended.
 1628|       |    ///
 1629|       |    /// - Note: This method will NOT produce resume data. If you wish to cancel and produce resume data, use
 1630|       |    ///         `cancel(producingResumeData:)` or `cancel(byProducingResumeData:)`.
 1631|       |    ///
 1632|       |    /// - Returns: The instance.
 1633|       |    @discardableResult
 1634|      0|    override public func cancel() -> Self {
 1635|      0|        cancel(producingResumeData: false)
 1636|      0|    }
 1637|       |
 1638|       |    /// Cancels the instance, optionally producing resume data. Once cancelled, a `DownloadRequest` can no longer be
 1639|       |    /// resumed or suspended.
 1640|       |    ///
 1641|       |    /// - Note: If `producingResumeData` is `true`, the `resumeData` property will be populated with any resume data, if
 1642|       |    ///         available.
 1643|       |    ///
 1644|       |    /// - Returns: The instance.
 1645|       |    @discardableResult
 1646|      0|    public func cancel(producingResumeData shouldProduceResumeData: Bool) -> Self {
 1647|      0|        cancel(optionallyProducingResumeData: shouldProduceResumeData ? { _ in } : nil)
 1648|      0|    }
 1649|       |
 1650|       |    /// Cancels the instance while producing resume data. Once cancelled, a `DownloadRequest` can no longer be resumed
 1651|       |    /// or suspended.
 1652|       |    ///
 1653|       |    /// - Note: The resume data passed to the completion handler will also be available on the instance's `resumeData`
 1654|       |    ///         property.
 1655|       |    ///
 1656|       |    /// - Parameter completionHandler: The completion handler that is called when the download has been successfully
 1657|       |    ///                                cancelled. It is not guaranteed to be called on a particular queue, so you may
 1658|       |    ///                                want use an appropriate queue to perform your work.
 1659|       |    ///
 1660|       |    /// - Returns:                     The instance.
 1661|       |    @discardableResult
 1662|      0|    public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Data?) -> Void) -> Self {
 1663|      0|        cancel(optionallyProducingResumeData: completionHandler)
 1664|      0|    }
 1665|       |
 1666|       |    /// Internal implementation of cancellation that optionally takes a resume data handler. If no handler is passed,
 1667|       |    /// cancellation is performed without producing resume data.
 1668|       |    ///
 1669|       |    /// - Parameter completionHandler: Optional resume data handler.
 1670|       |    ///
 1671|       |    /// - Returns:                     The instance.
 1672|      0|    private func cancel(optionallyProducingResumeData completionHandler: ((_ resumeData: Data?) -> Void)?) -> Self {
 1673|      0|        $mutableState.write { mutableState in
 1674|      0|            guard mutableState.state.canTransitionTo(.cancelled) else { return }
 1675|      0|
 1676|      0|            mutableState.state = .cancelled
 1677|      0|
 1678|      0|            underlyingQueue.async { self.didCancel() }
 1679|      0|
 1680|      0|            guard let task = mutableState.tasks.last as? URLSessionDownloadTask, task.state != .completed else {
 1681|      0|                underlyingQueue.async { self.finish() }
 1682|      0|                return
 1683|      0|            }
 1684|      0|
 1685|      0|            if let completionHandler = completionHandler {
 1686|      0|                // Resume to ensure metrics are gathered.
 1687|      0|                task.resume()
 1688|      0|                task.cancel { resumeData in
 1689|      0|                    self.mutableDownloadState.resumeData = resumeData
 1690|      0|                    self.underlyingQueue.async { self.didCancelTask(task) }
 1691|      0|                    completionHandler(resumeData)
 1692|      0|                }
 1693|      0|            } else {
 1694|      0|                // Resume to ensure metrics are gathered.
 1695|      0|                task.resume()
 1696|      0|                task.cancel(byProducingResumeData: { _ in })
 1697|      0|                self.underlyingQueue.async { self.didCancelTask(task) }
 1698|      0|            }
 1699|      0|        }
 1700|      0|
 1701|      0|        return self
 1702|      0|    }
 1703|       |
 1704|       |    /// Validates the request, using the specified closure.
 1705|       |    ///
 1706|       |    /// - Note: If validation fails, subsequent calls to response handlers will have an associated error.
 1707|       |    ///
 1708|       |    /// - Parameter validation: `Validation` closure to validate the response.
 1709|       |    ///
 1710|       |    /// - Returns:              The instance.
 1711|       |    @discardableResult
 1712|      0|    public func validate(_ validation: @escaping Validation) -> Self {
 1713|      0|        let validator: () -> Void = { [unowned self] in
 1714|      0|            guard self.error == nil, let response = self.response else { return }
 1715|      0|
 1716|      0|            let result = validation(self.request, response, self.fileURL)
 1717|      0|
 1718|      0|            if case let .failure(error) = result {
 1719|      0|                self.error = error.asAFError(or: .responseValidationFailed(reason: .customValidationFailed(error: error)))
 1720|      0|            }
 1721|      0|
 1722|      0|            self.eventMonitor?.request(self,
 1723|      0|                                       didValidateRequest: self.request,
 1724|      0|                                       response: response,
 1725|      0|                                       fileURL: self.fileURL,
 1726|      0|                                       withResult: result)
 1727|      0|        }
 1728|      0|
 1729|      0|        $validators.write { $0.append(validator) }
 1730|      0|
 1731|      0|        return self
 1732|      0|    }
 1733|       |}
 1734|       |
 1735|       |// MARK: - UploadRequest
 1736|       |
 1737|       |/// `DataRequest` subclass which handles `Data` upload from memory, file, or stream using `URLSessionUploadTask`.
 1738|       |public class UploadRequest: DataRequest {
 1739|       |    /// Type describing the origin of the upload, whether `Data`, file, or stream.
 1740|       |    public enum Uploadable {
 1741|       |        /// Upload from the provided `Data` value.
 1742|       |        case data(Data)
 1743|       |        /// Upload from the provided file `URL`, as well as a `Bool` determining whether the source file should be
 1744|       |        /// automatically removed once uploaded.
 1745|       |        case file(URL, shouldRemove: Bool)
 1746|       |        /// Upload from the provided `InputStream`.
 1747|       |        case stream(InputStream)
 1748|       |    }
 1749|       |
 1750|       |    // MARK: Initial State
 1751|       |
 1752|       |    /// The `UploadableConvertible` value used to produce the `Uploadable` value for this instance.
 1753|       |    public let upload: UploadableConvertible
 1754|       |
 1755|       |    /// `FileManager` used to perform cleanup tasks, including the removal of multipart form encoded payloads written
 1756|       |    /// to disk.
 1757|       |    public let fileManager: FileManager
 1758|       |
 1759|       |    // MARK: Mutable State
 1760|       |
 1761|       |    /// `Uploadable` value used by the instance.
 1762|       |    public var uploadable: Uploadable?
 1763|       |
 1764|       |    /// Creates an `UploadRequest` using the provided parameters.
 1765|       |    ///
 1766|       |    /// - Parameters:
 1767|       |    ///   - id:                 `UUID` used for the `Hashable` and `Equatable` implementations. `UUID()` by default.
 1768|       |    ///   - convertible:        `UploadConvertible` value used to determine the type of upload to be performed.
 1769|       |    ///   - underlyingQueue:    `DispatchQueue` on which all internal `Request` work is performed.
 1770|       |    ///   - serializationQueue: `DispatchQueue` on which all serialization work is performed. By default targets
 1771|       |    ///                         `underlyingQueue`, but can be passed another queue from a `Session`.
 1772|       |    ///   - eventMonitor:       `EventMonitor` called for event callbacks from internal `Request` actions.
 1773|       |    ///   - interceptor:        `RequestInterceptor` used throughout the request lifecycle.
 1774|       |    ///   - delegate:           `RequestDelegate` that provides an interface to actions not performed by the `Request`.
 1775|       |    init(id: UUID = UUID(),
 1776|       |         convertible: UploadConvertible,
 1777|       |         underlyingQueue: DispatchQueue,
 1778|       |         serializationQueue: DispatchQueue,
 1779|       |         eventMonitor: EventMonitor?,
 1780|       |         interceptor: RequestInterceptor?,
 1781|       |         fileManager: FileManager,
 1782|      0|         delegate: RequestDelegate) {
 1783|      0|        upload = convertible
 1784|      0|        self.fileManager = fileManager
 1785|      0|
 1786|      0|        super.init(id: id,
 1787|      0|                   convertible: convertible,
 1788|      0|                   underlyingQueue: underlyingQueue,
 1789|      0|                   serializationQueue: serializationQueue,
 1790|      0|                   eventMonitor: eventMonitor,
 1791|      0|                   interceptor: interceptor,
 1792|      0|                   delegate: delegate)
 1793|      0|    }
 1794|       |
 1795|       |    /// Called when the `Uploadable` value has been created from the `UploadConvertible`.
 1796|       |    ///
 1797|       |    /// - Parameter uploadable: The `Uploadable` that was created.
 1798|      0|    func didCreateUploadable(_ uploadable: Uploadable) {
 1799|      0|        self.uploadable = uploadable
 1800|      0|
 1801|      0|        eventMonitor?.request(self, didCreateUploadable: uploadable)
 1802|      0|    }
 1803|       |
 1804|       |    /// Called when the `Uploadable` value could not be created.
 1805|       |    ///
 1806|       |    /// - Parameter error: `AFError` produced by the failure.
 1807|      0|    func didFailToCreateUploadable(with error: AFError) {
 1808|      0|        self.error = error
 1809|      0|
 1810|      0|        eventMonitor?.request(self, didFailToCreateUploadableWithError: error)
 1811|      0|
 1812|      0|        retryOrFinish(error: error)
 1813|      0|    }
 1814|       |
 1815|      0|    override func task(for request: URLRequest, using session: URLSession) -> URLSessionTask {
 1816|      0|        guard let uploadable = uploadable else {
 1817|      0|            fatalError("Attempting to create a URLSessionUploadTask when Uploadable value doesn't exist.")
 1818|      0|        }
 1819|      0|
 1820|      0|        switch uploadable {
 1821|      0|        case let .data(data): return session.uploadTask(with: request, from: data)
 1822|      0|        case let .file(url, _): return session.uploadTask(with: request, fromFile: url)
 1823|      0|        case .stream: return session.uploadTask(withStreamedRequest: request)
 1824|      0|        }
 1825|      0|    }
 1826|       |
 1827|      0|    override func reset() {
 1828|      0|        // Uploadable must be recreated on every retry.
 1829|      0|        uploadable = nil
 1830|      0|
 1831|      0|        super.reset()
 1832|      0|    }
 1833|       |
 1834|       |    /// Produces the `InputStream` from `uploadable`, if it can.
 1835|       |    ///
 1836|       |    /// - Note: Calling this method with a non-`.stream` `Uploadable` is a logic error and will crash.
 1837|       |    ///
 1838|       |    /// - Returns: The `InputStream`.
 1839|      0|    func inputStream() -> InputStream {
 1840|      0|        guard let uploadable = uploadable else {
 1841|      0|            fatalError("Attempting to access the input stream but the uploadable doesn't exist.")
 1842|      0|        }
 1843|      0|
 1844|      0|        guard case let .stream(stream) = uploadable else {
 1845|      0|            fatalError("Attempted to access the stream of an UploadRequest that wasn't created with one.")
 1846|      0|        }
 1847|      0|
 1848|      0|        eventMonitor?.request(self, didProvideInputStream: stream)
 1849|      0|
 1850|      0|        return stream
 1851|      0|    }
 1852|       |
 1853|      0|    override public func cleanup() {
 1854|      0|        defer { super.cleanup() }
 1855|      0|
 1856|      0|        guard
 1857|      0|            let uploadable = self.uploadable,
 1858|      0|            case let .file(url, shouldRemove) = uploadable,
 1859|      0|            shouldRemove
 1860|      0|        else { return }
 1861|      0|
 1862|      0|        try? fileManager.removeItem(at: url)
 1863|      0|    }
 1864|       |}
 1865|       |
 1866|       |/// A type that can produce an `UploadRequest.Uploadable` value.
 1867|       |public protocol UploadableConvertible {
 1868|       |    /// Produces an `UploadRequest.Uploadable` value from the instance.
 1869|       |    ///
 1870|       |    /// - Returns: The `UploadRequest.Uploadable`.
 1871|       |    /// - Throws:  Any `Error` produced during creation.
 1872|       |    func createUploadable() throws -> UploadRequest.Uploadable
 1873|       |}
 1874|       |
 1875|       |extension UploadRequest.Uploadable: UploadableConvertible {
 1876|      0|    public func createUploadable() throws -> UploadRequest.Uploadable {
 1877|      0|        self
 1878|      0|    }
 1879|       |}
 1880|       |
 1881|       |/// A type that can be converted to an upload, whether from an `UploadRequest.Uploadable` or `URLRequestConvertible`.
 1882|       |public protocol UploadConvertible: UploadableConvertible & URLRequestConvertible {}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/RequestInterceptor.swift:
    1|       |//
    2|       |//  RequestInterceptor.swift
    3|       |//
    4|       |//  Copyright (c) 2019 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A type that can inspect and optionally adapt a `URLRequest` in some manner if necessary.
   28|       |public protocol RequestAdapter {
   29|       |    /// Inspects and adapts the specified `URLRequest` in some manner and calls the completion handler with the Result.
   30|       |    ///
   31|       |    /// - Parameters:
   32|       |    ///   - urlRequest: The `URLRequest` to adapt.
   33|       |    ///   - session:    The `Session` that will execute the `URLRequest`.
   34|       |    ///   - completion: The completion handler that must be called when adaptation is complete.
   35|       |    func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (Result<URLRequest, Error>) -> Void)
   36|       |}
   37|       |
   38|       |// MARK: -
   39|       |
   40|       |/// Outcome of determination whether retry is necessary.
   41|       |public enum RetryResult {
   42|       |    /// Retry should be attempted immediately.
   43|       |    case retry
   44|       |    /// Retry should be attempted after the associated `TimeInterval`.
   45|       |    case retryWithDelay(TimeInterval)
   46|       |    /// Do not retry.
   47|       |    case doNotRetry
   48|       |    /// Do not retry due to the associated `Error`.
   49|       |    case doNotRetryWithError(Error)
   50|       |}
   51|       |
   52|       |extension RetryResult {
   53|      0|    var retryRequired: Bool {
   54|      0|        switch self {
   55|      0|        case .retry, .retryWithDelay: return true
   56|      0|        default: return false
   57|      0|        }
   58|      0|    }
   59|       |
   60|      0|    var delay: TimeInterval? {
   61|      0|        switch self {
   62|      0|        case let .retryWithDelay(delay): return delay
   63|      0|        default: return nil
   64|      0|        }
   65|      0|    }
   66|       |
   67|      0|    var error: Error? {
   68|      0|        guard case let .doNotRetryWithError(error) = self else { return nil }
   69|      0|        return error
   70|      0|    }
   71|       |}
   72|       |
   73|       |/// A type that determines whether a request should be retried after being executed by the specified session manager
   74|       |/// and encountering an error.
   75|       |public protocol RequestRetrier {
   76|       |    /// Determines whether the `Request` should be retried by calling the `completion` closure.
   77|       |    ///
   78|       |    /// This operation is fully asynchronous. Any amount of time can be taken to determine whether the request needs
   79|       |    /// to be retried. The one requirement is that the completion closure is called to ensure the request is properly
   80|       |    /// cleaned up after.
   81|       |    ///
   82|       |    /// - Parameters:
   83|       |    ///   - request:    `Request` that failed due to the provided `Error`.
   84|       |    ///   - session:    `Session` that produced the `Request`.
   85|       |    ///   - error:      `Error` encountered while executing the `Request`.
   86|       |    ///   - completion: Completion closure to be executed when a retry decision has been determined.
   87|       |    func retry(_ request: Request, for session: Session, dueTo error: Error, completion: @escaping (RetryResult) -> Void)
   88|       |}
   89|       |
   90|       |// MARK: -
   91|       |
   92|       |/// Type that provides both `RequestAdapter` and `RequestRetrier` functionality.
   93|       |public protocol RequestInterceptor: RequestAdapter, RequestRetrier {}
   94|       |
   95|       |extension RequestInterceptor {
   96|      0|    public func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (Result<URLRequest, Error>) -> Void) {
   97|      0|        completion(.success(urlRequest))
   98|      0|    }
   99|       |
  100|       |    public func retry(_ request: Request,
  101|       |                      for session: Session,
  102|       |                      dueTo error: Error,
  103|      0|                      completion: @escaping (RetryResult) -> Void) {
  104|      0|        completion(.doNotRetry)
  105|      0|    }
  106|       |}
  107|       |
  108|       |/// `RequestAdapter` closure definition.
  109|       |public typealias AdaptHandler = (URLRequest, Session, _ completion: @escaping (Result<URLRequest, Error>) -> Void) -> Void
  110|       |/// `RequestRetrier` closure definition.
  111|       |public typealias RetryHandler = (Request, Session, Error, _ completion: @escaping (RetryResult) -> Void) -> Void
  112|       |
  113|       |// MARK: -
  114|       |
  115|       |/// Closure-based `RequestAdapter`.
  116|       |open class Adapter: RequestInterceptor {
  117|       |    private let adaptHandler: AdaptHandler
  118|       |
  119|       |    /// Creates an instance using the provided closure.
  120|       |    ///
  121|       |    /// - Parameter adaptHandler: `AdaptHandler` closure to be executed when handling request adaptation.
  122|      0|    public init(_ adaptHandler: @escaping AdaptHandler) {
  123|      0|        self.adaptHandler = adaptHandler
  124|      0|    }
  125|       |
  126|      0|    open func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (Result<URLRequest, Error>) -> Void) {
  127|      0|        adaptHandler(urlRequest, session, completion)
  128|      0|    }
  129|       |}
  130|       |
  131|       |// MARK: -
  132|       |
  133|       |/// Closure-based `RequestRetrier`.
  134|       |open class Retrier: RequestInterceptor {
  135|       |    private let retryHandler: RetryHandler
  136|       |
  137|       |    /// Creates an instance using the provided closure.
  138|       |    ///
  139|       |    /// - Parameter retryHandler: `RetryHandler` closure to be executed when handling request retry.
  140|      0|    public init(_ retryHandler: @escaping RetryHandler) {
  141|      0|        self.retryHandler = retryHandler
  142|      0|    }
  143|       |
  144|       |    open func retry(_ request: Request,
  145|       |                    for session: Session,
  146|       |                    dueTo error: Error,
  147|      0|                    completion: @escaping (RetryResult) -> Void) {
  148|      0|        retryHandler(request, session, error, completion)
  149|      0|    }
  150|       |}
  151|       |
  152|       |// MARK: -
  153|       |
  154|       |/// `RequestInterceptor` which can use multiple `RequestAdapter` and `RequestRetrier` values.
  155|       |open class Interceptor: RequestInterceptor {
  156|       |    /// All `RequestAdapter`s associated with the instance. These adapters will be run until one fails.
  157|       |    public let adapters: [RequestAdapter]
  158|       |    /// All `RequestRetrier`s associated with the instance. These retriers will be run one at a time until one triggers retry.
  159|       |    public let retriers: [RequestRetrier]
  160|       |
  161|       |    /// Creates an instance from `AdaptHandler` and `RetryHandler` closures.
  162|       |    ///
  163|       |    /// - Parameters:
  164|       |    ///   - adaptHandler: `AdaptHandler` closure to be used.
  165|       |    ///   - retryHandler: `RetryHandler` closure to be used.
  166|      0|    public init(adaptHandler: @escaping AdaptHandler, retryHandler: @escaping RetryHandler) {
  167|      0|        adapters = [Adapter(adaptHandler)]
  168|      0|        retriers = [Retrier(retryHandler)]
  169|      0|    }
  170|       |
  171|       |    /// Creates an instance from `RequestAdapter` and `RequestRetrier` values.
  172|       |    ///
  173|       |    /// - Parameters:
  174|       |    ///   - adapter: `RequestAdapter` value to be used.
  175|       |    ///   - retrier: `RequestRetrier` value to be used.
  176|      0|    public init(adapter: RequestAdapter, retrier: RequestRetrier) {
  177|      0|        adapters = [adapter]
  178|      0|        retriers = [retrier]
  179|      0|    }
  180|       |
  181|       |    /// Creates an instance from the arrays of `RequestAdapter` and `RequestRetrier` values.
  182|       |    ///
  183|       |    /// - Parameters:
  184|       |    ///   - adapters:     `RequestAdapter` values to be used.
  185|       |    ///   - retriers:     `RequestRetrier` values to be used.
  186|       |    ///   - interceptors: `RequestInterceptor`s to be used.
  187|      0|    public init(adapters: [RequestAdapter] = [], retriers: [RequestRetrier] = [], interceptors: [RequestInterceptor] = []) {
  188|      0|        self.adapters = adapters + interceptors
  189|      0|        self.retriers = retriers + interceptors
  190|      0|    }
  191|       |
  192|      0|    open func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (Result<URLRequest, Error>) -> Void) {
  193|      0|        adapt(urlRequest, for: session, using: adapters, completion: completion)
  194|      0|    }
  195|       |
  196|       |    private func adapt(_ urlRequest: URLRequest,
  197|       |                       for session: Session,
  198|       |                       using adapters: [RequestAdapter],
  199|      0|                       completion: @escaping (Result<URLRequest, Error>) -> Void) {
  200|      0|        var pendingAdapters = adapters
  201|      0|
  202|      0|        guard !pendingAdapters.isEmpty else { completion(.success(urlRequest)); return }
  203|      0|
  204|      0|        let adapter = pendingAdapters.removeFirst()
  205|      0|
  206|      0|        adapter.adapt(urlRequest, for: session) { result in
  207|      0|            switch result {
  208|      0|            case let .success(urlRequest):
  209|      0|                self.adapt(urlRequest, for: session, using: pendingAdapters, completion: completion)
  210|      0|            case .failure:
  211|      0|                completion(result)
  212|      0|            }
  213|      0|        }
  214|      0|    }
  215|       |
  216|       |    open func retry(_ request: Request,
  217|       |                    for session: Session,
  218|       |                    dueTo error: Error,
  219|      0|                    completion: @escaping (RetryResult) -> Void) {
  220|      0|        retry(request, for: session, dueTo: error, using: retriers, completion: completion)
  221|      0|    }
  222|       |
  223|       |    private func retry(_ request: Request,
  224|       |                       for session: Session,
  225|       |                       dueTo error: Error,
  226|       |                       using retriers: [RequestRetrier],
  227|      0|                       completion: @escaping (RetryResult) -> Void) {
  228|      0|        var pendingRetriers = retriers
  229|      0|
  230|      0|        guard !pendingRetriers.isEmpty else { completion(.doNotRetry); return }
  231|      0|
  232|      0|        let retrier = pendingRetriers.removeFirst()
  233|      0|
  234|      0|        retrier.retry(request, for: session, dueTo: error) { result in
  235|      0|            switch result {
  236|      0|            case .retry, .retryWithDelay, .doNotRetryWithError:
  237|      0|                completion(result)
  238|      0|            case .doNotRetry:
  239|      0|                // Only continue to the next retrier if retry was not triggered and no error was encountered
  240|      0|                self.retry(request, for: session, dueTo: error, using: pendingRetriers, completion: completion)
  241|      0|            }
  242|      0|        }
  243|      0|    }
  244|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/RequestTaskMap.swift:
    1|       |//
    2|       |//  RequestTaskMap.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A type that maintains a two way, one to one map of `URLSessionTask`s to `Request`s.
   28|       |struct RequestTaskMap {
   29|       |    private typealias Events = (completed: Bool, metricsGathered: Bool)
   30|       |
   31|       |    private var tasksToRequests: [URLSessionTask: Request]
   32|       |    private var requestsToTasks: [Request: URLSessionTask]
   33|       |    private var taskEvents: [URLSessionTask: Events]
   34|       |
   35|      0|    var requests: [Request] {
   36|      0|        Array(tasksToRequests.values)
   37|      0|    }
   38|       |
   39|       |    init(tasksToRequests: [URLSessionTask: Request] = [:],
   40|       |         requestsToTasks: [Request: URLSessionTask] = [:],
   41|      0|         taskEvents: [URLSessionTask: (completed: Bool, metricsGathered: Bool)] = [:]) {
   42|      0|        self.tasksToRequests = tasksToRequests
   43|      0|        self.requestsToTasks = requestsToTasks
   44|      0|        self.taskEvents = taskEvents
   45|      0|    }
   46|       |
   47|       |    subscript(_ request: Request) -> URLSessionTask? {
   48|      0|        get { requestsToTasks[request] }
   49|      0|        set {
   50|      0|            guard let newValue = newValue else {
   51|      0|                guard let task = requestsToTasks[request] else {
   52|      0|                    fatalError("RequestTaskMap consistency error: no task corresponding to request found.")
   53|      0|                }
   54|      0|
   55|      0|                requestsToTasks.removeValue(forKey: request)
   56|      0|                tasksToRequests.removeValue(forKey: task)
   57|      0|                taskEvents.removeValue(forKey: task)
   58|      0|
   59|      0|                return
   60|      0|            }
   61|      0|
   62|      0|            requestsToTasks[request] = newValue
   63|      0|            tasksToRequests[newValue] = request
   64|      0|            taskEvents[newValue] = (completed: false, metricsGathered: false)
   65|      0|        }
   66|       |    }
   67|       |
   68|       |    subscript(_ task: URLSessionTask) -> Request? {
   69|      0|        get { tasksToRequests[task] }
   70|      0|        set {
   71|      0|            guard let newValue = newValue else {
   72|      0|                guard let request = tasksToRequests[task] else {
   73|      0|                    fatalError("RequestTaskMap consistency error: no request corresponding to task found.")
   74|      0|                }
   75|      0|
   76|      0|                tasksToRequests.removeValue(forKey: task)
   77|      0|                requestsToTasks.removeValue(forKey: request)
   78|      0|                taskEvents.removeValue(forKey: task)
   79|      0|
   80|      0|                return
   81|      0|            }
   82|      0|
   83|      0|            tasksToRequests[task] = newValue
   84|      0|            requestsToTasks[newValue] = task
   85|      0|            taskEvents[task] = (completed: false, metricsGathered: false)
   86|      0|        }
   87|       |    }
   88|       |
   89|      0|    var count: Int {
   90|      0|        precondition(tasksToRequests.count == requestsToTasks.count,
   91|      0|                     "RequestTaskMap.count invalid, requests.count: \(tasksToRequests.count) != tasks.count: \(requestsToTasks.count)")
   92|      0|
   93|      0|        return tasksToRequests.count
   94|      0|    }
   95|       |
   96|      0|    var eventCount: Int {
   97|      0|        precondition(taskEvents.count == count, "RequestTaskMap.eventCount invalid, count: \(count) != taskEvents.count: \(taskEvents.count)")
   98|      0|
   99|      0|        return taskEvents.count
  100|      0|    }
  101|       |
  102|      0|    var isEmpty: Bool {
  103|      0|        precondition(tasksToRequests.isEmpty == requestsToTasks.isEmpty,
  104|      0|                     "RequestTaskMap.isEmpty invalid, requests.isEmpty: \(tasksToRequests.isEmpty) != tasks.isEmpty: \(requestsToTasks.isEmpty)")
  105|      0|
  106|      0|        return tasksToRequests.isEmpty
  107|      0|    }
  108|       |
  109|      0|    var isEventsEmpty: Bool {
  110|      0|        precondition(taskEvents.isEmpty == isEmpty, "RequestTaskMap.isEventsEmpty invalid, isEmpty: \(isEmpty) != taskEvents.isEmpty: \(taskEvents.isEmpty)")
  111|      0|
  112|      0|        return taskEvents.isEmpty
  113|      0|    }
  114|       |
  115|      0|    mutating func disassociateIfNecessaryAfterGatheringMetricsForTask(_ task: URLSessionTask) -> Bool {
  116|      0|        guard let events = taskEvents[task] else {
  117|      0|            fatalError("RequestTaskMap consistency error: no events corresponding to task found.")
  118|      0|        }
  119|      0|
  120|      0|        switch (events.completed, events.metricsGathered) {
  121|      0|        case (_, true): fatalError("RequestTaskMap consistency error: duplicate metricsGatheredForTask call.")
  122|      0|        case (false, false): taskEvents[task] = (completed: false, metricsGathered: true); return false
  123|      0|        case (true, false): self[task] = nil; return true
  124|      0|        }
  125|      0|    }
  126|       |
  127|      0|    mutating func disassociateIfNecessaryAfterCompletingTask(_ task: URLSessionTask) -> Bool {
  128|      0|        guard let events = taskEvents[task] else {
  129|      0|            fatalError("RequestTaskMap consistency error: no events corresponding to task found.")
  130|      0|        }
  131|      0|
  132|      0|        switch (events.completed, events.metricsGathered) {
  133|      0|        case (true, _): fatalError("RequestTaskMap consistency error: duplicate completionReceivedForTask call.")
  134|      0|        #if os(Linux) // Linux doesn't gather metrics, so unconditionally remove the reference and return true.
  135|      0|        default: self[task] = nil; return true
  136|      0|        #else
  137|      0|        case (false, false):
  138|      0|            if #available(macOS 10.12, iOS 10, watchOS 7, tvOS 10, *) {
  139|      0|                taskEvents[task] = (completed: true, metricsGathered: false); return false
  140|      0|            } else {
  141|      0|                // watchOS < 7 doesn't gather metrics, so unconditionally remove the reference and return true.
  142|      0|                self[task] = nil; return true
  143|      0|            }
  144|      0|        case (false, true):
  145|      0|            self[task] = nil; return true
  146|      0|        #endif
  147|      0|        }
  148|      0|    }
  149|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Response.swift:
    1|       |//
    2|       |//  Response.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Default type of `DataResponse` returned by Alamofire, with an `AFError` `Failure` type.
   28|       |public typealias AFDataResponse<Success> = DataResponse<Success, AFError>
   29|       |/// Default type of `DownloadResponse` returned by Alamofire, with an `AFError` `Failure` type.
   30|       |public typealias AFDownloadResponse<Success> = DownloadResponse<Success, AFError>
   31|       |
   32|       |/// Type used to store all values associated with a serialized response of a `DataRequest` or `UploadRequest`.
   33|       |public struct DataResponse<Success, Failure: Error> {
   34|       |    /// The URL request sent to the server.
   35|       |    public let request: URLRequest?
   36|       |
   37|       |    /// The server's response to the URL request.
   38|       |    public let response: HTTPURLResponse?
   39|       |
   40|       |    /// The data returned by the server.
   41|       |    public let data: Data?
   42|       |
   43|       |    /// The final metrics of the response.
   44|       |    ///
   45|       |    /// - Note: Due to `FB7624529`, collection of `URLSessionTaskMetrics` on watchOS is currently disabled.`
   46|       |    ///
   47|       |    public let metrics: URLSessionTaskMetrics?
   48|       |
   49|       |    /// The time taken to serialize the response.
   50|       |    public let serializationDuration: TimeInterval
   51|       |
   52|       |    /// The result of response serialization.
   53|       |    public let result: Result<Success, Failure>
   54|       |
   55|       |    /// Returns the associated value of the result if it is a success, `nil` otherwise.
   56|      0|    public var value: Success? { result.success }
   57|       |
   58|       |    /// Returns the associated error value if the result if it is a failure, `nil` otherwise.
   59|      0|    public var error: Failure? { result.failure }
   60|       |
   61|       |    /// Creates a `DataResponse` instance with the specified parameters derived from the response serialization.
   62|       |    ///
   63|       |    /// - Parameters:
   64|       |    ///   - request:               The `URLRequest` sent to the server.
   65|       |    ///   - response:              The `HTTPURLResponse` from the server.
   66|       |    ///   - data:                  The `Data` returned by the server.
   67|       |    ///   - metrics:               The `URLSessionTaskMetrics` of the `DataRequest` or `UploadRequest`.
   68|       |    ///   - serializationDuration: The duration taken by serialization.
   69|       |    ///   - result:                The `Result` of response serialization.
   70|       |    public init(request: URLRequest?,
   71|       |                response: HTTPURLResponse?,
   72|       |                data: Data?,
   73|       |                metrics: URLSessionTaskMetrics?,
   74|       |                serializationDuration: TimeInterval,
   75|      0|                result: Result<Success, Failure>) {
   76|      0|        self.request = request
   77|      0|        self.response = response
   78|      0|        self.data = data
   79|      0|        self.metrics = metrics
   80|      0|        self.serializationDuration = serializationDuration
   81|      0|        self.result = result
   82|      0|    }
   83|       |}
   84|       |
   85|       |// MARK: -
   86|       |
   87|       |extension DataResponse: CustomStringConvertible, CustomDebugStringConvertible {
   88|       |    /// The textual representation used when written to an output stream, which includes whether the result was a
   89|       |    /// success or failure.
   90|      0|    public var description: String {
   91|      0|        "\(result)"
   92|      0|    }
   93|       |
   94|       |    /// The debug textual representation used when written to an output stream, which includes (if available) a summary
   95|       |    /// of the `URLRequest`, the request's headers and body (if decodable as a `String` below 100KB); the
   96|       |    /// `HTTPURLResponse`'s status code, headers, and body; the duration of the network and serialization actions; and
   97|       |    /// the `Result` of serialization.
   98|      0|    public var debugDescription: String {
   99|      0|        guard let urlRequest = request else { return "[Request]: None\n[Result]: \(result)" }
  100|      0|
  101|      0|        let requestDescription = DebugDescription.description(of: urlRequest)
  102|      0|
  103|      0|        let responseDescription = response.map { response in
  104|      0|            let responseBodyDescription = DebugDescription.description(for: data, headers: response.headers)
  105|      0|
  106|      0|            return """
  107|      0|            \(DebugDescription.description(of: response))
  108|      0|                \(responseBodyDescription.indentingNewlines())
  109|      0|            """
  110|      0|        } ?? "[Response]: None"
  111|      0|
  112|      0|        let networkDuration = metrics.map { "\($0.taskInterval.duration)s" } ?? "None"
  113|      0|
  114|      0|        return """
  115|      0|        \(requestDescription)
  116|      0|        \(responseDescription)
  117|      0|        [Network Duration]: \(networkDuration)
  118|      0|        [Serialization Duration]: \(serializationDuration)s
  119|      0|        [Result]: \(result)
  120|      0|        """
  121|      0|    }
  122|       |}
  123|       |
  124|       |// MARK: -
  125|       |
  126|       |extension DataResponse {
  127|       |    /// Evaluates the specified closure when the result of this `DataResponse` is a success, passing the unwrapped
  128|       |    /// result value as a parameter.
  129|       |    ///
  130|       |    /// Use the `map` method with a closure that does not throw. For example:
  131|       |    ///
  132|       |    ///     let possibleData: DataResponse<Data> = ...
  133|       |    ///     let possibleInt = possibleData.map { $0.count }
  134|       |    ///
  135|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  136|       |    ///
  137|       |    /// - returns: A `DataResponse` whose result wraps the value returned by the given closure. If this instance's
  138|       |    ///            result is a failure, returns a response wrapping the same failure.
  139|      0|    public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> DataResponse<NewSuccess, Failure> {
  140|      0|        DataResponse<NewSuccess, Failure>(request: request,
  141|      0|                                          response: response,
  142|      0|                                          data: data,
  143|      0|                                          metrics: metrics,
  144|      0|                                          serializationDuration: serializationDuration,
  145|      0|                                          result: result.map(transform))
  146|      0|    }
  147|       |
  148|       |    /// Evaluates the given closure when the result of this `DataResponse` is a success, passing the unwrapped result
  149|       |    /// value as a parameter.
  150|       |    ///
  151|       |    /// Use the `tryMap` method with a closure that may throw an error. For example:
  152|       |    ///
  153|       |    ///     let possibleData: DataResponse<Data> = ...
  154|       |    ///     let possibleObject = possibleData.tryMap {
  155|       |    ///         try JSONSerialization.jsonObject(with: $0)
  156|       |    ///     }
  157|       |    ///
  158|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  159|       |    ///
  160|       |    /// - returns: A success or failure `DataResponse` depending on the result of the given closure. If this instance's
  161|       |    ///            result is a failure, returns the same failure.
  162|      0|    public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> DataResponse<NewSuccess, Error> {
  163|      0|        DataResponse<NewSuccess, Error>(request: request,
  164|      0|                                        response: response,
  165|      0|                                        data: data,
  166|      0|                                        metrics: metrics,
  167|      0|                                        serializationDuration: serializationDuration,
  168|      0|                                        result: result.tryMap(transform))
  169|      0|    }
  170|       |
  171|       |    /// Evaluates the specified closure when the `DataResponse` is a failure, passing the unwrapped error as a parameter.
  172|       |    ///
  173|       |    /// Use the `mapError` function with a closure that does not throw. For example:
  174|       |    ///
  175|       |    ///     let possibleData: DataResponse<Data> = ...
  176|       |    ///     let withMyError = possibleData.mapError { MyError.error($0) }
  177|       |    ///
  178|       |    /// - Parameter transform: A closure that takes the error of the instance.
  179|       |    ///
  180|       |    /// - Returns: A `DataResponse` instance containing the result of the transform.
  181|      0|    public func mapError<NewFailure: Error>(_ transform: (Failure) -> NewFailure) -> DataResponse<Success, NewFailure> {
  182|      0|        DataResponse<Success, NewFailure>(request: request,
  183|      0|                                          response: response,
  184|      0|                                          data: data,
  185|      0|                                          metrics: metrics,
  186|      0|                                          serializationDuration: serializationDuration,
  187|      0|                                          result: result.mapError(transform))
  188|      0|    }
  189|       |
  190|       |    /// Evaluates the specified closure when the `DataResponse` is a failure, passing the unwrapped error as a parameter.
  191|       |    ///
  192|       |    /// Use the `tryMapError` function with a closure that may throw an error. For example:
  193|       |    ///
  194|       |    ///     let possibleData: DataResponse<Data> = ...
  195|       |    ///     let possibleObject = possibleData.tryMapError {
  196|       |    ///         try someFailableFunction(taking: $0)
  197|       |    ///     }
  198|       |    ///
  199|       |    /// - Parameter transform: A throwing closure that takes the error of the instance.
  200|       |    ///
  201|       |    /// - Returns: A `DataResponse` instance containing the result of the transform.
  202|      0|    public func tryMapError<NewFailure: Error>(_ transform: (Failure) throws -> NewFailure) -> DataResponse<Success, Error> {
  203|      0|        DataResponse<Success, Error>(request: request,
  204|      0|                                     response: response,
  205|      0|                                     data: data,
  206|      0|                                     metrics: metrics,
  207|      0|                                     serializationDuration: serializationDuration,
  208|      0|                                     result: result.tryMapError(transform))
  209|      0|    }
  210|       |}
  211|       |
  212|       |// MARK: -
  213|       |
  214|       |/// Used to store all data associated with a serialized response of a download request.
  215|       |public struct DownloadResponse<Success, Failure: Error> {
  216|       |    /// The URL request sent to the server.
  217|       |    public let request: URLRequest?
  218|       |
  219|       |    /// The server's response to the URL request.
  220|       |    public let response: HTTPURLResponse?
  221|       |
  222|       |    /// The final destination URL of the data returned from the server after it is moved.
  223|       |    public let fileURL: URL?
  224|       |
  225|       |    /// The resume data generated if the request was cancelled.
  226|       |    public let resumeData: Data?
  227|       |
  228|       |    /// The final metrics of the response.
  229|       |    ///
  230|       |    /// - Note: Due to `FB7624529`, collection of `URLSessionTaskMetrics` on watchOS is currently disabled.`
  231|       |    ///
  232|       |    public let metrics: URLSessionTaskMetrics?
  233|       |
  234|       |    /// The time taken to serialize the response.
  235|       |    public let serializationDuration: TimeInterval
  236|       |
  237|       |    /// The result of response serialization.
  238|       |    public let result: Result<Success, Failure>
  239|       |
  240|       |    /// Returns the associated value of the result if it is a success, `nil` otherwise.
  241|      0|    public var value: Success? { result.success }
  242|       |
  243|       |    /// Returns the associated error value if the result if it is a failure, `nil` otherwise.
  244|      0|    public var error: Failure? { result.failure }
  245|       |
  246|       |    /// Creates a `DownloadResponse` instance with the specified parameters derived from response serialization.
  247|       |    ///
  248|       |    /// - Parameters:
  249|       |    ///   - request:               The `URLRequest` sent to the server.
  250|       |    ///   - response:              The `HTTPURLResponse` from the server.
  251|       |    ///   - temporaryURL:          The temporary destination `URL` of the data returned from the server.
  252|       |    ///   - destinationURL:        The final destination `URL` of the data returned from the server, if it was moved.
  253|       |    ///   - resumeData:            The resume `Data` generated if the request was cancelled.
  254|       |    ///   - metrics:               The `URLSessionTaskMetrics` of the `DownloadRequest`.
  255|       |    ///   - serializationDuration: The duration taken by serialization.
  256|       |    ///   - result:                The `Result` of response serialization.
  257|       |    public init(request: URLRequest?,
  258|       |                response: HTTPURLResponse?,
  259|       |                fileURL: URL?,
  260|       |                resumeData: Data?,
  261|       |                metrics: URLSessionTaskMetrics?,
  262|       |                serializationDuration: TimeInterval,
  263|      0|                result: Result<Success, Failure>) {
  264|      0|        self.request = request
  265|      0|        self.response = response
  266|      0|        self.fileURL = fileURL
  267|      0|        self.resumeData = resumeData
  268|      0|        self.metrics = metrics
  269|      0|        self.serializationDuration = serializationDuration
  270|      0|        self.result = result
  271|      0|    }
  272|       |}
  273|       |
  274|       |// MARK: -
  275|       |
  276|       |extension DownloadResponse: CustomStringConvertible, CustomDebugStringConvertible {
  277|       |    /// The textual representation used when written to an output stream, which includes whether the result was a
  278|       |    /// success or failure.
  279|      0|    public var description: String {
  280|      0|        "\(result)"
  281|      0|    }
  282|       |
  283|       |    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
  284|       |    /// response, the temporary and destination URLs, the resume data, the durations of the network and serialization
  285|       |    /// actions, and the response serialization result.
  286|      0|    public var debugDescription: String {
  287|      0|        guard let urlRequest = request else { return "[Request]: None\n[Result]: \(result)" }
  288|      0|
  289|      0|        let requestDescription = DebugDescription.description(of: urlRequest)
  290|      0|        let responseDescription = response.map(DebugDescription.description(of:)) ?? "[Response]: None"
  ------------------
  | Unexecuted instantiation: $s9Alamofire16DownloadResponseV16debugDescriptionSSvgSSSo17NSHTTPURLResponseCcAA05DebugE033_863905029ED90242D6E4F65F78661D96LLOmcfu_
  ------------------
  | Unexecuted instantiation: $s9Alamofire16DownloadResponseV16debugDescriptionSSvgSSSo17NSHTTPURLResponseCcAA05DebugE033_863905029ED90242D6E4F65F78661D96LLOmcfu_SSAFcfu0_
  ------------------
  291|      0|        let networkDuration = metrics.map { "\($0.taskInterval.duration)s" } ?? "None"
  292|      0|        let resumeDataDescription = resumeData.map { "\($0)" } ?? "None"
  293|      0|
  294|      0|        return """
  295|      0|        \(requestDescription)
  296|      0|        \(responseDescription)
  297|      0|        [File URL]: \(fileURL?.path ?? "None")
  298|      0|        [Resume Data]: \(resumeDataDescription)
  299|      0|        [Network Duration]: \(networkDuration)
  300|      0|        [Serialization Duration]: \(serializationDuration)s
  301|      0|        [Result]: \(result)
  302|      0|        """
  303|      0|    }
  304|       |}
  305|       |
  306|       |// MARK: -
  307|       |
  308|       |extension DownloadResponse {
  309|       |    /// Evaluates the given closure when the result of this `DownloadResponse` is a success, passing the unwrapped
  310|       |    /// result value as a parameter.
  311|       |    ///
  312|       |    /// Use the `map` method with a closure that does not throw. For example:
  313|       |    ///
  314|       |    ///     let possibleData: DownloadResponse<Data> = ...
  315|       |    ///     let possibleInt = possibleData.map { $0.count }
  316|       |    ///
  317|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  318|       |    ///
  319|       |    /// - returns: A `DownloadResponse` whose result wraps the value returned by the given closure. If this instance's
  320|       |    ///            result is a failure, returns a response wrapping the same failure.
  321|      0|    public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> DownloadResponse<NewSuccess, Failure> {
  322|      0|        DownloadResponse<NewSuccess, Failure>(request: request,
  323|      0|                                              response: response,
  324|      0|                                              fileURL: fileURL,
  325|      0|                                              resumeData: resumeData,
  326|      0|                                              metrics: metrics,
  327|      0|                                              serializationDuration: serializationDuration,
  328|      0|                                              result: result.map(transform))
  329|      0|    }
  330|       |
  331|       |    /// Evaluates the given closure when the result of this `DownloadResponse` is a success, passing the unwrapped
  332|       |    /// result value as a parameter.
  333|       |    ///
  334|       |    /// Use the `tryMap` method with a closure that may throw an error. For example:
  335|       |    ///
  336|       |    ///     let possibleData: DownloadResponse<Data> = ...
  337|       |    ///     let possibleObject = possibleData.tryMap {
  338|       |    ///         try JSONSerialization.jsonObject(with: $0)
  339|       |    ///     }
  340|       |    ///
  341|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  342|       |    ///
  343|       |    /// - returns: A success or failure `DownloadResponse` depending on the result of the given closure. If this
  344|       |    /// instance's result is a failure, returns the same failure.
  345|      0|    public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> DownloadResponse<NewSuccess, Error> {
  346|      0|        DownloadResponse<NewSuccess, Error>(request: request,
  347|      0|                                            response: response,
  348|      0|                                            fileURL: fileURL,
  349|      0|                                            resumeData: resumeData,
  350|      0|                                            metrics: metrics,
  351|      0|                                            serializationDuration: serializationDuration,
  352|      0|                                            result: result.tryMap(transform))
  353|      0|    }
  354|       |
  355|       |    /// Evaluates the specified closure when the `DownloadResponse` is a failure, passing the unwrapped error as a parameter.
  356|       |    ///
  357|       |    /// Use the `mapError` function with a closure that does not throw. For example:
  358|       |    ///
  359|       |    ///     let possibleData: DownloadResponse<Data> = ...
  360|       |    ///     let withMyError = possibleData.mapError { MyError.error($0) }
  361|       |    ///
  362|       |    /// - Parameter transform: A closure that takes the error of the instance.
  363|       |    ///
  364|       |    /// - Returns: A `DownloadResponse` instance containing the result of the transform.
  365|      0|    public func mapError<NewFailure: Error>(_ transform: (Failure) -> NewFailure) -> DownloadResponse<Success, NewFailure> {
  366|      0|        DownloadResponse<Success, NewFailure>(request: request,
  367|      0|                                              response: response,
  368|      0|                                              fileURL: fileURL,
  369|      0|                                              resumeData: resumeData,
  370|      0|                                              metrics: metrics,
  371|      0|                                              serializationDuration: serializationDuration,
  372|      0|                                              result: result.mapError(transform))
  373|      0|    }
  374|       |
  375|       |    /// Evaluates the specified closure when the `DownloadResponse` is a failure, passing the unwrapped error as a parameter.
  376|       |    ///
  377|       |    /// Use the `tryMapError` function with a closure that may throw an error. For example:
  378|       |    ///
  379|       |    ///     let possibleData: DownloadResponse<Data> = ...
  380|       |    ///     let possibleObject = possibleData.tryMapError {
  381|       |    ///         try someFailableFunction(taking: $0)
  382|       |    ///     }
  383|       |    ///
  384|       |    /// - Parameter transform: A throwing closure that takes the error of the instance.
  385|       |    ///
  386|       |    /// - Returns: A `DownloadResponse` instance containing the result of the transform.
  387|      0|    public func tryMapError<NewFailure: Error>(_ transform: (Failure) throws -> NewFailure) -> DownloadResponse<Success, Error> {
  388|      0|        DownloadResponse<Success, Error>(request: request,
  389|      0|                                         response: response,
  390|      0|                                         fileURL: fileURL,
  391|      0|                                         resumeData: resumeData,
  392|      0|                                         metrics: metrics,
  393|      0|                                         serializationDuration: serializationDuration,
  394|      0|                                         result: result.tryMapError(transform))
  395|      0|    }
  396|       |}
  397|       |
  398|       |private enum DebugDescription {
  399|      0|    static func description(of request: URLRequest) -> String {
  400|      0|        let requestSummary = "\(request.httpMethod!) \(request)"
  401|      0|        let requestHeadersDescription = DebugDescription.description(for: request.headers)
  402|      0|        let requestBodyDescription = DebugDescription.description(for: request.httpBody, headers: request.headers)
  403|      0|
  404|      0|        return """
  405|      0|        [Request]: \(requestSummary)
  406|      0|            \(requestHeadersDescription.indentingNewlines())
  407|      0|            \(requestBodyDescription.indentingNewlines())
  408|      0|        """
  409|      0|    }
  410|       |
  411|      0|    static func description(of response: HTTPURLResponse) -> String {
  412|      0|        """
  413|      0|        [Response]:
  414|      0|            [Status Code]: \(response.statusCode)
  415|      0|            \(DebugDescription.description(for: response.headers).indentingNewlines())
  416|      0|        """
  417|      0|    }
  418|       |
  419|      0|    static func description(for headers: HTTPHeaders) -> String {
  420|      0|        guard !headers.isEmpty else { return "[Headers]: None" }
  421|      0|
  422|      0|        let headerDescription = "\(headers.sorted())".indentingNewlines()
  423|      0|        return """
  424|      0|        [Headers]:
  425|      0|            \(headerDescription)
  426|      0|        """
  427|      0|    }
  428|       |
  429|       |    static func description(for data: Data?,
  430|       |                            headers: HTTPHeaders,
  431|       |                            allowingPrintableTypes printableTypes: [String] = ["json", "xml", "text"],
  432|      0|                            maximumLength: Int = 100_000) -> String {
  433|      0|        guard let data = data, !data.isEmpty else { return "[Body]: None" }
  434|      0|
  435|      0|        guard
  436|      0|            data.count <= maximumLength,
  437|      0|            printableTypes.compactMap({ headers["Content-Type"]?.contains($0) }).contains(true)
  438|      0|        else { return "[Body]: \(data.count) bytes" }
  439|      0|
  440|      0|        return """
  441|      0|        [Body]:
  442|      0|            \(String(decoding: data, as: UTF8.self)
  443|      0|            .trimmingCharacters(in: .whitespacesAndNewlines)
  444|      0|            .indentingNewlines())
  445|      0|        """
  446|      0|    }
  447|       |}
  448|       |
  449|       |extension String {
  450|      0|    fileprivate func indentingNewlines(by spaceCount: Int = 4) -> String {
  451|      0|        let spaces = String(repeating: " ", count: spaceCount)
  452|      0|        return replacingOccurrences(of: "\n", with: "\n\(spaces)")
  453|      0|    }
  454|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/ResponseSerialization.swift:
    1|       |//
    2|       |//  ResponseSerialization.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |// MARK: Protocols
   28|       |
   29|       |/// The type to which all data response serializers must conform in order to serialize a response.
   30|       |public protocol DataResponseSerializerProtocol {
   31|       |    /// The type of serialized object to be created.
   32|       |    associatedtype SerializedObject
   33|       |
   34|       |    /// Serialize the response `Data` into the provided type..
   35|       |    ///
   36|       |    /// - Parameters:
   37|       |    ///   - request:  `URLRequest` which was used to perform the request, if any.
   38|       |    ///   - response: `HTTPURLResponse` received from the server, if any.
   39|       |    ///   - data:     `Data` returned from the server, if any.
   40|       |    ///   - error:    `Error` produced by Alamofire or the underlying `URLSession` during the request.
   41|       |    ///
   42|       |    /// - Returns:    The `SerializedObject`.
   43|       |    /// - Throws:     Any `Error` produced during serialization.
   44|       |    func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -> SerializedObject
   45|       |}
   46|       |
   47|       |/// The type to which all download response serializers must conform in order to serialize a response.
   48|       |public protocol DownloadResponseSerializerProtocol {
   49|       |    /// The type of serialized object to be created.
   50|       |    associatedtype SerializedObject
   51|       |
   52|       |    /// Serialize the downloaded response `Data` from disk into the provided type..
   53|       |    ///
   54|       |    /// - Parameters:
   55|       |    ///   - request:  `URLRequest` which was used to perform the request, if any.
   56|       |    ///   - response: `HTTPURLResponse` received from the server, if any.
   57|       |    ///   - fileURL:  File `URL` to which the response data was downloaded.
   58|       |    ///   - error:    `Error` produced by Alamofire or the underlying `URLSession` during the request.
   59|       |    ///
   60|       |    /// - Returns:    The `SerializedObject`.
   61|       |    /// - Throws:     Any `Error` produced during serialization.
   62|       |    func serializeDownload(request: URLRequest?, response: HTTPURLResponse?, fileURL: URL?, error: Error?) throws -> SerializedObject
   63|       |}
   64|       |
   65|       |/// A serializer that can handle both data and download responses.
   66|       |public protocol ResponseSerializer: DataResponseSerializerProtocol & DownloadResponseSerializerProtocol {
   67|       |    /// `DataPreprocessor` used to prepare incoming `Data` for serialization.
   68|       |    var dataPreprocessor: DataPreprocessor { get }
   69|       |    /// `HTTPMethod`s for which empty response bodies are considered appropriate.
   70|       |    var emptyRequestMethods: Set<HTTPMethod> { get }
   71|       |    /// HTTP response codes for which empty response bodies are considered appropriate.
   72|       |    var emptyResponseCodes: Set<Int> { get }
   73|       |}
   74|       |
   75|       |/// Type used to preprocess `Data` before it handled by a serializer.
   76|       |public protocol DataPreprocessor {
   77|       |    /// Process           `Data` before it's handled by a serializer.
   78|       |    /// - Parameter data: The raw `Data` to process.
   79|       |    func preprocess(_ data: Data) throws -> Data
   80|       |}
   81|       |
   82|       |/// `DataPreprocessor` that returns passed `Data` without any transform.
   83|       |public struct PassthroughPreprocessor: DataPreprocessor {
   84|      0|    public init() {}
   85|       |
   86|      0|    public func preprocess(_ data: Data) throws -> Data { data }
   87|       |}
   88|       |
   89|       |/// `DataPreprocessor` that trims Google's typical `)]}',\n` XSSI JSON header.
   90|       |public struct GoogleXSSIPreprocessor: DataPreprocessor {
   91|      0|    public init() {}
   92|       |
   93|      0|    public func preprocess(_ data: Data) throws -> Data {
   94|      0|        (data.prefix(6) == Data(")]}',\n".utf8)) ? data.dropFirst(6) : data
   95|      0|    }
   96|       |}
   97|       |
   98|       |extension ResponseSerializer {
   99|       |    /// Default `DataPreprocessor`. `PassthroughPreprocessor` by default.
  100|      0|    public static var defaultDataPreprocessor: DataPreprocessor { PassthroughPreprocessor() }
  101|       |    /// Default `HTTPMethod`s for which empty response bodies are considered appropriate. `[.head]` by default.
  102|      0|    public static var defaultEmptyRequestMethods: Set<HTTPMethod> { [.head] }
  103|       |    /// HTTP response codes for which empty response bodies are considered appropriate. `[204, 205]` by default.
  104|      0|    public static var defaultEmptyResponseCodes: Set<Int> { [204, 205] }
  105|       |
  106|      0|    public var dataPreprocessor: DataPreprocessor { Self.defaultDataPreprocessor }
  107|      0|    public var emptyRequestMethods: Set<HTTPMethod> { Self.defaultEmptyRequestMethods }
  108|      0|    public var emptyResponseCodes: Set<Int> { Self.defaultEmptyResponseCodes }
  109|       |
  110|       |    /// Determines whether the `request` allows empty response bodies, if `request` exists.
  111|       |    ///
  112|       |    /// - Parameter request: `URLRequest` to evaluate.
  113|       |    ///
  114|       |    /// - Returns:           `Bool` representing the outcome of the evaluation, or `nil` if `request` was `nil`.
  115|      0|    public func requestAllowsEmptyResponseData(_ request: URLRequest?) -> Bool? {
  116|      0|        request.flatMap { $0.httpMethod }
  117|      0|            .flatMap(HTTPMethod.init)
  118|      0|            .map { emptyRequestMethods.contains($0) }
  119|      0|    }
  120|       |
  121|       |    /// Determines whether the `response` allows empty response bodies, if `response` exists`.
  122|       |    ///
  123|       |    /// - Parameter response: `HTTPURLResponse` to evaluate.
  124|       |    ///
  125|       |    /// - Returns:            `Bool` representing the outcome of the evaluation, or `nil` if `response` was `nil`.
  126|      0|    public func responseAllowsEmptyResponseData(_ response: HTTPURLResponse?) -> Bool? {
  127|      0|        response.flatMap { $0.statusCode }
  128|      0|            .map { emptyResponseCodes.contains($0) }
  129|      0|    }
  130|       |
  131|       |    /// Determines whether `request` and `response` allow empty response bodies.
  132|       |    ///
  133|       |    /// - Parameters:
  134|       |    ///   - request:  `URLRequest` to evaluate.
  135|       |    ///   - response: `HTTPURLResponse` to evaluate.
  136|       |    ///
  137|       |    /// - Returns:    `true` if `request` or `response` allow empty bodies, `false` otherwise.
  138|      0|    public func emptyResponseAllowed(forRequest request: URLRequest?, response: HTTPURLResponse?) -> Bool {
  139|      0|        (requestAllowsEmptyResponseData(request) == true) || (responseAllowsEmptyResponseData(response) == true)
  140|      0|    }
  141|       |}
  142|       |
  143|       |/// By default, any serializer declared to conform to both types will get file serialization for free, as it just feeds
  144|       |/// the data read from disk into the data response serializer.
  145|       |extension DownloadResponseSerializerProtocol where Self: DataResponseSerializerProtocol {
  146|      0|    public func serializeDownload(request: URLRequest?, response: HTTPURLResponse?, fileURL: URL?, error: Error?) throws -> Self.SerializedObject {
  147|      0|        guard error == nil else { throw error! }
  148|      0|
  149|      0|        guard let fileURL = fileURL else {
  150|      0|            throw AFError.responseSerializationFailed(reason: .inputFileNil)
  151|      0|        }
  152|      0|
  153|      0|        let data: Data
  154|      0|        do {
  155|      0|            data = try Data(contentsOf: fileURL)
  156|      0|        } catch {
  157|      0|            throw AFError.responseSerializationFailed(reason: .inputFileReadFailed(at: fileURL))
  158|      0|        }
  159|      0|
  160|      0|        do {
  161|      0|            return try serialize(request: request, response: response, data: data, error: error)
  162|      0|        } catch {
  163|      0|            throw error
  164|      0|        }
  165|      0|    }
  166|       |}
  167|       |
  168|       |// MARK: - Default
  169|       |
  170|       |extension DataRequest {
  171|       |    /// Adds a handler to be called once the request has finished.
  172|       |    ///
  173|       |    /// - Parameters:
  174|       |    ///   - queue:             The queue on which the completion handler is dispatched. `.main` by default.
  175|       |    ///   - completionHandler: The code to be executed once the request has finished.
  176|       |    ///
  177|       |    /// - Returns:             The request.
  178|       |    @discardableResult
  179|      0|    public func response(queue: DispatchQueue = .main, completionHandler: @escaping (AFDataResponse<Data?>) -> Void) -> Self {
  180|      0|        appendResponseSerializer {
  181|      0|            // Start work that should be on the serialization queue.
  182|      0|            let result = AFResult<Data?>(value: self.data, error: self.error)
  183|      0|            // End work that should be on the serialization queue.
  184|      0|
  185|      0|            self.underlyingQueue.async {
  186|      0|                let response = DataResponse(request: self.request,
  187|      0|                                            response: self.response,
  188|      0|                                            data: self.data,
  189|      0|                                            metrics: self.metrics,
  190|      0|                                            serializationDuration: 0,
  191|      0|                                            result: result)
  192|      0|
  193|      0|                self.eventMonitor?.request(self, didParseResponse: response)
  194|      0|
  195|      0|                self.responseSerializerDidComplete { queue.async { completionHandler(response) } }
  196|      0|            }
  197|      0|        }
  198|      0|
  199|      0|        return self
  200|      0|    }
  201|       |
  202|       |    /// Adds a handler to be called once the request has finished.
  203|       |    ///
  204|       |    /// - Parameters:
  205|       |    ///   - queue:              The queue on which the completion handler is dispatched. `.main` by default
  206|       |    ///   - responseSerializer: The response serializer responsible for serializing the request, response, and data.
  207|       |    ///   - completionHandler:  The code to be executed once the request has finished.
  208|       |    ///
  209|       |    /// - Returns:              The request.
  210|       |    @discardableResult
  211|       |    public func response<Serializer: DataResponseSerializerProtocol>(queue: DispatchQueue = .main,
  212|       |                                                                     responseSerializer: Serializer,
  213|       |                                                                     completionHandler: @escaping (AFDataResponse<Serializer.SerializedObject>) -> Void)
  214|      0|        -> Self {
  215|      0|        appendResponseSerializer {
  216|      0|            // Start work that should be on the serialization queue.
  217|      0|            let start = ProcessInfo.processInfo.systemUptime
  218|      0|            let result: AFResult<Serializer.SerializedObject> = Result {
  219|      0|                try responseSerializer.serialize(request: self.request,
  220|      0|                                                 response: self.response,
  221|      0|                                                 data: self.data,
  222|      0|                                                 error: self.error)
  223|      0|            }.mapError { error in
  224|      0|                error.asAFError(or: .responseSerializationFailed(reason: .customSerializationFailed(error: error)))
  225|      0|            }
  226|      0|
  227|      0|            let end = ProcessInfo.processInfo.systemUptime
  228|      0|            // End work that should be on the serialization queue.
  229|      0|
  230|      0|            self.underlyingQueue.async {
  231|      0|                let response = DataResponse(request: self.request,
  232|      0|                                            response: self.response,
  233|      0|                                            data: self.data,
  234|      0|                                            metrics: self.metrics,
  235|      0|                                            serializationDuration: end - start,
  236|      0|                                            result: result)
  237|      0|
  238|      0|                self.eventMonitor?.request(self, didParseResponse: response)
  239|      0|
  240|      0|                guard let serializerError = result.failure, let delegate = self.delegate else {
  241|      0|                    self.responseSerializerDidComplete { queue.async { completionHandler(response) } }
  242|      0|                    return
  243|      0|                }
  244|      0|
  245|      0|                delegate.retryResult(for: self, dueTo: serializerError) { retryResult in
  246|      0|                    var didComplete: (() -> Void)?
  247|      0|
  248|      0|                    defer {
  249|      0|                        if let didComplete = didComplete {
  250|      0|                            self.responseSerializerDidComplete { queue.async { didComplete() } }
  251|      0|                        }
  252|      0|                    }
  253|      0|
  254|      0|                    switch retryResult {
  255|      0|                    case .doNotRetry:
  256|      0|                        didComplete = { completionHandler(response) }
  257|      0|
  258|      0|                    case let .doNotRetryWithError(retryError):
  259|      0|                        let result: AFResult<Serializer.SerializedObject> = .failure(retryError.asAFError(orFailWith: "Received retryError was not already AFError"))
  260|      0|
  261|      0|                        let response = DataResponse(request: self.request,
  262|      0|                                                    response: self.response,
  263|      0|                                                    data: self.data,
  264|      0|                                                    metrics: self.metrics,
  265|      0|                                                    serializationDuration: end - start,
  266|      0|                                                    result: result)
  267|      0|
  268|      0|                        didComplete = { completionHandler(response) }
  269|      0|
  270|      0|                    case .retry, .retryWithDelay:
  271|      0|                        delegate.retryRequest(self, withDelay: retryResult.delay)
  272|      0|                    }
  273|      0|                }
  274|      0|            }
  275|      0|        }
  276|      0|
  277|      0|        return self
  278|      0|    }
  279|       |}
  280|       |
  281|       |extension DownloadRequest {
  282|       |    /// Adds a handler to be called once the request has finished.
  283|       |    ///
  284|       |    /// - Parameters:
  285|       |    ///   - queue:             The queue on which the completion handler is dispatched. `.main` by default.
  286|       |    ///   - completionHandler: The code to be executed once the request has finished.
  287|       |    ///
  288|       |    /// - Returns:             The request.
  289|       |    @discardableResult
  290|       |    public func response(queue: DispatchQueue = .main,
  291|       |                         completionHandler: @escaping (AFDownloadResponse<URL?>) -> Void)
  292|      0|        -> Self {
  293|      0|        appendResponseSerializer {
  294|      0|            // Start work that should be on the serialization queue.
  295|      0|            let result = AFResult<URL?>(value: self.fileURL, error: self.error)
  296|      0|            // End work that should be on the serialization queue.
  297|      0|
  298|      0|            self.underlyingQueue.async {
  299|      0|                let response = DownloadResponse(request: self.request,
  300|      0|                                                response: self.response,
  301|      0|                                                fileURL: self.fileURL,
  302|      0|                                                resumeData: self.resumeData,
  303|      0|                                                metrics: self.metrics,
  304|      0|                                                serializationDuration: 0,
  305|      0|                                                result: result)
  306|      0|
  307|      0|                self.eventMonitor?.request(self, didParseResponse: response)
  308|      0|
  309|      0|                self.responseSerializerDidComplete { queue.async { completionHandler(response) } }
  310|      0|            }
  311|      0|        }
  312|      0|
  313|      0|        return self
  314|      0|    }
  315|       |
  316|       |    /// Adds a handler to be called once the request has finished.
  317|       |    ///
  318|       |    /// - Parameters:
  319|       |    ///   - queue:              The queue on which the completion handler is dispatched. `.main` by default.
  320|       |    ///   - responseSerializer: The response serializer responsible for serializing the request, response, and data
  321|       |    ///                         contained in the destination `URL`.
  322|       |    ///   - completionHandler:  The code to be executed once the request has finished.
  323|       |    ///
  324|       |    /// - Returns:              The request.
  325|       |    @discardableResult
  326|       |    public func response<Serializer: DownloadResponseSerializerProtocol>(queue: DispatchQueue = .main,
  327|       |                                                                         responseSerializer: Serializer,
  328|       |                                                                         completionHandler: @escaping (AFDownloadResponse<Serializer.SerializedObject>) -> Void)
  329|      0|        -> Self {
  330|      0|        appendResponseSerializer {
  331|      0|            // Start work that should be on the serialization queue.
  332|      0|            let start = ProcessInfo.processInfo.systemUptime
  333|      0|            let result: AFResult<Serializer.SerializedObject> = Result {
  334|      0|                try responseSerializer.serializeDownload(request: self.request,
  335|      0|                                                         response: self.response,
  336|      0|                                                         fileURL: self.fileURL,
  337|      0|                                                         error: self.error)
  338|      0|            }.mapError { error in
  339|      0|                error.asAFError(or: .responseSerializationFailed(reason: .customSerializationFailed(error: error)))
  340|      0|            }
  341|      0|            let end = ProcessInfo.processInfo.systemUptime
  342|      0|            // End work that should be on the serialization queue.
  343|      0|
  344|      0|            self.underlyingQueue.async {
  345|      0|                let response = DownloadResponse(request: self.request,
  346|      0|                                                response: self.response,
  347|      0|                                                fileURL: self.fileURL,
  348|      0|                                                resumeData: self.resumeData,
  349|      0|                                                metrics: self.metrics,
  350|      0|                                                serializationDuration: end - start,
  351|      0|                                                result: result)
  352|      0|
  353|      0|                self.eventMonitor?.request(self, didParseResponse: response)
  354|      0|
  355|      0|                guard let serializerError = result.failure, let delegate = self.delegate else {
  356|      0|                    self.responseSerializerDidComplete { queue.async { completionHandler(response) } }
  357|      0|                    return
  358|      0|                }
  359|      0|
  360|      0|                delegate.retryResult(for: self, dueTo: serializerError) { retryResult in
  361|      0|                    var didComplete: (() -> Void)?
  362|      0|
  363|      0|                    defer {
  364|      0|                        if let didComplete = didComplete {
  365|      0|                            self.responseSerializerDidComplete { queue.async { didComplete() } }
  366|      0|                        }
  367|      0|                    }
  368|      0|
  369|      0|                    switch retryResult {
  370|      0|                    case .doNotRetry:
  371|      0|                        didComplete = { completionHandler(response) }
  372|      0|
  373|      0|                    case let .doNotRetryWithError(retryError):
  374|      0|                        let result: AFResult<Serializer.SerializedObject> = .failure(retryError.asAFError(orFailWith: "Received retryError was not already AFError"))
  375|      0|
  376|      0|                        let response = DownloadResponse(request: self.request,
  377|      0|                                                        response: self.response,
  378|      0|                                                        fileURL: self.fileURL,
  379|      0|                                                        resumeData: self.resumeData,
  380|      0|                                                        metrics: self.metrics,
  381|      0|                                                        serializationDuration: end - start,
  382|      0|                                                        result: result)
  383|      0|
  384|      0|                        didComplete = { completionHandler(response) }
  385|      0|
  386|      0|                    case .retry, .retryWithDelay:
  387|      0|                        delegate.retryRequest(self, withDelay: retryResult.delay)
  388|      0|                    }
  389|      0|                }
  390|      0|            }
  391|      0|        }
  392|      0|
  393|      0|        return self
  394|      0|    }
  395|       |}
  396|       |
  397|       |// MARK: - URL
  398|       |
  399|       |/// A `DownloadResponseSerializerProtocol` that performs only `Error` checking and ensures that a downloaded `fileURL`
  400|       |/// is present.
  401|       |public struct URLResponseSerializer: DownloadResponseSerializerProtocol {
  402|       |    /// Creates an instance.
  403|      0|    public init() {}
  404|       |
  405|       |    public func serializeDownload(request: URLRequest?,
  406|       |                                  response: HTTPURLResponse?,
  407|       |                                  fileURL: URL?,
  408|      0|                                  error: Error?) throws -> URL {
  409|      0|        guard error == nil else { throw error! }
  410|      0|
  411|      0|        guard let url = fileURL else {
  412|      0|            throw AFError.responseSerializationFailed(reason: .inputFileNil)
  413|      0|        }
  414|      0|
  415|      0|        return url
  416|      0|    }
  417|       |}
  418|       |
  419|       |extension DownloadRequest {
  420|       |    /// Adds a handler using a `URLResponseSerializer` to be called once the request is finished.
  421|       |    ///
  422|       |    /// - Parameters:
  423|       |    ///   - queue:             The queue on which the completion handler is called. `.main` by default.
  424|       |    ///   - completionHandler: A closure to be executed once the request has finished.
  425|       |    ///
  426|       |    /// - Returns:             The request.
  427|       |    @discardableResult
  428|       |    public func responseURL(queue: DispatchQueue = .main,
  429|      0|                            completionHandler: @escaping (AFDownloadResponse<URL>) -> Void) -> Self {
  430|      0|        response(queue: queue, responseSerializer: URLResponseSerializer(), completionHandler: completionHandler)
  431|      0|    }
  432|       |}
  433|       |
  434|       |// MARK: - Data
  435|       |
  436|       |/// A `ResponseSerializer` that performs minimal response checking and returns any response `Data` as-is. By default, a
  437|       |/// request returning `nil` or no data is considered an error. However, if the request has an `HTTPMethod` or the
  438|       |/// response has an  HTTP status code valid for empty responses, then an empty `Data` value is returned.
  439|       |public final class DataResponseSerializer: ResponseSerializer {
  440|       |    public let dataPreprocessor: DataPreprocessor
  441|       |    public let emptyResponseCodes: Set<Int>
  442|       |    public let emptyRequestMethods: Set<HTTPMethod>
  443|       |
  444|       |    /// Creates an instance using the provided values.
  445|       |    ///
  446|       |    /// - Parameters:
  447|       |    ///   - dataPreprocessor:    `DataPreprocessor` used to prepare the received `Data` for serialization.
  448|       |    ///   - emptyResponseCodes:  The HTTP response codes for which empty responses are allowed. `[204, 205]` by default.
  449|       |    ///   - emptyRequestMethods: The HTTP request methods for which empty responses are allowed. `[.head]` by default.
  450|       |    public init(dataPreprocessor: DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor,
  451|       |                emptyResponseCodes: Set<Int> = DataResponseSerializer.defaultEmptyResponseCodes,
  452|      0|                emptyRequestMethods: Set<HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) {
  453|      0|        self.dataPreprocessor = dataPreprocessor
  454|      0|        self.emptyResponseCodes = emptyResponseCodes
  455|      0|        self.emptyRequestMethods = emptyRequestMethods
  456|      0|    }
  457|       |
  458|      0|    public func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -> Data {
  459|      0|        guard error == nil else { throw error! }
  460|      0|
  461|      0|        guard var data = data, !data.isEmpty else {
  462|      0|            guard emptyResponseAllowed(forRequest: request, response: response) else {
  463|      0|                throw AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
  464|      0|            }
  465|      0|
  466|      0|            return Data()
  467|      0|        }
  468|      0|
  469|      0|        data = try dataPreprocessor.preprocess(data)
  470|      0|
  471|      0|        return data
  472|      0|    }
  473|       |}
  474|       |
  475|       |extension DataRequest {
  476|       |    /// Adds a handler using a `DataResponseSerializer` to be called once the request has finished.
  477|       |    ///
  478|       |    /// - Parameters:
  479|       |    ///   - queue:               The queue on which the completion handler is called. `.main` by default.
  480|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  481|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  482|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  483|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  484|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  485|       |    ///
  486|       |    /// - Returns:               The request.
  487|       |    @discardableResult
  488|       |    public func responseData(queue: DispatchQueue = .main,
  489|       |                             dataPreprocessor: DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor,
  490|       |                             emptyResponseCodes: Set<Int> = DataResponseSerializer.defaultEmptyResponseCodes,
  491|       |                             emptyRequestMethods: Set<HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods,
  492|      0|                             completionHandler: @escaping (AFDataResponse<Data>) -> Void) -> Self {
  493|      0|        response(queue: queue,
  494|      0|                 responseSerializer: DataResponseSerializer(dataPreprocessor: dataPreprocessor,
  495|      0|                                                            emptyResponseCodes: emptyResponseCodes,
  496|      0|                                                            emptyRequestMethods: emptyRequestMethods),
  497|      0|                 completionHandler: completionHandler)
  498|      0|    }
  499|       |}
  500|       |
  501|       |extension DownloadRequest {
  502|       |    /// Adds a handler using a `DataResponseSerializer` to be called once the request has finished.
  503|       |    ///
  504|       |    /// - Parameters:
  505|       |    ///   - queue:               The queue on which the completion handler is called. `.main` by default.
  506|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  507|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  508|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  509|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  510|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  511|       |    ///
  512|       |    /// - Returns:               The request.
  513|       |    @discardableResult
  514|       |    public func responseData(queue: DispatchQueue = .main,
  515|       |                             dataPreprocessor: DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor,
  516|       |                             emptyResponseCodes: Set<Int> = DataResponseSerializer.defaultEmptyResponseCodes,
  517|       |                             emptyRequestMethods: Set<HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods,
  518|      0|                             completionHandler: @escaping (AFDownloadResponse<Data>) -> Void) -> Self {
  519|      0|        response(queue: queue,
  520|      0|                 responseSerializer: DataResponseSerializer(dataPreprocessor: dataPreprocessor,
  521|      0|                                                            emptyResponseCodes: emptyResponseCodes,
  522|      0|                                                            emptyRequestMethods: emptyRequestMethods),
  523|      0|                 completionHandler: completionHandler)
  524|      0|    }
  525|       |}
  526|       |
  527|       |// MARK: - String
  528|       |
  529|       |/// A `ResponseSerializer` that decodes the response data as a `String`. By default, a request returning `nil` or no
  530|       |/// data is considered an error. However, if the request has an `HTTPMethod` or the response has an  HTTP status code
  531|       |/// valid for empty responses, then an empty `String` is returned.
  532|       |public final class StringResponseSerializer: ResponseSerializer {
  533|       |    public let dataPreprocessor: DataPreprocessor
  534|       |    /// Optional string encoding used to validate the response.
  535|       |    public let encoding: String.Encoding?
  536|       |    public let emptyResponseCodes: Set<Int>
  537|       |    public let emptyRequestMethods: Set<HTTPMethod>
  538|       |
  539|       |    /// Creates an instance with the provided values.
  540|       |    ///
  541|       |    /// - Parameters:
  542|       |    ///   - dataPreprocessor:    `DataPreprocessor` used to prepare the received `Data` for serialization.
  543|       |    ///   - encoding:            A string encoding. Defaults to `nil`, in which case the encoding will be determined
  544|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  545|       |    ///   - emptyResponseCodes:  The HTTP response codes for which empty responses are allowed. `[204, 205]` by default.
  546|       |    ///   - emptyRequestMethods: The HTTP request methods for which empty responses are allowed. `[.head]` by default.
  547|       |    public init(dataPreprocessor: DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor,
  548|       |                encoding: String.Encoding? = nil,
  549|       |                emptyResponseCodes: Set<Int> = StringResponseSerializer.defaultEmptyResponseCodes,
  550|      0|                emptyRequestMethods: Set<HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) {
  551|      0|        self.dataPreprocessor = dataPreprocessor
  552|      0|        self.encoding = encoding
  553|      0|        self.emptyResponseCodes = emptyResponseCodes
  554|      0|        self.emptyRequestMethods = emptyRequestMethods
  555|      0|    }
  556|       |
  557|      0|    public func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -> String {
  558|      0|        guard error == nil else { throw error! }
  559|      0|
  560|      0|        guard var data = data, !data.isEmpty else {
  561|      0|            guard emptyResponseAllowed(forRequest: request, response: response) else {
  562|      0|                throw AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
  563|      0|            }
  564|      0|
  565|      0|            return ""
  566|      0|        }
  567|      0|
  568|      0|        data = try dataPreprocessor.preprocess(data)
  569|      0|
  570|      0|        var convertedEncoding = encoding
  571|      0|
  572|      0|        if let encodingName = response?.textEncodingName, convertedEncoding == nil {
  573|      0|            convertedEncoding = String.Encoding(ianaCharsetName: encodingName)
  574|      0|        }
  575|      0|
  576|      0|        let actualEncoding = convertedEncoding ?? .isoLatin1
  577|      0|
  578|      0|        guard let string = String(data: data, encoding: actualEncoding) else {
  579|      0|            throw AFError.responseSerializationFailed(reason: .stringSerializationFailed(encoding: actualEncoding))
  580|      0|        }
  581|      0|
  582|      0|        return string
  583|      0|    }
  584|       |}
  585|       |
  586|       |extension DataRequest {
  587|       |    /// Adds a handler using a `StringResponseSerializer` to be called once the request has finished.
  588|       |    ///
  589|       |    /// - Parameters:
  590|       |    ///   - queue:               The queue on which the completion handler is dispatched. `.main` by default.
  591|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  592|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  593|       |    ///   - encoding:            The string encoding. Defaults to `nil`, in which case the encoding will be determined
  594|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  595|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  596|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  597|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  598|       |    ///
  599|       |    /// - Returns:               The request.
  600|       |    @discardableResult
  601|       |    public func responseString(queue: DispatchQueue = .main,
  602|       |                               dataPreprocessor: DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor,
  603|       |                               encoding: String.Encoding? = nil,
  604|       |                               emptyResponseCodes: Set<Int> = StringResponseSerializer.defaultEmptyResponseCodes,
  605|       |                               emptyRequestMethods: Set<HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods,
  606|      0|                               completionHandler: @escaping (AFDataResponse<String>) -> Void) -> Self {
  607|      0|        response(queue: queue,
  608|      0|                 responseSerializer: StringResponseSerializer(dataPreprocessor: dataPreprocessor,
  609|      0|                                                              encoding: encoding,
  610|      0|                                                              emptyResponseCodes: emptyResponseCodes,
  611|      0|                                                              emptyRequestMethods: emptyRequestMethods),
  612|      0|                 completionHandler: completionHandler)
  613|      0|    }
  614|       |}
  615|       |
  616|       |extension DownloadRequest {
  617|       |    /// Adds a handler using a `StringResponseSerializer` to be called once the request has finished.
  618|       |    ///
  619|       |    /// - Parameters:
  620|       |    ///   - queue:               The queue on which the completion handler is dispatched. `.main` by default.
  621|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  622|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  623|       |    ///   - encoding:            The string encoding. Defaults to `nil`, in which case the encoding will be determined
  624|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  625|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  626|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  627|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  628|       |    ///
  629|       |    /// - Returns:               The request.
  630|       |    @discardableResult
  631|       |    public func responseString(queue: DispatchQueue = .main,
  632|       |                               dataPreprocessor: DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor,
  633|       |                               encoding: String.Encoding? = nil,
  634|       |                               emptyResponseCodes: Set<Int> = StringResponseSerializer.defaultEmptyResponseCodes,
  635|       |                               emptyRequestMethods: Set<HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods,
  636|      0|                               completionHandler: @escaping (AFDownloadResponse<String>) -> Void) -> Self {
  637|      0|        response(queue: queue,
  638|      0|                 responseSerializer: StringResponseSerializer(dataPreprocessor: dataPreprocessor,
  639|      0|                                                              encoding: encoding,
  640|      0|                                                              emptyResponseCodes: emptyResponseCodes,
  641|      0|                                                              emptyRequestMethods: emptyRequestMethods),
  642|      0|                 completionHandler: completionHandler)
  643|      0|    }
  644|       |}
  645|       |
  646|       |// MARK: - JSON
  647|       |
  648|       |/// A `ResponseSerializer` that decodes the response data using `JSONSerialization`. By default, a request returning
  649|       |/// `nil` or no data is considered an error. However, if the request has an `HTTPMethod` or the response has an
  650|       |/// HTTP status code valid for empty responses, then an `NSNull` value is returned.
  651|       |public final class JSONResponseSerializer: ResponseSerializer {
  652|       |    public let dataPreprocessor: DataPreprocessor
  653|       |    public let emptyResponseCodes: Set<Int>
  654|       |    public let emptyRequestMethods: Set<HTTPMethod>
  655|       |    /// `JSONSerialization.ReadingOptions` used when serializing a response.
  656|       |    public let options: JSONSerialization.ReadingOptions
  657|       |
  658|       |    /// Creates an instance with the provided values.
  659|       |    ///
  660|       |    /// - Parameters:
  661|       |    ///   - dataPreprocessor:    `DataPreprocessor` used to prepare the received `Data` for serialization.
  662|       |    ///   - emptyResponseCodes:  The HTTP response codes for which empty responses are allowed. `[204, 205]` by default.
  663|       |    ///   - emptyRequestMethods: The HTTP request methods for which empty responses are allowed. `[.head]` by default.
  664|       |    ///   - options:             The options to use. `.allowFragments` by default.
  665|       |    public init(dataPreprocessor: DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor,
  666|       |                emptyResponseCodes: Set<Int> = JSONResponseSerializer.defaultEmptyResponseCodes,
  667|       |                emptyRequestMethods: Set<HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods,
  668|      0|                options: JSONSerialization.ReadingOptions = .allowFragments) {
  669|      0|        self.dataPreprocessor = dataPreprocessor
  670|      0|        self.emptyResponseCodes = emptyResponseCodes
  671|      0|        self.emptyRequestMethods = emptyRequestMethods
  672|      0|        self.options = options
  673|      0|    }
  674|       |
  675|      0|    public func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -> Any {
  676|      0|        guard error == nil else { throw error! }
  677|      0|
  678|      0|        guard var data = data, !data.isEmpty else {
  679|      0|            guard emptyResponseAllowed(forRequest: request, response: response) else {
  680|      0|                throw AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
  681|      0|            }
  682|      0|
  683|      0|            return NSNull()
  684|      0|        }
  685|      0|
  686|      0|        data = try dataPreprocessor.preprocess(data)
  687|      0|
  688|      0|        do {
  689|      0|            return try JSONSerialization.jsonObject(with: data, options: options)
  690|      0|        } catch {
  691|      0|            throw AFError.responseSerializationFailed(reason: .jsonSerializationFailed(error: error))
  692|      0|        }
  693|      0|    }
  694|       |}
  695|       |
  696|       |extension DataRequest {
  697|       |    /// Adds a handler using a `JSONResponseSerializer` to be called once the request has finished.
  698|       |    ///
  699|       |    /// - Parameters:
  700|       |    ///   - queue:               The queue on which the completion handler is dispatched. `.main` by default.
  701|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  702|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  703|       |    ///   - encoding:            The string encoding. Defaults to `nil`, in which case the encoding will be determined
  704|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  705|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  706|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  707|       |    ///   - options:             `JSONSerialization.ReadingOptions` used when parsing the response. `.allowFragments`
  708|       |    ///                          by default.
  709|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  710|       |    ///
  711|       |    /// - Returns:               The request.
  712|       |    @discardableResult
  713|       |    public func responseJSON(queue: DispatchQueue = .main,
  714|       |                             dataPreprocessor: DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor,
  715|       |                             emptyResponseCodes: Set<Int> = JSONResponseSerializer.defaultEmptyResponseCodes,
  716|       |                             emptyRequestMethods: Set<HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods,
  717|       |                             options: JSONSerialization.ReadingOptions = .allowFragments,
  718|      0|                             completionHandler: @escaping (AFDataResponse<Any>) -> Void) -> Self {
  719|      0|        response(queue: queue,
  720|      0|                 responseSerializer: JSONResponseSerializer(dataPreprocessor: dataPreprocessor,
  721|      0|                                                            emptyResponseCodes: emptyResponseCodes,
  722|      0|                                                            emptyRequestMethods: emptyRequestMethods,
  723|      0|                                                            options: options),
  724|      0|                 completionHandler: completionHandler)
  725|      0|    }
  726|       |}
  727|       |
  728|       |extension DownloadRequest {
  729|       |    /// Adds a handler using a `JSONResponseSerializer` to be called once the request has finished.
  730|       |    ///
  731|       |    /// - Parameters:
  732|       |    ///   - queue:               The queue on which the completion handler is dispatched. `.main` by default.
  733|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  734|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  735|       |    ///   - encoding:            The string encoding. Defaults to `nil`, in which case the encoding will be determined
  736|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  737|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  738|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  739|       |    ///   - options:             `JSONSerialization.ReadingOptions` used when parsing the response. `.allowFragments`
  740|       |    ///                          by default.
  741|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  742|       |    ///
  743|       |    /// - Returns:               The request.
  744|       |    @discardableResult
  745|       |    public func responseJSON(queue: DispatchQueue = .main,
  746|       |                             dataPreprocessor: DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor,
  747|       |                             emptyResponseCodes: Set<Int> = JSONResponseSerializer.defaultEmptyResponseCodes,
  748|       |                             emptyRequestMethods: Set<HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods,
  749|       |                             options: JSONSerialization.ReadingOptions = .allowFragments,
  750|      0|                             completionHandler: @escaping (AFDownloadResponse<Any>) -> Void) -> Self {
  751|      0|        response(queue: queue,
  752|      0|                 responseSerializer: JSONResponseSerializer(dataPreprocessor: dataPreprocessor,
  753|      0|                                                            emptyResponseCodes: emptyResponseCodes,
  754|      0|                                                            emptyRequestMethods: emptyRequestMethods,
  755|      0|                                                            options: options),
  756|      0|                 completionHandler: completionHandler)
  757|      0|    }
  758|       |}
  759|       |
  760|       |// MARK: - Empty
  761|       |
  762|       |/// Protocol representing an empty response. Use `T.emptyValue()` to get an instance.
  763|       |public protocol EmptyResponse {
  764|       |    /// Empty value for the conforming type.
  765|       |    ///
  766|       |    /// - Returns: Value of `Self` to use for empty values.
  767|       |    static func emptyValue() -> Self
  768|       |}
  769|       |
  770|       |/// Type representing an empty value. Use `Empty.value` to get the static instance.
  771|       |public struct Empty: Codable {
  772|       |    /// Static `Empty` instance used for all `Empty` responses.
  773|       |    public static let value = Empty()
  774|       |}
  775|       |
  776|       |extension Empty: EmptyResponse {
  777|      0|    public static func emptyValue() -> Empty {
  778|      0|        value
  779|      0|    }
  780|       |}
  781|       |
  782|       |// MARK: - DataDecoder Protocol
  783|       |
  784|       |/// Any type which can decode `Data` into a `Decodable` type.
  785|       |public protocol DataDecoder {
  786|       |    /// Decode `Data` into the provided type.
  787|       |    ///
  788|       |    /// - Parameters:
  789|       |    ///   - type:  The `Type` to be decoded.
  790|       |    ///   - data:  The `Data` to be decoded.
  791|       |    ///
  792|       |    /// - Returns: The decoded value of type `D`.
  793|       |    /// - Throws:  Any error that occurs during decode.
  794|       |    func decode<D: Decodable>(_ type: D.Type, from data: Data) throws -> D
  795|       |}
  796|       |
  797|       |/// `JSONDecoder` automatically conforms to `DataDecoder`.
  798|       |extension JSONDecoder: DataDecoder {}
  799|       |/// `PropertyListDecoder` automatically conforms to `DataDecoder`.
  800|       |extension PropertyListDecoder: DataDecoder {}
  801|       |
  802|       |// MARK: - Decodable
  803|       |
  804|       |/// A `ResponseSerializer` that decodes the response data as a generic value using any type that conforms to
  805|       |/// `DataDecoder`. By default, this is an instance of `JSONDecoder`. Additionally, a request returning `nil` or no data
  806|       |/// is considered an error. However, if the request has an `HTTPMethod` or the response has an HTTP status code valid
  807|       |/// for empty responses then an empty value will be returned. If the decoded type conforms to `EmptyResponse`, the
  808|       |/// type's `emptyValue()` will be returned. If the decoded type is `Empty`, the `.value` instance is returned. If the
  809|       |/// decoded type *does not* conform to `EmptyResponse` and isn't `Empty`, an error will be produced.
  810|       |public final class DecodableResponseSerializer<T: Decodable>: ResponseSerializer {
  811|       |    public let dataPreprocessor: DataPreprocessor
  812|       |    /// The `DataDecoder` instance used to decode responses.
  813|       |    public let decoder: DataDecoder
  814|       |    public let emptyResponseCodes: Set<Int>
  815|       |    public let emptyRequestMethods: Set<HTTPMethod>
  816|       |
  817|       |    /// Creates an instance using the values provided.
  818|       |    ///
  819|       |    /// - Parameters:
  820|       |    ///   - dataPreprocessor:    `DataPreprocessor` used to prepare the received `Data` for serialization.
  821|       |    ///   - decoder:             The `DataDecoder`. `JSONDecoder()` by default.
  822|       |    ///   - emptyResponseCodes:  The HTTP response codes for which empty responses are allowed. `[204, 205]` by default.
  823|       |    ///   - emptyRequestMethods: The HTTP request methods for which empty responses are allowed. `[.head]` by default.
  824|       |    public init(dataPreprocessor: DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor,
  825|       |                decoder: DataDecoder = JSONDecoder(),
  826|       |                emptyResponseCodes: Set<Int> = DecodableResponseSerializer.defaultEmptyResponseCodes,
  827|      0|                emptyRequestMethods: Set<HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods) {
  828|      0|        self.dataPreprocessor = dataPreprocessor
  829|      0|        self.decoder = decoder
  830|      0|        self.emptyResponseCodes = emptyResponseCodes
  831|      0|        self.emptyRequestMethods = emptyRequestMethods
  832|      0|    }
  833|       |
  834|      0|    public func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -> T {
  835|      0|        guard error == nil else { throw error! }
  836|      0|
  837|      0|        guard var data = data, !data.isEmpty else {
  838|      0|            guard emptyResponseAllowed(forRequest: request, response: response) else {
  839|      0|                throw AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
  840|      0|            }
  841|      0|
  842|      0|            guard let emptyResponseType = T.self as? EmptyResponse.Type, let emptyValue = emptyResponseType.emptyValue() as? T else {
  843|      0|                throw AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: "\(T.self)"))
  844|      0|            }
  845|      0|
  846|      0|            return emptyValue
  847|      0|        }
  848|      0|
  849|      0|        data = try dataPreprocessor.preprocess(data)
  850|      0|
  851|      0|        do {
  852|      0|            return try decoder.decode(T.self, from: data)
  853|      0|        } catch {
  854|      0|            throw AFError.responseSerializationFailed(reason: .decodingFailed(error: error))
  855|      0|        }
  856|      0|    }
  857|       |}
  858|       |
  859|       |extension DataRequest {
  860|       |    /// Adds a handler using a `DecodableResponseSerializer` to be called once the request has finished.
  861|       |    ///
  862|       |    /// - Parameters:
  863|       |    ///   - type:                `Decodable` type to decode from response data.
  864|       |    ///   - queue:               The queue on which the completion handler is dispatched. `.main` by default.
  865|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  866|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  867|       |    ///   - decoder:             `DataDecoder` to use to decode the response. `JSONDecoder()` by default.
  868|       |    ///   - encoding:            The string encoding. Defaults to `nil`, in which case the encoding will be determined
  869|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  870|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  871|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  872|       |    ///   - options:             `JSONSerialization.ReadingOptions` used when parsing the response. `.allowFragments`
  873|       |    ///                          by default.
  874|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  875|       |    ///
  876|       |    /// - Returns:               The request.
  877|       |    @discardableResult
  878|       |    public func responseDecodable<T: Decodable>(of type: T.Type = T.self,
  879|       |                                                queue: DispatchQueue = .main,
  880|       |                                                dataPreprocessor: DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor,
  881|       |                                                decoder: DataDecoder = JSONDecoder(),
  882|       |                                                emptyResponseCodes: Set<Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes,
  883|       |                                                emptyRequestMethods: Set<HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods,
  884|      0|                                                completionHandler: @escaping (AFDataResponse<T>) -> Void) -> Self {
  885|      0|        response(queue: queue,
  886|      0|                 responseSerializer: DecodableResponseSerializer(dataPreprocessor: dataPreprocessor,
  887|      0|                                                                 decoder: decoder,
  888|      0|                                                                 emptyResponseCodes: emptyResponseCodes,
  889|      0|                                                                 emptyRequestMethods: emptyRequestMethods),
  890|      0|                 completionHandler: completionHandler)
  891|      0|    }
  892|       |}
  893|       |
  894|       |extension DownloadRequest {
  895|       |    /// Adds a handler using a `DecodableResponseSerializer` to be called once the request has finished.
  896|       |    ///
  897|       |    /// - Parameters:
  898|       |    ///   - type:                `Decodable` type to decode from response data.
  899|       |    ///   - queue:               The queue on which the completion handler is dispatched. `.main` by default.
  900|       |    ///   - dataPreprocessor:    `DataPreprocessor` which processes the received `Data` before calling the
  901|       |    ///                          `completionHandler`. `PassthroughPreprocessor()` by default.
  902|       |    ///   - decoder:             `DataDecoder` to use to decode the response. `JSONDecoder()` by default.
  903|       |    ///   - encoding:            The string encoding. Defaults to `nil`, in which case the encoding will be determined
  904|       |    ///                          from the server response, falling back to the default HTTP character set, `ISO-8859-1`.
  905|       |    ///   - emptyResponseCodes:  HTTP status codes for which empty responses are always valid. `[204, 205]` by default.
  906|       |    ///   - emptyRequestMethods: `HTTPMethod`s for which empty responses are always valid. `[.head]` by default.
  907|       |    ///   - options:             `JSONSerialization.ReadingOptions` used when parsing the response. `.allowFragments`
  908|       |    ///                          by default.
  909|       |    ///   - completionHandler:   A closure to be executed once the request has finished.
  910|       |    ///
  911|       |    /// - Returns:               The request.
  912|       |    @discardableResult
  913|       |    public func responseDecodable<T: Decodable>(of type: T.Type = T.self,
  914|       |                                                queue: DispatchQueue = .main,
  915|       |                                                dataPreprocessor: DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor,
  916|       |                                                decoder: DataDecoder = JSONDecoder(),
  917|       |                                                emptyResponseCodes: Set<Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes,
  918|       |                                                emptyRequestMethods: Set<HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods,
  919|      0|                                                completionHandler: @escaping (AFDownloadResponse<T>) -> Void) -> Self {
  920|      0|        response(queue: queue,
  921|      0|                 responseSerializer: DecodableResponseSerializer(dataPreprocessor: dataPreprocessor,
  922|      0|                                                                 decoder: decoder,
  923|      0|                                                                 emptyResponseCodes: emptyResponseCodes,
  924|      0|                                                                 emptyRequestMethods: emptyRequestMethods),
  925|      0|                 completionHandler: completionHandler)
  926|      0|    }
  927|       |}
  928|       |
  929|       |// MARK: - DataStreamRequest
  930|       |
  931|       |/// A type which can serialize incoming `Data`.
  932|       |public protocol DataStreamSerializer {
  933|       |    /// Type produced from the serialized `Data`.
  934|       |    associatedtype SerializedObject
  935|       |
  936|       |    /// Serializes incoming `Data` into a `SerializedObject` value.
  937|       |    ///
  938|       |    /// - Parameter data: `Data` to be serialized.
  939|       |    ///
  940|       |    /// - Throws: Any error produced during serialization.
  941|       |    func serialize(_ data: Data) throws -> SerializedObject
  942|       |}
  943|       |
  944|       |/// `DataStreamSerializer` which uses the provided `DataPreprocessor` and `DataDecoder` to serialize the incoming `Data`.
  945|       |public struct DecodableStreamSerializer<T: Decodable>: DataStreamSerializer {
  946|       |    /// `DataDecoder` used to decode incoming `Data`.
  947|       |    public let decoder: DataDecoder
  948|       |    /// `DataPreprocessor` incoming `Data` is passed through before being passed to the `DataDecoder`.
  949|       |    public let dataPreprocessor: DataPreprocessor
  950|       |
  951|       |    /// Creates an instance with the provided `DataDecoder` and `DataPreprocessor`.
  952|       |    /// - Parameters:
  953|       |    ///   - decoder: `        DataDecoder` used to decode incoming `Data`.
  954|       |    ///   - dataPreprocessor: `DataPreprocessor` used to process incoming `Data` before it's passed through the `decoder`.
  955|      0|    public init(decoder: DataDecoder = JSONDecoder(), dataPreprocessor: DataPreprocessor = PassthroughPreprocessor()) {
  956|      0|        self.decoder = decoder
  957|      0|        self.dataPreprocessor = dataPreprocessor
  958|      0|    }
  959|       |
  960|      0|    public func serialize(_ data: Data) throws -> T {
  961|      0|        let processedData = try dataPreprocessor.preprocess(data)
  962|      0|        do {
  963|      0|            return try decoder.decode(T.self, from: processedData)
  964|      0|        } catch {
  965|      0|            throw AFError.responseSerializationFailed(reason: .decodingFailed(error: error))
  966|      0|        }
  967|      0|    }
  968|       |}
  969|       |
  970|       |/// `DataStreamSerializer` which performs no serialization on incoming `Data`.
  971|       |public struct PassthroughStreamSerializer: DataStreamSerializer {
  972|      0|    public func serialize(_ data: Data) throws -> Data { data }
  973|       |}
  974|       |
  975|       |/// `DataStreamSerializer` which serializes incoming stream `Data` into `UTF8`-decoded `String` values.
  976|       |public struct StringStreamSerializer: DataStreamSerializer {
  977|      0|    public func serialize(_ data: Data) throws -> String {
  978|      0|        String(decoding: data, as: UTF8.self)
  979|      0|    }
  980|       |}
  981|       |
  982|       |extension DataStreamRequest {
  983|       |    /// Adds a `StreamHandler` which performs no parsing on incoming `Data`.
  984|       |    ///
  985|       |    /// - Parameters:
  986|       |    ///   - queue:  `DispatchQueue` on which to perform `StreamHandler` closure.
  987|       |    ///   - stream: `StreamHandler` closure called as `Data` is received. May be called multiple times.
  988|       |    ///
  989|       |    /// - Returns:  The `DataStreamRequest`.
  990|       |    @discardableResult
  991|      0|    public func responseStream(on queue: DispatchQueue = .main, stream: @escaping Handler<Data, Never>) -> Self {
  992|      0|        let parser = { [unowned self] (data: Data) in
  993|      0|            queue.async {
  994|      0|                self.capturingError {
  995|      0|                    try stream(.init(event: .stream(.success(data)), token: .init(self)))
  996|      0|                }
  997|      0|
  998|      0|                self.updateAndCompleteIfPossible()
  999|      0|            }
 1000|      0|        }
 1001|      0|
 1002|      0|        $streamMutableState.write { $0.streams.append(parser) }
 1003|      0|        appendStreamCompletion(on: queue, stream: stream)
 1004|      0|
 1005|      0|        return self
 1006|      0|    }
 1007|       |
 1008|       |    /// Adds a `StreamHandler` which uses the provided `DataStreamSerializer` to process incoming `Data`.
 1009|       |    ///
 1010|       |    /// - Parameters:
 1011|       |    ///   - serializer: `DataStreamSerializer` used to process incoming `Data`. Its work is done on the `serializationQueue`.
 1012|       |    ///   - queue:      `DispatchQueue` on which to perform `StreamHandler` closure.
 1013|       |    ///   - stream:     `StreamHandler` closure called as `Data` is received. May be called multiple times.
 1014|       |    ///
 1015|       |    /// - Returns:      The `DataStreamRequest`.
 1016|       |    @discardableResult
 1017|       |    public func responseStream<Serializer: DataStreamSerializer>(using serializer: Serializer,
 1018|       |                                                                 on queue: DispatchQueue = .main,
 1019|      0|                                                                 stream: @escaping Handler<Serializer.SerializedObject, AFError>) -> Self {
 1020|      0|        let parser = { [unowned self] (data: Data) in
 1021|      0|            self.serializationQueue.async {
 1022|      0|                // Start work on serialization queue.
 1023|      0|                let result = Result { try serializer.serialize(data) }
 1024|      0|                    .mapError { $0.asAFError(or: .responseSerializationFailed(reason: .customSerializationFailed(error: $0))) }
 1025|      0|                // End work on serialization queue.
 1026|      0|                self.underlyingQueue.async {
 1027|      0|                    self.eventMonitor?.request(self, didParseStream: result)
 1028|      0|
 1029|      0|                    if result.isFailure, self.automaticallyCancelOnStreamError {
 1030|      0|                        self.cancel()
 1031|      0|                    }
 1032|      0|
 1033|      0|                    queue.async {
 1034|      0|                        self.capturingError {
 1035|      0|                            try stream(.init(event: .stream(result), token: .init(self)))
 1036|      0|                        }
 1037|      0|
 1038|      0|                        self.updateAndCompleteIfPossible()
 1039|      0|                    }
 1040|      0|                }
 1041|      0|            }
 1042|      0|        }
 1043|      0|
 1044|      0|        $streamMutableState.write { $0.streams.append(parser) }
 1045|      0|        appendStreamCompletion(on: queue, stream: stream)
 1046|      0|
 1047|      0|        return self
 1048|      0|    }
 1049|       |
 1050|       |    /// Adds a `StreamHandler` which parses incoming `Data` as a UTF8 `String`.
 1051|       |    ///
 1052|       |    /// - Parameters:
 1053|       |    ///   - queue:      `DispatchQueue` on which to perform `StreamHandler` closure.
 1054|       |    ///   - stream:     `StreamHandler` closure called as `Data` is received. May be called multiple times.
 1055|       |    ///
 1056|       |    /// - Returns:  The `DataStreamRequest`.
 1057|       |    @discardableResult
 1058|       |    public func responseStreamString(on queue: DispatchQueue = .main,
 1059|      0|                                     stream: @escaping Handler<String, Never>) -> Self {
 1060|      0|        let parser = { [unowned self] (data: Data) in
 1061|      0|            self.serializationQueue.async {
 1062|      0|                // Start work on serialization queue.
 1063|      0|                let string = String(decoding: data, as: UTF8.self)
 1064|      0|                // End work on serialization queue.
 1065|      0|                self.underlyingQueue.async {
 1066|      0|                    self.eventMonitor?.request(self, didParseStream: .success(string))
 1067|      0|
 1068|      0|                    queue.async {
 1069|      0|                        self.capturingError {
 1070|      0|                            try stream(.init(event: .stream(.success(string)), token: .init(self)))
 1071|      0|                        }
 1072|      0|
 1073|      0|                        self.updateAndCompleteIfPossible()
 1074|      0|                    }
 1075|      0|                }
 1076|      0|            }
 1077|      0|        }
 1078|      0|
 1079|      0|        $streamMutableState.write { $0.streams.append(parser) }
 1080|      0|        appendStreamCompletion(on: queue, stream: stream)
 1081|      0|
 1082|      0|        return self
 1083|      0|    }
 1084|       |
 1085|      0|    private func updateAndCompleteIfPossible() {
 1086|      0|        $streamMutableState.write { state in
 1087|      0|            state.numberOfExecutingStreams -= 1
 1088|      0|
 1089|      0|            guard state.numberOfExecutingStreams == 0, !state.enqueuedCompletionEvents.isEmpty else { return }
 1090|      0|
 1091|      0|            let completionEvents = state.enqueuedCompletionEvents
 1092|      0|            self.underlyingQueue.async { completionEvents.forEach { $0() } }
 1093|      0|            state.enqueuedCompletionEvents.removeAll()
 1094|      0|        }
 1095|      0|    }
 1096|       |
 1097|       |    /// Adds a `StreamHandler` which parses incoming `Data` using the provided `DataDecoder`.
 1098|       |    ///
 1099|       |    /// - Parameters:
 1100|       |    ///   - type:         `Decodable` type to parse incoming `Data` into.
 1101|       |    ///   - queue:        `DispatchQueue` on which to perform `StreamHandler` closure.
 1102|       |    ///   - decoder:      `DataDecoder` used to decode the incoming `Data`.
 1103|       |    ///   - preprocessor: `DataPreprocessor` used to process the incoming `Data` before it's passed to the `decoder`.
 1104|       |    ///   - stream:       `StreamHandler` closure called as `Data` is received. May be called multiple times.
 1105|       |    ///
 1106|       |    /// - Returns: The `DataStreamRequest`.
 1107|       |    @discardableResult
 1108|       |    public func responseStreamDecodable<T: Decodable>(of type: T.Type = T.self,
 1109|       |                                                      on queue: DispatchQueue = .main,
 1110|       |                                                      using decoder: DataDecoder = JSONDecoder(),
 1111|       |                                                      preprocessor: DataPreprocessor = PassthroughPreprocessor(),
 1112|      0|                                                      stream: @escaping Handler<T, AFError>) -> Self {
 1113|      0|        responseStream(using: DecodableStreamSerializer<T>(decoder: decoder, dataPreprocessor: preprocessor),
 1114|      0|                       stream: stream)
 1115|      0|    }
 1116|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Result+Alamofire.swift:
    1|       |//
    2|       |//  Result+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2019 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Default type of `Result` returned by Alamofire, with an `AFError` `Failure` type.
   28|       |public typealias AFResult<Success> = Result<Success, AFError>
   29|       |
   30|       |// MARK: - Internal APIs
   31|       |
   32|       |extension Result {
   33|       |    /// Returns whether the instance is `.success`.
   34|      0|    var isSuccess: Bool {
   35|      0|        guard case .success = self else { return false }
   36|      0|        return true
   37|      0|    }
   38|       |
   39|       |    /// Returns whether the instance is `.failure`.
   40|      0|    var isFailure: Bool {
   41|      0|        !isSuccess
   42|      0|    }
   43|       |
   44|       |    /// Returns the associated value if the result is a success, `nil` otherwise.
   45|      0|    var success: Success? {
   46|      0|        guard case let .success(value) = self else { return nil }
   47|      0|        return value
   48|      0|    }
   49|       |
   50|       |    /// Returns the associated error value if the result is a failure, `nil` otherwise.
   51|      0|    var failure: Failure? {
   52|      0|        guard case let .failure(error) = self else { return nil }
   53|      0|        return error
   54|      0|    }
   55|       |
   56|       |    /// Initializes a `Result` from value or error. Returns `.failure` if the error is non-nil, `.success` otherwise.
   57|       |    ///
   58|       |    /// - Parameters:
   59|       |    ///   - value: A value.
   60|       |    ///   - error: An `Error`.
   61|      0|    init(value: Success, error: Failure?) {
   62|      0|        if let error = error {
   63|      0|            self = .failure(error)
   64|      0|        } else {
   65|      0|            self = .success(value)
   66|      0|        }
   67|      0|    }
   68|       |
   69|       |    /// Evaluates the specified closure when the `Result` is a success, passing the unwrapped value as a parameter.
   70|       |    ///
   71|       |    /// Use the `tryMap` method with a closure that may throw an error. For example:
   72|       |    ///
   73|       |    ///     let possibleData: Result<Data, Error> = .success(Data(...))
   74|       |    ///     let possibleObject = possibleData.tryMap {
   75|       |    ///         try JSONSerialization.jsonObject(with: $0)
   76|       |    ///     }
   77|       |    ///
   78|       |    /// - parameter transform: A closure that takes the success value of the instance.
   79|       |    ///
   80|       |    /// - returns: A `Result` containing the result of the given closure. If this instance is a failure, returns the
   81|       |    ///            same failure.
   82|      0|    func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> Result<NewSuccess, Error> {
   83|      0|        switch self {
   84|      0|        case let .success(value):
   85|      0|            do {
   86|      0|                return try .success(transform(value))
   87|      0|            } catch {
   88|      0|                return .failure(error)
   89|      0|            }
   90|      0|        case let .failure(error):
   91|      0|            return .failure(error)
   92|      0|        }
   93|      0|    }
   94|       |
   95|       |    /// Evaluates the specified closure when the `Result` is a failure, passing the unwrapped error as a parameter.
   96|       |    ///
   97|       |    /// Use the `tryMapError` function with a closure that may throw an error. For example:
   98|       |    ///
   99|       |    ///     let possibleData: Result<Data, Error> = .success(Data(...))
  100|       |    ///     let possibleObject = possibleData.tryMapError {
  101|       |    ///         try someFailableFunction(taking: $0)
  102|       |    ///     }
  103|       |    ///
  104|       |    /// - Parameter transform: A throwing closure that takes the error of the instance.
  105|       |    ///
  106|       |    /// - Returns: A `Result` instance containing the result of the transform. If this instance is a success, returns
  107|       |    ///            the same success.
  108|      0|    func tryMapError<NewFailure: Error>(_ transform: (Failure) throws -> NewFailure) -> Result<Success, Error> {
  109|      0|        switch self {
  110|      0|        case let .failure(error):
  111|      0|            do {
  112|      0|                return try .failure(transform(error))
  113|      0|            } catch {
  114|      0|                return .failure(error)
  115|      0|            }
  116|      0|        case let .success(value):
  117|      0|            return .success(value)
  118|      0|        }
  119|      0|    }
  120|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/RetryPolicy.swift:
    1|       |//
    2|       |//  RetryPolicy.swift
    3|       |//
    4|       |//  Copyright (c) 2019-2020 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A retry policy that retries requests using an exponential backoff for allowed HTTP methods and HTTP status codes
   28|       |/// as well as certain types of networking errors.
   29|       |open class RetryPolicy: RequestInterceptor {
   30|       |    /// The default retry limit for retry policies.
   31|       |    public static let defaultRetryLimit: UInt = 2
   32|       |
   33|       |    /// The default exponential backoff base for retry policies (must be a minimum of 2).
   34|       |    public static let defaultExponentialBackoffBase: UInt = 2
   35|       |
   36|       |    /// The default exponential backoff scale for retry policies.
   37|       |    public static let defaultExponentialBackoffScale: Double = 0.5
   38|       |
   39|       |    /// The default HTTP methods to retry.
   40|       |    /// See [RFC 2616 - Section 9.1.2](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) for more information.
   41|       |    public static let defaultRetryableHTTPMethods: Set<HTTPMethod> = [.delete, // [Delete](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.7) - not always idempotent
   42|       |                                                                      .get, // [GET](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3) - generally idempotent
   43|       |                                                                      .head, // [HEAD](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4) - generally idempotent
   44|       |                                                                      .options, // [OPTIONS](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.2) - inherently idempotent
   45|       |                                                                      .put, // [PUT](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.6) - not always idempotent
   46|       |                                                                      .trace // [TRACE](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.8) - inherently idempotent
   47|       |    ]
   48|       |
   49|       |    /// The default HTTP status codes to retry.
   50|       |    /// See [RFC 2616 - Section 10](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10) for more information.
   51|       |    public static let defaultRetryableHTTPStatusCodes: Set<Int> = [408, // [Request Timeout](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.9)
   52|       |                                                                   500, // [Internal Server Error](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1)
   53|       |                                                                   502, // [Bad Gateway](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.3)
   54|       |                                                                   503, // [Service Unavailable](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.4)
   55|       |                                                                   504 // [Gateway Timeout](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.5)
   56|       |    ]
   57|       |
   58|       |    /// The default URL error codes to retry.
   59|       |    public static let defaultRetryableURLErrorCodes: Set<URLError.Code> = [// [Security] App Transport Security disallowed a connection because there is no secure network connection.
   60|       |        //   - [Disabled] ATS settings do not change at runtime.
   61|       |        // .appTransportSecurityRequiresSecureConnection,
   62|       |
   63|       |        // [System] An app or app extension attempted to connect to a background session that is already connected to a
   64|       |        // process.
   65|       |        //   - [Enabled] The other process could release the background session.
   66|       |        .backgroundSessionInUseByAnotherProcess,
   67|       |
   68|       |        // [System] The shared container identifier of the URL session configuration is needed but has not been set.
   69|       |        //   - [Disabled] Cannot change at runtime.
   70|       |        // .backgroundSessionRequiresSharedContainer,
   71|       |
   72|       |        // [System] The app is suspended or exits while a background data task is processing.
   73|       |        //   - [Enabled] App can be foregrounded or launched to recover.
   74|       |        .backgroundSessionWasDisconnected,
   75|       |
   76|       |        // [Network] The URL Loading system received bad data from the server.
   77|       |        //   - [Enabled] Server could return valid data when retrying.
   78|       |        .badServerResponse,
   79|       |
   80|       |        // [Resource] A malformed URL prevented a URL request from being initiated.
   81|       |        //   - [Disabled] URL was most likely constructed incorrectly.
   82|       |        // .badURL,
   83|       |
   84|       |        // [System] A connection was attempted while a phone call is active on a network that does not support
   85|       |        // simultaneous phone and data communication (EDGE or GPRS).
   86|       |        //   - [Enabled] Phone call could be ended to allow request to recover.
   87|       |        .callIsActive,
   88|       |
   89|       |        // [Client] An asynchronous load has been canceled.
   90|       |        //   - [Disabled] Request was cancelled by the client.
   91|       |        // .cancelled,
   92|       |
   93|       |        // [File System] A download task couldn‚Äôt close the downloaded file on disk.
   94|       |        //   - [Disabled] File system error is unlikely to recover with retry.
   95|       |        // .cannotCloseFile,
   96|       |
   97|       |        // [Network] An attempt to connect to a host failed.
   98|       |        //   - [Enabled] Server or DNS lookup could recover during retry.
   99|       |        .cannotConnectToHost,
  100|       |
  101|       |        // [File System] A download task couldn‚Äôt create the downloaded file on disk because of an I/O failure.
  102|       |        //   - [Disabled] File system error is unlikely to recover with retry.
  103|       |        // .cannotCreateFile,
  104|       |
  105|       |        // [Data] Content data received during a connection request had an unknown content encoding.
  106|       |        //   - [Disabled] Server is unlikely to modify the content encoding during a retry.
  107|       |        // .cannotDecodeContentData,
  108|       |
  109|       |        // [Data] Content data received during a connection request could not be decoded for a known content encoding.
  110|       |        //   - [Disabled] Server is unlikely to modify the content encoding during a retry.
  111|       |        // .cannotDecodeRawData,
  112|       |
  113|       |        // [Network] The host name for a URL could not be resolved.
  114|       |        //   - [Enabled] Server or DNS lookup could recover during retry.
  115|       |        .cannotFindHost,
  116|       |
  117|       |        // [Network] A request to load an item only from the cache could not be satisfied.
  118|       |        //   - [Enabled] Cache could be populated during a retry.
  119|       |        .cannotLoadFromNetwork,
  120|       |
  121|       |        // [File System] A download task was unable to move a downloaded file on disk.
  122|       |        //   - [Disabled] File system error is unlikely to recover with retry.
  123|       |        // .cannotMoveFile,
  124|       |
  125|       |        // [File System] A download task was unable to open the downloaded file on disk.
  126|       |        //   - [Disabled] File system error is unlikely to recover with retry.
  127|       |        // .cannotOpenFile,
  128|       |
  129|       |        // [Data] A task could not parse a response.
  130|       |        //   - [Disabled] Invalid response is unlikely to recover with retry.
  131|       |        // .cannotParseResponse,
  132|       |
  133|       |        // [File System] A download task was unable to remove a downloaded file from disk.
  134|       |        //   - [Disabled] File system error is unlikely to recover with retry.
  135|       |        // .cannotRemoveFile,
  136|       |
  137|       |        // [File System] A download task was unable to write to the downloaded file on disk.
  138|       |        //   - [Disabled] File system error is unlikely to recover with retry.
  139|       |        // .cannotWriteToFile,
  140|       |
  141|       |        // [Security] A client certificate was rejected.
  142|       |        //   - [Disabled] Client certificate is unlikely to change with retry.
  143|       |        // .clientCertificateRejected,
  144|       |
  145|       |        // [Security] A client certificate was required to authenticate an SSL connection during a request.
  146|       |        //   - [Disabled] Client certificate is unlikely to be provided with retry.
  147|       |        // .clientCertificateRequired,
  148|       |
  149|       |        // [Data] The length of the resource data exceeds the maximum allowed.
  150|       |        //   - [Disabled] Resource will likely still exceed the length maximum on retry.
  151|       |        // .dataLengthExceedsMaximum,
  152|       |
  153|       |        // [System] The cellular network disallowed a connection.
  154|       |        //   - [Enabled] WiFi connection could be established during retry.
  155|       |        .dataNotAllowed,
  156|       |
  157|       |        // [Network] The host address could not be found via DNS lookup.
  158|       |        //   - [Enabled] DNS lookup could succeed during retry.
  159|       |        .dnsLookupFailed,
  160|       |
  161|       |        // [Data] A download task failed to decode an encoded file during the download.
  162|       |        //   - [Enabled] Server could correct the decoding issue with retry.
  163|       |        .downloadDecodingFailedMidStream,
  164|       |
  165|       |        // [Data] A download task failed to decode an encoded file after downloading.
  166|       |        //   - [Enabled] Server could correct the decoding issue with retry.
  167|       |        .downloadDecodingFailedToComplete,
  168|       |
  169|       |        // [File System] A file does not exist.
  170|       |        //   - [Disabled] File system error is unlikely to recover with retry.
  171|       |        // .fileDoesNotExist,
  172|       |
  173|       |        // [File System] A request for an FTP file resulted in the server responding that the file is not a plain file,
  174|       |        // but a directory.
  175|       |        //   - [Disabled] FTP directory is not likely to change to a file during a retry.
  176|       |        // .fileIsDirectory,
  177|       |
  178|       |        // [Network] A redirect loop has been detected or the threshold for number of allowable redirects has been
  179|       |        // exceeded (currently 16).
  180|       |        //   - [Disabled] The redirect loop is unlikely to be resolved within the retry window.
  181|       |        // .httpTooManyRedirects,
  182|       |
  183|       |        // [System] The attempted connection required activating a data context while roaming, but international roaming
  184|       |        // is disabled.
  185|       |        //   - [Enabled] WiFi connection could be established during retry.
  186|       |        .internationalRoamingOff,
  187|       |
  188|       |        // [Connectivity] A client or server connection was severed in the middle of an in-progress load.
  189|       |        //   - [Enabled] A network connection could be established during retry.
  190|       |        .networkConnectionLost,
  191|       |
  192|       |        // [File System] A resource couldn‚Äôt be read because of insufficient permissions.
  193|       |        //   - [Disabled] Permissions are unlikely to be granted during retry.
  194|       |        // .noPermissionsToReadFile,
  195|       |
  196|       |        // [Connectivity] A network resource was requested, but an internet connection has not been established and
  197|       |        // cannot be established automatically.
  198|       |        //   - [Enabled] A network connection could be established during retry.
  199|       |        .notConnectedToInternet,
  200|       |
  201|       |        // [Resource] A redirect was specified by way of server response code, but the server did not accompany this
  202|       |        // code with a redirect URL.
  203|       |        //   - [Disabled] The redirect URL is unlikely to be supplied during a retry.
  204|       |        // .redirectToNonExistentLocation,
  205|       |
  206|       |        // [Client] A body stream is needed but the client did not provide one.
  207|       |        //   - [Disabled] The client will be unlikely to supply a body stream during retry.
  208|       |        // .requestBodyStreamExhausted,
  209|       |
  210|       |        // [Resource] A requested resource couldn‚Äôt be retrieved.
  211|       |        //   - [Disabled] The resource is unlikely to become available during the retry window.
  212|       |        // .resourceUnavailable,
  213|       |
  214|       |        // [Security] An attempt to establish a secure connection failed for reasons that can‚Äôt be expressed more
  215|       |        // specifically.
  216|       |        //   - [Enabled] The secure connection could be established during a retry given the lack of specificity
  217|       |        //     provided by the error.
  218|       |        .secureConnectionFailed,
  219|       |
  220|       |        // [Security] A server certificate had a date which indicates it has expired, or is not yet valid.
  221|       |        //   - [Enabled] The server certificate could become valid within the retry window.
  222|       |        .serverCertificateHasBadDate,
  223|       |
  224|       |        // [Security] A server certificate was not signed by any root server.
  225|       |        //   - [Disabled] The server certificate is unlikely to change during the retry window.
  226|       |        // .serverCertificateHasUnknownRoot,
  227|       |
  228|       |        // [Security] A server certificate is not yet valid.
  229|       |        //   - [Enabled] The server certificate could become valid within the retry window.
  230|       |        .serverCertificateNotYetValid,
  231|       |
  232|       |        // [Security] A server certificate was signed by a root server that isn‚Äôt trusted.
  233|       |        //   - [Disabled] The server certificate is unlikely to become trusted within the retry window.
  234|       |        // .serverCertificateUntrusted,
  235|       |
  236|       |        // [Network] An asynchronous operation timed out.
  237|       |        //   - [Enabled] The request timed out for an unknown reason and should be retried.
  238|       |        .timedOut
  239|       |
  240|       |        // [System] The URL Loading System encountered an error that it can‚Äôt interpret.
  241|       |        //   - [Disabled] The error could not be interpreted and is unlikely to be recovered from during a retry.
  242|       |        // .unknown,
  243|       |
  244|       |        // [Resource] A properly formed URL couldn‚Äôt be handled by the framework.
  245|       |        //   - [Disabled] The URL is unlikely to change during a retry.
  246|       |        // .unsupportedURL,
  247|       |
  248|       |        // [Client] Authentication is required to access a resource.
  249|       |        //   - [Disabled] The user authentication is unlikely to be provided by retrying.
  250|       |        // .userAuthenticationRequired,
  251|       |
  252|       |        // [Client] An asynchronous request for authentication has been canceled by the user.
  253|       |        //   - [Disabled] The user cancelled authentication and explicitly took action to not retry.
  254|       |        // .userCancelledAuthentication,
  255|       |
  256|       |        // [Resource] A server reported that a URL has a non-zero content length, but terminated the network connection
  257|       |        // gracefully without sending any data.
  258|       |        //   - [Disabled] The server is unlikely to provide data during the retry window.
  259|       |        // .zeroByteResource,
  260|       |    ]
  261|       |
  262|       |    /// The total number of times the request is allowed to be retried.
  263|       |    public let retryLimit: UInt
  264|       |
  265|       |    /// The base of the exponential backoff policy (should always be greater than or equal to 2).
  266|       |    public let exponentialBackoffBase: UInt
  267|       |
  268|       |    /// The scale of the exponential backoff.
  269|       |    public let exponentialBackoffScale: Double
  270|       |
  271|       |    /// The HTTP methods that are allowed to be retried.
  272|       |    public let retryableHTTPMethods: Set<HTTPMethod>
  273|       |
  274|       |    /// The HTTP status codes that are automatically retried by the policy.
  275|       |    public let retryableHTTPStatusCodes: Set<Int>
  276|       |
  277|       |    /// The URL error codes that are automatically retried by the policy.
  278|       |    public let retryableURLErrorCodes: Set<URLError.Code>
  279|       |
  280|       |    /// Creates an `ExponentialBackoffRetryPolicy` from the specified parameters.
  281|       |    ///
  282|       |    /// - Parameters:
  283|       |    ///   - retryLimit:               The total number of times the request is allowed to be retried. `2` by default.
  284|       |    ///   - exponentialBackoffBase:   The base of the exponential backoff policy. `2` by default.
  285|       |    ///   - exponentialBackoffScale:  The scale of the exponential backoff. `0.5` by default.
  286|       |    ///   - retryableHTTPMethods:     The HTTP methods that are allowed to be retried.
  287|       |    ///                               `RetryPolicy.defaultRetryableHTTPMethods` by default.
  288|       |    ///   - retryableHTTPStatusCodes: The HTTP status codes that are automatically retried by the policy.
  289|       |    ///                               `RetryPolicy.defaultRetryableHTTPStatusCodes` by default.
  290|       |    ///   - retryableURLErrorCodes:   The URL error codes that are automatically retried by the policy.
  291|       |    ///                               `RetryPolicy.defaultRetryableURLErrorCodes` by default.
  292|       |    public init(retryLimit: UInt = RetryPolicy.defaultRetryLimit,
  293|       |                exponentialBackoffBase: UInt = RetryPolicy.defaultExponentialBackoffBase,
  294|       |                exponentialBackoffScale: Double = RetryPolicy.defaultExponentialBackoffScale,
  295|       |                retryableHTTPMethods: Set<HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods,
  296|       |                retryableHTTPStatusCodes: Set<Int> = RetryPolicy.defaultRetryableHTTPStatusCodes,
  297|      0|                retryableURLErrorCodes: Set<URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) {
  298|      0|        precondition(exponentialBackoffBase >= 2, "The `exponentialBackoffBase` must be a minimum of 2.")
  299|      0|
  300|      0|        self.retryLimit = retryLimit
  301|      0|        self.exponentialBackoffBase = exponentialBackoffBase
  302|      0|        self.exponentialBackoffScale = exponentialBackoffScale
  303|      0|        self.retryableHTTPMethods = retryableHTTPMethods
  304|      0|        self.retryableHTTPStatusCodes = retryableHTTPStatusCodes
  305|      0|        self.retryableURLErrorCodes = retryableURLErrorCodes
  306|      0|    }
  307|       |
  308|       |    open func retry(_ request: Request,
  309|       |                    for session: Session,
  310|       |                    dueTo error: Error,
  311|      0|                    completion: @escaping (RetryResult) -> Void) {
  312|      0|        if request.retryCount < retryLimit, shouldRetry(request: request, dueTo: error) {
  313|      0|            completion(.retryWithDelay(pow(Double(exponentialBackoffBase), Double(request.retryCount)) * exponentialBackoffScale))
  314|      0|        } else {
  315|      0|            completion(.doNotRetry)
  316|      0|        }
  317|      0|    }
  318|       |
  319|       |    /// Determines whether or not to retry the provided `Request`.
  320|       |    ///
  321|       |    /// - Parameters:
  322|       |    ///     - request: `Request` that failed due to the provided `Error`.
  323|       |    ///     - error:   `Error` encountered while executing the `Request`.
  324|       |    ///
  325|       |    /// - Returns:     `Bool` determining whether or not to retry the `Request`.
  326|      0|    open func shouldRetry(request: Request, dueTo error: Error) -> Bool {
  327|      0|        guard let httpMethod = request.request?.method, retryableHTTPMethods.contains(httpMethod) else { return false }
  328|      0|
  329|      0|        if let statusCode = request.response?.statusCode, retryableHTTPStatusCodes.contains(statusCode) {
  330|      0|            return true
  331|      0|        } else {
  332|      0|            let errorCode = (error as? URLError)?.code
  333|      0|            let afErrorCode = (error.asAFError?.underlyingError as? URLError)?.code
  334|      0|
  335|      0|            guard let code = errorCode ?? afErrorCode else { return false }
  336|      0|
  337|      0|            return retryableURLErrorCodes.contains(code)
  338|      0|        }
  339|      0|    }
  340|       |}
  341|       |
  342|       |// MARK: -
  343|       |
  344|       |/// A retry policy that automatically retries idempotent requests for network connection lost errors. For more
  345|       |/// information about retrying network connection lost errors, please refer to Apple's
  346|       |/// [technical document](https://developer.apple.com/library/content/qa/qa1941/_index.html).
  347|       |open class ConnectionLostRetryPolicy: RetryPolicy {
  348|       |    /// Creates a `ConnectionLostRetryPolicy` instance from the specified parameters.
  349|       |    ///
  350|       |    /// - Parameters:
  351|       |    ///   - retryLimit:              The total number of times the request is allowed to be retried.
  352|       |    ///                              `RetryPolicy.defaultRetryLimit` by default.
  353|       |    ///   - exponentialBackoffBase:  The base of the exponential backoff policy.
  354|       |    ///                              `RetryPolicy.defaultExponentialBackoffBase` by default.
  355|       |    ///   - exponentialBackoffScale: The scale of the exponential backoff.
  356|       |    ///                              `RetryPolicy.defaultExponentialBackoffScale` by default.
  357|       |    ///   - retryableHTTPMethods:    The idempotent http methods to retry.
  358|       |    ///                              `RetryPolicy.defaultRetryableHTTPMethods` by default.
  359|       |    public init(retryLimit: UInt = RetryPolicy.defaultRetryLimit,
  360|       |                exponentialBackoffBase: UInt = RetryPolicy.defaultExponentialBackoffBase,
  361|       |                exponentialBackoffScale: Double = RetryPolicy.defaultExponentialBackoffScale,
  362|      0|                retryableHTTPMethods: Set<HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) {
  363|      0|        super.init(retryLimit: retryLimit,
  364|      0|                   exponentialBackoffBase: exponentialBackoffBase,
  365|      0|                   exponentialBackoffScale: exponentialBackoffScale,
  366|      0|                   retryableHTTPMethods: retryableHTTPMethods,
  367|      0|                   retryableHTTPStatusCodes: [],
  368|      0|                   retryableURLErrorCodes: [.networkConnectionLost])
  369|      0|    }
  370|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/ServerTrustEvaluation.swift:
    1|       |//
    2|       |//  ServerTrustPolicy.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Responsible for managing the mapping of `ServerTrustEvaluating` values to given hosts.
   28|       |open class ServerTrustManager {
   29|       |    /// Determines whether all hosts for this `ServerTrustManager` must be evaluated. `true` by default.
   30|       |    public let allHostsMustBeEvaluated: Bool
   31|       |
   32|       |    /// The dictionary of policies mapped to a particular host.
   33|       |    public let evaluators: [String: ServerTrustEvaluating]
   34|       |
   35|       |    /// Initializes the `ServerTrustManager` instance with the given evaluators.
   36|       |    ///
   37|       |    /// Since different servers and web services can have different leaf certificates, intermediate and even root
   38|       |    /// certificates, it is important to have the flexibility to specify evaluation policies on a per host basis. This
   39|       |    /// allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key
   40|       |    /// pinning for host3 and disabling evaluation for host4.
   41|       |    ///
   42|       |    /// - Parameters:
   43|       |    ///   - allHostsMustBeEvaluated: The value determining whether all hosts for this instance must be evaluated. `true`
   44|       |    ///                              by default.
   45|       |    ///   - evaluators:              A dictionary of evaluators mapped to hosts.
   46|      0|    public init(allHostsMustBeEvaluated: Bool = true, evaluators: [String: ServerTrustEvaluating]) {
   47|      0|        self.allHostsMustBeEvaluated = allHostsMustBeEvaluated
   48|      0|        self.evaluators = evaluators
   49|      0|    }
   50|       |
   51|       |    /// Returns the `ServerTrustEvaluating` value for the given host, if one is set.
   52|       |    ///
   53|       |    /// By default, this method will return the policy that perfectly matches the given host. Subclasses could override
   54|       |    /// this method and implement more complex mapping implementations such as wildcards.
   55|       |    ///
   56|       |    /// - Parameter host: The host to use when searching for a matching policy.
   57|       |    ///
   58|       |    /// - Returns:        The `ServerTrustEvaluating` value for the given host if found, `nil` otherwise.
   59|       |    /// - Throws:         `AFError.serverTrustEvaluationFailed` if `allHostsMustBeEvaluated` is `true` and no matching
   60|       |    ///                   evaluators are found.
   61|      0|    open func serverTrustEvaluator(forHost host: String) throws -> ServerTrustEvaluating? {
   62|      0|        guard let evaluator = evaluators[host] else {
   63|      0|            if allHostsMustBeEvaluated {
   64|      0|                throw AFError.serverTrustEvaluationFailed(reason: .noRequiredEvaluator(host: host))
   65|      0|            }
   66|      0|
   67|      0|            return nil
   68|      0|        }
   69|      0|
   70|      0|        return evaluator
   71|      0|    }
   72|       |}
   73|       |
   74|       |/// A protocol describing the API used to evaluate server trusts.
   75|       |public protocol ServerTrustEvaluating {
   76|       |    #if os(Linux)
   77|       |    // Implement this once Linux has API for evaluating server trusts.
   78|       |    #else
   79|       |    /// Evaluates the given `SecTrust` value for the given `host`.
   80|       |    ///
   81|       |    /// - Parameters:
   82|       |    ///   - trust: The `SecTrust` value to evaluate.
   83|       |    ///   - host:  The host for which to evaluate the `SecTrust` value.
   84|       |    ///
   85|       |    /// - Returns: A `Bool` indicating whether the evaluator considers the `SecTrust` value valid for `host`.
   86|       |    func evaluate(_ trust: SecTrust, forHost host: String) throws
   87|       |    #endif
   88|       |}
   89|       |
   90|       |// MARK: - Server Trust Evaluators
   91|       |
   92|       |/// An evaluator which uses the default server trust evaluation while allowing you to control whether to validate the
   93|       |/// host provided by the challenge. Applications are encouraged to always validate the host in production environments
   94|       |/// to guarantee the validity of the server's certificate chain.
   95|       |public final class DefaultTrustEvaluator: ServerTrustEvaluating {
   96|       |    private let validateHost: Bool
   97|       |
   98|       |    /// Creates a `DefaultTrustEvaluator`.
   99|       |    ///
  100|       |    /// - Parameter validateHost: Determines whether or not the evaluator should validate the host. `true` by default.
  101|      0|    public init(validateHost: Bool = true) {
  102|      0|        self.validateHost = validateHost
  103|      0|    }
  104|       |
  105|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {
  106|      0|        if validateHost {
  107|      0|            try trust.af.performValidation(forHost: host)
  108|      0|        }
  109|      0|
  110|      0|        try trust.af.performDefaultValidation(forHost: host)
  111|      0|    }
  112|       |}
  113|       |
  114|       |/// An evaluator which Uses the default and revoked server trust evaluations allowing you to control whether to validate
  115|       |/// the host provided by the challenge as well as specify the revocation flags for testing for revoked certificates.
  116|       |/// Apple platforms did not start testing for revoked certificates automatically until iOS 10.1, macOS 10.12 and tvOS
  117|       |/// 10.1 which is demonstrated in our TLS tests. Applications are encouraged to always validate the host in production
  118|       |/// environments to guarantee the validity of the server's certificate chain.
  119|       |public final class RevocationTrustEvaluator: ServerTrustEvaluating {
  120|       |    /// Represents the options to be use when evaluating the status of a certificate.
  121|       |    /// Only Revocation Policy Constants are valid, and can be found in [Apple's documentation](https://developer.apple.com/documentation/security/certificate_key_and_trust_services/policies/1563600-revocation_policy_constants).
  122|       |    public struct Options: OptionSet {
  123|       |        /// Perform revocation checking using the CRL (Certification Revocation List) method.
  124|       |        public static let crl = Options(rawValue: kSecRevocationCRLMethod)
  125|       |        /// Consult only locally cached replies; do not use network access.
  126|       |        public static let networkAccessDisabled = Options(rawValue: kSecRevocationNetworkAccessDisabled)
  127|       |        /// Perform revocation checking using OCSP (Online Certificate Status Protocol).
  128|       |        public static let ocsp = Options(rawValue: kSecRevocationOCSPMethod)
  129|       |        /// Prefer CRL revocation checking over OCSP; by default, OCSP is preferred.
  130|       |        public static let preferCRL = Options(rawValue: kSecRevocationPreferCRL)
  131|       |        /// Require a positive response to pass the policy. If the flag is not set, revocation checking is done on a
  132|       |        /// "best attempt" basis, where failure to reach the server is not considered fatal.
  133|       |        public static let requirePositiveResponse = Options(rawValue: kSecRevocationRequirePositiveResponse)
  134|       |        /// Perform either OCSP or CRL checking. The checking is performed according to the method(s) specified in the
  135|       |        /// certificate and the value of `preferCRL`.
  136|       |        public static let any = Options(rawValue: kSecRevocationUseAnyAvailableMethod)
  137|       |
  138|       |        /// The raw value of the option.
  139|       |        public let rawValue: CFOptionFlags
  140|       |
  141|       |        /// Creates an `Options` value with the given `CFOptionFlags`.
  142|       |        ///
  143|       |        /// - Parameter rawValue: The `CFOptionFlags` value to initialize with.
  144|      0|        public init(rawValue: CFOptionFlags) {
  145|      0|            self.rawValue = rawValue
  146|      0|        }
  147|       |    }
  148|       |
  149|       |    private let performDefaultValidation: Bool
  150|       |    private let validateHost: Bool
  151|       |    private let options: Options
  152|       |
  153|       |    /// Creates a `RevocationTrustEvaluator`.
  154|       |    ///
  155|       |    /// - Note: Default and host validation will fail when using this evaluator with self-signed certificates. Use
  156|       |    ///         `PinnedCertificatesTrustEvaluator` if you need to use self-signed certificates.
  157|       |    ///
  158|       |    /// - Parameters:
  159|       |    ///   - performDefaultValidation:     Determines whether default validation should be performed in addition to
  160|       |    ///                                   evaluating the pinned certificates. `true` by default.
  161|       |    ///   - validateHost:                 Determines whether or not the evaluator should validate the host, in addition
  162|       |    ///                                   to performing the default evaluation, even if `performDefaultValidation` is
  163|       |    ///                                   `false`. `true` by default.
  164|       |    ///   - options:                      The `Options` to use to check the revocation status of the certificate. `.any`
  165|       |    ///                                   by default.
  166|      0|    public init(performDefaultValidation: Bool = true, validateHost: Bool = true, options: Options = .any) {
  167|      0|        self.performDefaultValidation = performDefaultValidation
  168|      0|        self.validateHost = validateHost
  169|      0|        self.options = options
  170|      0|    }
  171|       |
  172|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {
  173|      0|        if performDefaultValidation {
  174|      0|            try trust.af.performDefaultValidation(forHost: host)
  175|      0|        }
  176|      0|
  177|      0|        if validateHost {
  178|      0|            try trust.af.performValidation(forHost: host)
  179|      0|        }
  180|      0|
  181|      0|        if #available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *) {
  182|      0|            try trust.af.evaluate(afterApplying: SecPolicy.af.revocation(options: options))
  183|      0|        } else {
  184|      0|            try trust.af.validate(policy: SecPolicy.af.revocation(options: options)) { status, result in
  185|      0|                AFError.serverTrustEvaluationFailed(reason: .revocationCheckFailed(output: .init(host, trust, status, result), options: options))
  186|      0|            }
  187|      0|        }
  188|      0|    }
  189|       |}
  190|       |
  191|       |/// Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned
  192|       |/// certificates match one of the server certificates. By validating both the certificate chain and host, certificate
  193|       |/// pinning provides a very secure form of server trust validation mitigating most, if not all, MITM attacks.
  194|       |/// Applications are encouraged to always validate the host and require a valid certificate chain in production
  195|       |/// environments.
  196|       |public final class PinnedCertificatesTrustEvaluator: ServerTrustEvaluating {
  197|       |    private let certificates: [SecCertificate]
  198|       |    private let acceptSelfSignedCertificates: Bool
  199|       |    private let performDefaultValidation: Bool
  200|       |    private let validateHost: Bool
  201|       |
  202|       |    /// Creates a `PinnedCertificatesTrustEvaluator`.
  203|       |    ///
  204|       |    /// - Parameters:
  205|       |    ///   - certificates:                 The certificates to use to evaluate the trust. All `cer`, `crt`, and `der`
  206|       |    ///                                   certificates in `Bundle.main` by default.
  207|       |    ///   - acceptSelfSignedCertificates: Adds the provided certificates as anchors for the trust evaluation, allowing
  208|       |    ///                                   self-signed certificates to pass. `false` by default. THIS SETTING SHOULD BE
  209|       |    ///                                   FALSE IN PRODUCTION!
  210|       |    ///   - performDefaultValidation:     Determines whether default validation should be performed in addition to
  211|       |    ///                                   evaluating the pinned certificates. `true` by default.
  212|       |    ///   - validateHost:                 Determines whether or not the evaluator should validate the host, in addition
  213|       |    ///                                   to performing the default evaluation, even if `performDefaultValidation` is
  214|       |    ///                                   `false`. `true` by default.
  215|       |    public init(certificates: [SecCertificate] = Bundle.main.af.certificates,
  216|       |                acceptSelfSignedCertificates: Bool = false,
  217|       |                performDefaultValidation: Bool = true,
  218|      0|                validateHost: Bool = true) {
  219|      0|        self.certificates = certificates
  220|      0|        self.acceptSelfSignedCertificates = acceptSelfSignedCertificates
  221|      0|        self.performDefaultValidation = performDefaultValidation
  222|      0|        self.validateHost = validateHost
  223|      0|    }
  224|       |
  225|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {
  226|      0|        guard !certificates.isEmpty else {
  227|      0|            throw AFError.serverTrustEvaluationFailed(reason: .noCertificatesFound)
  228|      0|        }
  229|      0|
  230|      0|        if acceptSelfSignedCertificates {
  231|      0|            try trust.af.setAnchorCertificates(certificates)
  232|      0|        }
  233|      0|
  234|      0|        if performDefaultValidation {
  235|      0|            try trust.af.performDefaultValidation(forHost: host)
  236|      0|        }
  237|      0|
  238|      0|        if validateHost {
  239|      0|            try trust.af.performValidation(forHost: host)
  240|      0|        }
  241|      0|
  242|      0|        let serverCertificatesData = Set(trust.af.certificateData)
  243|      0|        let pinnedCertificatesData = Set(certificates.af.data)
  244|      0|        let pinnedCertificatesInServerData = !serverCertificatesData.isDisjoint(with: pinnedCertificatesData)
  245|      0|        if !pinnedCertificatesInServerData {
  246|      0|            throw AFError.serverTrustEvaluationFailed(reason: .certificatePinningFailed(host: host,
  247|      0|                                                                                        trust: trust,
  248|      0|                                                                                        pinnedCertificates: certificates,
  249|      0|                                                                                        serverCertificates: trust.af.certificates))
  250|      0|        }
  251|      0|    }
  252|       |}
  253|       |
  254|       |/// Uses the pinned public keys to validate the server trust. The server trust is considered valid if one of the pinned
  255|       |/// public keys match one of the server certificate public keys. By validating both the certificate chain and host,
  256|       |/// public key pinning provides a very secure form of server trust validation mitigating most, if not all, MITM attacks.
  257|       |/// Applications are encouraged to always validate the host and require a valid certificate chain in production
  258|       |/// environments.
  259|       |public final class PublicKeysTrustEvaluator: ServerTrustEvaluating {
  260|       |    private let keys: [SecKey]
  261|       |    private let performDefaultValidation: Bool
  262|       |    private let validateHost: Bool
  263|       |
  264|       |    /// Creates a `PublicKeysTrustEvaluator`.
  265|       |    ///
  266|       |    /// - Note: Default and host validation will fail when using this evaluator with self-signed certificates. Use
  267|       |    ///         `PinnedCertificatesTrustEvaluator` if you need to use self-signed certificates.
  268|       |    ///
  269|       |    /// - Parameters:
  270|       |    ///   - keys:                     The `SecKey`s to use to validate public keys. Defaults to the public keys of all
  271|       |    ///                               certificates included in the main bundle.
  272|       |    ///   - performDefaultValidation: Determines whether default validation should be performed in addition to
  273|       |    ///                               evaluating the pinned certificates. `true` by default.
  274|       |    ///   - validateHost:             Determines whether or not the evaluator should validate the host, in addition to
  275|       |    ///                               performing the default evaluation, even if `performDefaultValidation` is `false`.
  276|       |    ///                               `true` by default.
  277|       |    public init(keys: [SecKey] = Bundle.main.af.publicKeys,
  278|       |                performDefaultValidation: Bool = true,
  279|      0|                validateHost: Bool = true) {
  280|      0|        self.keys = keys
  281|      0|        self.performDefaultValidation = performDefaultValidation
  282|      0|        self.validateHost = validateHost
  283|      0|    }
  284|       |
  285|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {
  286|      0|        guard !keys.isEmpty else {
  287|      0|            throw AFError.serverTrustEvaluationFailed(reason: .noPublicKeysFound)
  288|      0|        }
  289|      0|
  290|      0|        if performDefaultValidation {
  291|      0|            try trust.af.performDefaultValidation(forHost: host)
  292|      0|        }
  293|      0|
  294|      0|        if validateHost {
  295|      0|            try trust.af.performValidation(forHost: host)
  296|      0|        }
  297|      0|
  298|      0|        let pinnedKeysInServerKeys: Bool = {
  299|      0|            for serverPublicKey in trust.af.publicKeys {
  300|      0|                for pinnedPublicKey in keys {
  301|      0|                    if serverPublicKey == pinnedPublicKey {
  302|      0|                        return true
  303|      0|                    }
  304|      0|                }
  305|      0|            }
  306|      0|            return false
  307|      0|        }()
  308|      0|
  309|      0|        if !pinnedKeysInServerKeys {
  310|      0|            throw AFError.serverTrustEvaluationFailed(reason: .publicKeyPinningFailed(host: host,
  311|      0|                                                                                      trust: trust,
  312|      0|                                                                                      pinnedKeys: keys,
  313|      0|                                                                                      serverKeys: trust.af.publicKeys))
  314|      0|        }
  315|      0|    }
  316|       |}
  317|       |
  318|       |/// Uses the provided evaluators to validate the server trust. The trust is only considered valid if all of the
  319|       |/// evaluators consider it valid.
  320|       |public final class CompositeTrustEvaluator: ServerTrustEvaluating {
  321|       |    private let evaluators: [ServerTrustEvaluating]
  322|       |
  323|       |    /// Creates a `CompositeTrustEvaluator`.
  324|       |    ///
  325|       |    /// - Parameter evaluators: The `ServerTrustEvaluating` values used to evaluate the server trust.
  326|      0|    public init(evaluators: [ServerTrustEvaluating]) {
  327|      0|        self.evaluators = evaluators
  328|      0|    }
  329|       |
  330|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {
  331|      0|        try evaluators.evaluate(trust, forHost: host)
  332|      0|    }
  333|       |}
  334|       |
  335|       |/// Disables all evaluation which in turn will always consider any server trust as valid.
  336|       |///
  337|       |/// - Note: Instead of disabling server trust evaluation, it's a better idea to configure systems to properly trust test
  338|       |///         certificates, as outlined in [this Apple tech note](https://developer.apple.com/library/archive/qa/qa1948/_index.html).
  339|       |///
  340|       |/// **THIS EVALUATOR SHOULD NEVER BE USED IN PRODUCTION!**
  341|       |@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
  342|       |public typealias DisabledEvaluator = DisabledTrustEvaluator
  343|       |
  344|       |/// Disables all evaluation which in turn will always consider any server trust as valid.
  345|       |///
  346|       |///
  347|       |/// - Note: Instead of disabling server trust evaluation, it's a better idea to configure systems to properly trust test
  348|       |///         certificates, as outlined in [this Apple tech note](https://developer.apple.com/library/archive/qa/qa1948/_index.html).
  349|       |///
  350|       |/// **THIS EVALUATOR SHOULD NEVER BE USED IN PRODUCTION!**
  351|       |public final class DisabledTrustEvaluator: ServerTrustEvaluating {
  352|       |    /// Creates an instance.
  353|      0|    public init() {}
  354|       |
  355|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {}
  356|       |}
  357|       |
  358|       |// MARK: - Extensions
  359|       |
  360|       |extension Array where Element == ServerTrustEvaluating {
  361|       |    #if os(Linux)
  362|       |    // Add this same convenience method for Linux.
  363|       |    #else
  364|       |    /// Evaluates the given `SecTrust` value for the given `host`.
  365|       |    ///
  366|       |    /// - Parameters:
  367|       |    ///   - trust: The `SecTrust` value to evaluate.
  368|       |    ///   - host:  The host for which to evaluate the `SecTrust` value.
  369|       |    ///
  370|       |    /// - Returns: Whether or not the evaluator considers the `SecTrust` value valid for `host`.
  371|      0|    public func evaluate(_ trust: SecTrust, forHost host: String) throws {
  372|      0|        for evaluator in self {
  373|      0|            try evaluator.evaluate(trust, forHost: host)
  374|      0|        }
  375|      0|    }
  376|       |    #endif
  377|       |}
  378|       |
  379|       |extension Bundle: AlamofireExtended {}
  380|       |extension AlamofireExtension where ExtendedType: Bundle {
  381|       |    /// Returns all valid `cer`, `crt`, and `der` certificates in the bundle.
  382|      0|    public var certificates: [SecCertificate] {
  383|      0|        paths(forResourcesOfTypes: [".cer", ".CER", ".crt", ".CRT", ".der", ".DER"]).compactMap { path in
  384|      0|            guard
  385|      0|                let certificateData = try? Data(contentsOf: URL(fileURLWithPath: path)) as CFData,
  386|      0|                let certificate = SecCertificateCreateWithData(nil, certificateData) else { return nil }
  387|      0|
  388|      0|            return certificate
  389|      0|        }
  390|      0|    }
  391|       |
  392|       |    /// Returns all public keys for the valid certificates in the bundle.
  393|      0|    public var publicKeys: [SecKey] {
  394|      0|        certificates.af.publicKeys
  395|      0|    }
  396|       |
  397|       |    /// Returns all pathnames for the resources identified by the provided file extensions.
  398|       |    ///
  399|       |    /// - Parameter types: The filename extensions locate.
  400|       |    ///
  401|       |    /// - Returns:         All pathnames for the given filename extensions.
  402|      0|    public func paths(forResourcesOfTypes types: [String]) -> [String] {
  403|      0|        Array(Set(types.flatMap { type.paths(forResourcesOfType: $0, inDirectory: nil) }))
  404|      0|    }
  405|       |}
  406|       |
  407|       |extension SecTrust: AlamofireExtended {}
  408|       |extension AlamofireExtension where ExtendedType == SecTrust {
  409|       |    /// Evaluates `self` after applying the `SecPolicy` value provided.
  410|       |    ///
  411|       |    /// - Parameter policy: The `SecPolicy` to apply to `self` before evaluation.
  412|       |    ///
  413|       |    /// - Throws:           Any `Error` from applying the `SecPolicy` or from evaluation.
  414|       |    @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  415|      0|    public func evaluate(afterApplying policy: SecPolicy) throws {
  416|      0|        try apply(policy: policy).af.evaluate()
  417|      0|    }
  418|       |
  419|       |    /// Attempts to validate `self` using the `SecPolicy` provided and transforming any error produced using the closure passed.
  420|       |    ///
  421|       |    /// - Parameters:
  422|       |    ///   - policy:        The `SecPolicy` used to evaluate `self`.
  423|       |    ///   - errorProducer: The closure used transform the failed `OSStatus` and `SecTrustResultType`.
  424|       |    /// - Throws:          Any `Error` from applying the `policy`, or the result of `errorProducer` if validation fails.
  425|       |    @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  426|       |    @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  427|       |    @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  428|       |    @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  429|      0|    public func validate(policy: SecPolicy, errorProducer: (_ status: OSStatus, _ result: SecTrustResultType) -> Error) throws {
  430|      0|        try apply(policy: policy).af.validate(errorProducer: errorProducer)
  431|      0|    }
  432|       |
  433|       |    /// Applies a `SecPolicy` to `self`, throwing if it fails.
  434|       |    ///
  435|       |    /// - Parameter policy: The `SecPolicy`.
  436|       |    ///
  437|       |    /// - Returns: `self`, with the policy applied.
  438|       |    /// - Throws: An `AFError.serverTrustEvaluationFailed` instance with a `.policyApplicationFailed` reason.
  439|      0|    public func apply(policy: SecPolicy) throws -> SecTrust {
  440|      0|        let status = SecTrustSetPolicies(type, policy)
  441|      0|
  442|      0|        guard status.af.isSuccess else {
  443|      0|            throw AFError.serverTrustEvaluationFailed(reason: .policyApplicationFailed(trust: type,
  444|      0|                                                                                       policy: policy,
  445|      0|                                                                                       status: status))
  446|      0|        }
  447|      0|
  448|      0|        return type
  449|      0|    }
  450|       |
  451|       |    /// Evaluate `self`, throwing an `Error` if evaluation fails.
  452|       |    ///
  453|       |    /// - Throws: `AFError.serverTrustEvaluationFailed` with reason `.trustValidationFailed` and associated error from
  454|       |    ///           the underlying evaluation.
  455|       |    @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  456|      0|    public func evaluate() throws {
  457|      0|        var error: CFError?
  458|      0|        let evaluationSucceeded = SecTrustEvaluateWithError(type, &error)
  459|      0|
  460|      0|        if !evaluationSucceeded {
  461|      0|            throw AFError.serverTrustEvaluationFailed(reason: .trustEvaluationFailed(error: error))
  462|      0|        }
  463|      0|    }
  464|       |
  465|       |    /// Validate `self`, passing any failure values through `errorProducer`.
  466|       |    ///
  467|       |    /// - Parameter errorProducer: The closure used to transform the failed `OSStatus` and `SecTrustResultType` into an
  468|       |    ///                            `Error`.
  469|       |    /// - Throws:                  The `Error` produced by the `errorProducer` closure.
  470|       |    @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  471|       |    @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  472|       |    @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  473|       |    @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  474|      0|    public func validate(errorProducer: (_ status: OSStatus, _ result: SecTrustResultType) -> Error) throws {
  475|      0|        var result = SecTrustResultType.invalid
  476|      0|        let status = SecTrustEvaluate(type, &result)
  477|      0|
  478|      0|        guard status.af.isSuccess && result.af.isSuccess else {
  479|      0|            throw errorProducer(status, result)
  480|      0|        }
  481|      0|    }
  482|       |
  483|       |    /// Sets a custom certificate chain on `self`, allowing full validation of a self-signed certificate and its chain.
  484|       |    ///
  485|       |    /// - Parameter certificates: The `SecCertificate`s to add to the chain.
  486|       |    /// - Throws:                 Any error produced when applying the new certificate chain.
  487|      0|    public func setAnchorCertificates(_ certificates: [SecCertificate]) throws {
  488|      0|        // Add additional anchor certificates.
  489|      0|        let status = SecTrustSetAnchorCertificates(type, certificates as CFArray)
  490|      0|        guard status.af.isSuccess else {
  491|      0|            throw AFError.serverTrustEvaluationFailed(reason: .settingAnchorCertificatesFailed(status: status,
  492|      0|                                                                                               certificates: certificates))
  493|      0|        }
  494|      0|
  495|      0|        // Trust only the set anchor certs.
  496|      0|        let onlyStatus = SecTrustSetAnchorCertificatesOnly(type, true)
  497|      0|        guard onlyStatus.af.isSuccess else {
  498|      0|            throw AFError.serverTrustEvaluationFailed(reason: .settingAnchorCertificatesFailed(status: onlyStatus,
  499|      0|                                                                                               certificates: certificates))
  500|      0|        }
  501|      0|    }
  502|       |
  503|       |    /// The public keys contained in `self`.
  504|      0|    public var publicKeys: [SecKey] {
  505|      0|        certificates.af.publicKeys
  506|      0|    }
  507|       |
  508|       |    /// The `SecCertificate`s contained i `self`.
  509|      0|    public var certificates: [SecCertificate] {
  510|      0|        (0..<SecTrustGetCertificateCount(type)).compactMap { index in
  511|      0|            SecTrustGetCertificateAtIndex(type, index)
  512|      0|        }
  513|      0|    }
  514|       |
  515|       |    /// The `Data` values for all certificates contained in `self`.
  516|      0|    public var certificateData: [Data] {
  517|      0|        certificates.af.data
  518|      0|    }
  519|       |
  520|       |    /// Validates `self` after applying `SecPolicy.af.default`. This evaluation does not validate the hostname.
  521|       |    ///
  522|       |    /// - Parameter host: The hostname, used only in the error output if validation fails.
  523|       |    /// - Throws: An `AFError.serverTrustEvaluationFailed` instance with a `.defaultEvaluationFailed` reason.
  524|      0|    public func performDefaultValidation(forHost host: String) throws {
  525|      0|        if #available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *) {
  526|      0|            try evaluate(afterApplying: SecPolicy.af.default)
  527|      0|        } else {
  528|      0|            try validate(policy: SecPolicy.af.default) { status, result in
  529|      0|                AFError.serverTrustEvaluationFailed(reason: .defaultEvaluationFailed(output: .init(host, type, status, result)))
  530|      0|            }
  531|      0|        }
  532|      0|    }
  533|       |
  534|       |    /// Validates `self` after applying `SecPolicy.af.hostname(host)`, which performs the default validation as well as
  535|       |    /// hostname validation.
  536|       |    ///
  537|       |    /// - Parameter host: The hostname to use in the validation.
  538|       |    /// - Throws:         An `AFError.serverTrustEvaluationFailed` instance with a `.defaultEvaluationFailed` reason.
  539|      0|    public func performValidation(forHost host: String) throws {
  540|      0|        if #available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *) {
  541|      0|            try evaluate(afterApplying: SecPolicy.af.hostname(host))
  542|      0|        } else {
  543|      0|            try validate(policy: SecPolicy.af.hostname(host)) { status, result in
  544|      0|                AFError.serverTrustEvaluationFailed(reason: .hostValidationFailed(output: .init(host, type, status, result)))
  545|      0|            }
  546|      0|        }
  547|      0|    }
  548|       |}
  549|       |
  550|       |extension SecPolicy: AlamofireExtended {}
  551|       |extension AlamofireExtension where ExtendedType == SecPolicy {
  552|       |    /// Creates a `SecPolicy` instance which will validate server certificates but not require a host name match.
  553|       |    public static let `default` = SecPolicyCreateSSL(true, nil)
  554|       |
  555|       |    /// Creates a `SecPolicy` instance which will validate server certificates and much match the provided hostname.
  556|       |    ///
  557|       |    /// - Parameter hostname: The hostname to validate against.
  558|       |    ///
  559|       |    /// - Returns:            The `SecPolicy`.
  560|      0|    public static func hostname(_ hostname: String) -> SecPolicy {
  561|      0|        SecPolicyCreateSSL(true, hostname as CFString)
  562|      0|    }
  563|       |
  564|       |    /// Creates a `SecPolicy` which checks the revocation of certificates.
  565|       |    ///
  566|       |    /// - Parameter options: The `RevocationTrustEvaluator.Options` for evaluation.
  567|       |    ///
  568|       |    /// - Returns:           The `SecPolicy`.
  569|       |    /// - Throws:            An `AFError.serverTrustEvaluationFailed` error with reason `.revocationPolicyCreationFailed`
  570|       |    ///                      if the policy cannot be created.
  571|      0|    public static func revocation(options: RevocationTrustEvaluator.Options) throws -> SecPolicy {
  572|      0|        guard let policy = SecPolicyCreateRevocation(options.rawValue) else {
  573|      0|            throw AFError.serverTrustEvaluationFailed(reason: .revocationPolicyCreationFailed)
  574|      0|        }
  575|      0|
  576|      0|        return policy
  577|      0|    }
  578|       |}
  579|       |
  580|       |extension Array: AlamofireExtended {}
  581|       |extension AlamofireExtension where ExtendedType == [SecCertificate] {
  582|       |    /// All `Data` values for the contained `SecCertificate`s.
  583|      0|    public var data: [Data] {
  584|      0|        type.map { SecCertificateCopyData($0) as Data }
  585|      0|    }
  586|       |
  587|       |    /// All public `SecKey` values for the contained `SecCertificate`s.
  588|      0|    public var publicKeys: [SecKey] {
  589|      0|        type.compactMap { $0.af.publicKey }
  590|      0|    }
  591|       |}
  592|       |
  593|       |extension SecCertificate: AlamofireExtended {}
  594|       |extension AlamofireExtension where ExtendedType == SecCertificate {
  595|       |    /// The public key for `self`, if it can be extracted.
  596|      0|    public var publicKey: SecKey? {
  597|      0|        let policy = SecPolicyCreateBasicX509()
  598|      0|        var trust: SecTrust?
  599|      0|        let trustCreationStatus = SecTrustCreateWithCertificates(type, policy, &trust)
  600|      0|
  601|      0|        guard let createdTrust = trust, trustCreationStatus == errSecSuccess else { return nil }
  602|      0|
  603|      0|        return SecTrustCopyPublicKey(createdTrust)
  604|      0|    }
  605|       |}
  606|       |
  607|       |extension OSStatus: AlamofireExtended {}
  608|       |extension AlamofireExtension where ExtendedType == OSStatus {
  609|       |    /// Returns whether `self` is `errSecSuccess`.
  610|      0|    public var isSuccess: Bool { type == errSecSuccess }
  611|       |}
  612|       |
  613|       |extension SecTrustResultType: AlamofireExtended {}
  614|       |extension AlamofireExtension where ExtendedType == SecTrustResultType {
  615|       |    /// Returns whether `self is `.unspecified` or `.proceed`.
  616|      0|    public var isSuccess: Bool {
  617|      0|        (type == .unspecified || type == .proceed)
  618|      0|    }
  619|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Session.swift:
    1|       |//
    2|       |//  Session.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// `Session` creates and manages Alamofire's `Request` types during their lifetimes. It also provides common
   28|       |/// functionality for all `Request`s, including queuing, interception, trust management, redirect handling, and response
   29|       |/// cache handling.
   30|       |open class Session {
   31|       |    /// Shared singleton instance used by all `AF.request` APIs. Cannot be modified.
   32|       |    public static let `default` = Session()
   33|       |
   34|       |    /// Underlying `URLSession` used to create `URLSessionTasks` for this instance, and for which this instance's
   35|       |    /// `delegate` handles `URLSessionDelegate` callbacks.
   36|       |    ///
   37|       |    /// - Note: This instance should **NOT** be used to interact with the underlying `URLSessionTask`s. Doing so will
   38|       |    ///         break internal Alamofire logic that tracks those tasks.
   39|       |    ///
   40|       |    public let session: URLSession
   41|       |    /// Instance's `SessionDelegate`, which handles the `URLSessionDelegate` methods and `Request` interaction.
   42|       |    public let delegate: SessionDelegate
   43|       |    /// Root `DispatchQueue` for all internal callbacks and state update. **MUST** be a serial queue.
   44|       |    public let rootQueue: DispatchQueue
   45|       |    /// Value determining whether this instance automatically calls `resume()` on all created `Request`s.
   46|       |    public let startRequestsImmediately: Bool
   47|       |    /// `DispatchQueue` on which `URLRequest`s are created asynchronously. By default this queue uses `rootQueue` as its
   48|       |    /// `target`, but a separate queue can be used if request creation is determined to be a bottleneck. Always profile
   49|       |    /// and test before introducing an additional queue.
   50|       |    public let requestQueue: DispatchQueue
   51|       |    /// `DispatchQueue` passed to all `Request`s on which they perform their response serialization. By default this
   52|       |    /// queue uses `rootQueue` as its `target` but a separate queue can be used if response serialization is determined
   53|       |    /// to be a bottleneck. Always profile and test before introducing an additional queue.
   54|       |    public let serializationQueue: DispatchQueue
   55|       |    /// `RequestInterceptor` used for all `Request` created by the instance. `RequestInterceptor`s can also be set on a
   56|       |    /// per-`Request` basis, in which case the `Request`'s interceptor takes precedence over this value.
   57|       |    public let interceptor: RequestInterceptor?
   58|       |    /// `ServerTrustManager` instance used to evaluate all trust challenges and provide certificate and key pinning.
   59|       |    public let serverTrustManager: ServerTrustManager?
   60|       |    /// `RedirectHandler` instance used to provide customization for request redirection.
   61|       |    public let redirectHandler: RedirectHandler?
   62|       |    /// `CachedResponseHandler` instance used to provide customization of cached response handling.
   63|       |    public let cachedResponseHandler: CachedResponseHandler?
   64|       |    /// `CompositeEventMonitor` used to compose Alamofire's `defaultEventMonitors` and any passed `EventMonitor`s.
   65|       |    public let eventMonitor: CompositeEventMonitor
   66|       |    /// `EventMonitor`s included in all instances. `[AlamofireNotifications()]` by default.
   67|      0|    public let defaultEventMonitors: [EventMonitor] = [AlamofireNotifications()]
   68|       |
   69|       |    /// Internal map between `Request`s and any `URLSessionTasks` that may be in flight for them.
   70|      0|    var requestTaskMap = RequestTaskMap()
   71|       |    /// `Set` of currently active `Request`s.
   72|      0|    var activeRequests: Set<Request> = []
   73|       |    /// Completion events awaiting `URLSessionTaskMetrics`.
   74|      0|    var waitingCompletions: [URLSessionTask: () -> Void] = [:]
   75|       |
   76|       |    /// Creates a `Session` from a `URLSession` and other parameters.
   77|       |    ///
   78|       |    /// - Note: When passing a `URLSession`, you must create the `URLSession` with a specific `delegateQueue` value and
   79|       |    ///         pass the `delegateQueue`'s `underlyingQueue` as the `rootQueue` parameter of this initializer.
   80|       |    ///
   81|       |    /// - Parameters:
   82|       |    ///   - session:                  Underlying `URLSession` for this instance.
   83|       |    ///   - delegate:                 `SessionDelegate` that handles `session`'s delegate callbacks as well as `Request`
   84|       |    ///                               interaction.
   85|       |    ///   - rootQueue:                Root `DispatchQueue` for all internal callbacks and state updates. **MUST** be a
   86|       |    ///                               serial queue.
   87|       |    ///   - startRequestsImmediately: Determines whether this instance will automatically start all `Request`s. `true`
   88|       |    ///                               by default. If set to `false`, all `Request`s created must have `.resume()` called.
   89|       |    ///                               on them for them to start.
   90|       |    ///   - requestQueue:             `DispatchQueue` on which to perform `URLRequest` creation. By default this queue
   91|       |    ///                               will use the `rootQueue` as its `target`. A separate queue can be used if it's
   92|       |    ///                               determined request creation is a bottleneck, but that should only be done after
   93|       |    ///                               careful testing and profiling. `nil` by default.
   94|       |    ///   - serializationQueue:       `DispatchQueue` on which to perform all response serialization. By default this
   95|       |    ///                               queue will use the `rootQueue` as its `target`. A separate queue can be used if
   96|       |    ///                               it's determined response serialization is a bottleneck, but that should only be
   97|       |    ///                               done after careful testing and profiling. `nil` by default.
   98|       |    ///   - interceptor:              `RequestInterceptor` to be used for all `Request`s created by this instance. `nil`
   99|       |    ///                               by default.
  100|       |    ///   - serverTrustManager:       `ServerTrustManager` to be used for all trust evaluations by this instance. `nil`
  101|       |    ///                               by default.
  102|       |    ///   - redirectHandler:          `RedirectHandler` to be used by all `Request`s created by this instance. `nil` by
  103|       |    ///                               default.
  104|       |    ///   - cachedResponseHandler:    `CachedResponseHandler` to be used by all `Request`s created by this instance.
  105|       |    ///                               `nil` by default.
  106|       |    ///   - eventMonitors:            Additional `EventMonitor`s used by the instance. Alamofire always adds a
  107|       |    ///                               `AlamofireNotifications` `EventMonitor` to the array passed here. `[]` by default.
  108|       |    public init(session: URLSession,
  109|       |                delegate: SessionDelegate,
  110|       |                rootQueue: DispatchQueue,
  111|       |                startRequestsImmediately: Bool = true,
  112|       |                requestQueue: DispatchQueue? = nil,
  113|       |                serializationQueue: DispatchQueue? = nil,
  114|       |                interceptor: RequestInterceptor? = nil,
  115|       |                serverTrustManager: ServerTrustManager? = nil,
  116|       |                redirectHandler: RedirectHandler? = nil,
  117|       |                cachedResponseHandler: CachedResponseHandler? = nil,
  118|      0|                eventMonitors: [EventMonitor] = []) {
  119|      0|        precondition(session.configuration.identifier == nil,
  120|      0|                     "Alamofire does not support background URLSessionConfigurations.")
  121|      0|        precondition(session.delegateQueue.underlyingQueue === rootQueue,
  122|      0|                     "Session(session:) initializer must be passed the DispatchQueue used as the delegateQueue's underlyingQueue as rootQueue.")
  123|      0|
  124|      0|        self.session = session
  125|      0|        self.delegate = delegate
  126|      0|        self.rootQueue = rootQueue
  127|      0|        self.startRequestsImmediately = startRequestsImmediately
  128|      0|        self.requestQueue = requestQueue ?? DispatchQueue(label: "\(rootQueue.label).requestQueue", target: rootQueue)
  129|      0|        self.serializationQueue = serializationQueue ?? DispatchQueue(label: "\(rootQueue.label).serializationQueue", target: rootQueue)
  130|      0|        self.interceptor = interceptor
  131|      0|        self.serverTrustManager = serverTrustManager
  132|      0|        self.redirectHandler = redirectHandler
  133|      0|        self.cachedResponseHandler = cachedResponseHandler
  134|      0|        eventMonitor = CompositeEventMonitor(monitors: defaultEventMonitors + eventMonitors)
  135|      0|        delegate.eventMonitor = eventMonitor
  136|      0|        delegate.stateProvider = self
  137|      0|    }
  138|       |
  139|       |    /// Creates a `Session` from a `URLSessionConfiguration`.
  140|       |    ///
  141|       |    /// - Note: This initializer lets Alamofire handle the creation of the underlying `URLSession` and its
  142|       |    ///         `delegateQueue`, and is the recommended initializer for most uses.
  143|       |    ///
  144|       |    /// - Parameters:
  145|       |    ///   - configuration:            `URLSessionConfiguration` to be used to create the underlying `URLSession`. Changes
  146|       |    ///                               to this value after being passed to this initializer will have no effect.
  147|       |    ///                               `URLSessionConfiguration.af.default` by default.
  148|       |    ///   - delegate:                 `SessionDelegate` that handles `session`'s delegate callbacks as well as `Request`
  149|       |    ///                               interaction. `SessionDelegate()` by default.
  150|       |    ///   - rootQueue:                Root `DispatchQueue` for all internal callbacks and state updates. **MUST** be a
  151|       |    ///                               serial queue. `DispatchQueue(label: "org.alamofire.session.rootQueue")` by default.
  152|       |    ///   - startRequestsImmediately: Determines whether this instance will automatically start all `Request`s. `true`
  153|       |    ///                               by default. If set to `false`, all `Request`s created must have `.resume()` called.
  154|       |    ///                               on them for them to start.
  155|       |    ///   - requestQueue:             `DispatchQueue` on which to perform `URLRequest` creation. By default this queue
  156|       |    ///                               will use the `rootQueue` as its `target`. A separate queue can be used if it's
  157|       |    ///                               determined request creation is a bottleneck, but that should only be done after
  158|       |    ///                               careful testing and profiling. `nil` by default.
  159|       |    ///   - serializationQueue:       `DispatchQueue` on which to perform all response serialization. By default this
  160|       |    ///                               queue will use the `rootQueue` as its `target`. A separate queue can be used if
  161|       |    ///                               it's determined response serialization is a bottleneck, but that should only be
  162|       |    ///                               done after careful testing and profiling. `nil` by default.
  163|       |    ///   - interceptor:              `RequestInterceptor` to be used for all `Request`s created by this instance. `nil`
  164|       |    ///                               by default.
  165|       |    ///   - serverTrustManager:       `ServerTrustManager` to be used for all trust evaluations by this instance. `nil`
  166|       |    ///                               by default.
  167|       |    ///   - redirectHandler:          `RedirectHandler` to be used by all `Request`s created by this instance. `nil` by
  168|       |    ///                               default.
  169|       |    ///   - cachedResponseHandler:    `CachedResponseHandler` to be used by all `Request`s created by this instance.
  170|       |    ///                               `nil` by default.
  171|       |    ///   - eventMonitors:            Additional `EventMonitor`s used by the instance. Alamofire always adds a
  172|       |    ///                               `AlamofireNotifications` `EventMonitor` to the array passed here. `[]` by default.
  173|       |    public convenience init(configuration: URLSessionConfiguration = URLSessionConfiguration.af.default,
  174|       |                            delegate: SessionDelegate = SessionDelegate(),
  175|       |                            rootQueue: DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"),
  176|       |                            startRequestsImmediately: Bool = true,
  177|       |                            requestQueue: DispatchQueue? = nil,
  178|       |                            serializationQueue: DispatchQueue? = nil,
  179|       |                            interceptor: RequestInterceptor? = nil,
  180|       |                            serverTrustManager: ServerTrustManager? = nil,
  181|       |                            redirectHandler: RedirectHandler? = nil,
  182|       |                            cachedResponseHandler: CachedResponseHandler? = nil,
  183|      0|                            eventMonitors: [EventMonitor] = []) {
  184|      0|        precondition(configuration.identifier == nil, "Alamofire does not support background URLSessionConfigurations.")
  185|      0|
  186|      0|        let delegateQueue = OperationQueue(maxConcurrentOperationCount: 1, underlyingQueue: rootQueue, name: "org.alamofire.session.sessionDelegateQueue")
  187|      0|        let session = URLSession(configuration: configuration, delegate: delegate, delegateQueue: delegateQueue)
  188|      0|
  189|      0|        self.init(session: session,
  190|      0|                  delegate: delegate,
  191|      0|                  rootQueue: rootQueue,
  192|      0|                  startRequestsImmediately: startRequestsImmediately,
  193|      0|                  requestQueue: requestQueue,
  194|      0|                  serializationQueue: serializationQueue,
  195|      0|                  interceptor: interceptor,
  196|      0|                  serverTrustManager: serverTrustManager,
  197|      0|                  redirectHandler: redirectHandler,
  198|      0|                  cachedResponseHandler: cachedResponseHandler,
  199|      0|                  eventMonitors: eventMonitors)
  200|      0|    }
  201|       |
  202|      0|    deinit {
  203|      0|        finishRequestsForDeinit()
  204|      0|        session.invalidateAndCancel()
  205|      0|    }
  206|       |
  207|       |    // MARK: - All Requests API
  208|       |
  209|       |    /// Perform an action on all active `Request`s.
  210|       |    ///
  211|       |    /// - Note: The provided `action` closure is performed asynchronously, meaning that some `Request`s may complete and
  212|       |    ///         be unavailable by time it runs. Additionally, this action is performed on the instances's `rootQueue`,
  213|       |    ///         so care should be taken that actions are fast. Once the work on the `Request`s is complete, any
  214|       |    ///         additional work should be performed on another queue.
  215|       |    ///
  216|       |    /// - Parameters:
  217|       |    ///   - action:     Closure to perform with all `Request`s.
  218|      0|    public func withAllRequests(perform action: @escaping (Set<Request>) -> Void) {
  219|      0|        rootQueue.async {
  220|      0|            action(self.activeRequests)
  221|      0|        }
  222|      0|    }
  223|       |
  224|       |    /// Cancel all active `Request`s, optionally calling a completion handler when complete.
  225|       |    ///
  226|       |    /// - Note: This is an asynchronous operation and does not block the creation of future `Request`s. Cancelled
  227|       |    ///         `Request`s may not cancel immediately due internal work, and may not cancel at all if they are close to
  228|       |    ///         completion when cancelled.
  229|       |    ///
  230|       |    /// - Parameters:
  231|       |    ///   - queue:      `DispatchQueue` on which the completion handler is run. `.main` by default.
  232|       |    ///   - completion: Closure to be called when all `Request`s have been cancelled.
  233|      0|    public func cancelAllRequests(completingOnQueue queue: DispatchQueue = .main, completion: (() -> Void)? = nil) {
  234|      0|        withAllRequests { requests in
  235|      0|            requests.forEach { $0.cancel() }
  236|      0|            queue.async {
  237|      0|                completion?()
  238|      0|            }
  239|      0|        }
  240|      0|    }
  241|       |
  242|       |    // MARK: - DataRequest
  243|       |
  244|       |    /// Closure which provides a `URLRequest` for mutation.
  245|       |    public typealias RequestModifier = (inout URLRequest) throws -> Void
  246|       |
  247|       |    struct RequestConvertible: URLRequestConvertible {
  248|       |        let url: URLConvertible
  249|       |        let method: HTTPMethod
  250|       |        let parameters: Parameters?
  251|       |        let encoding: ParameterEncoding
  252|       |        let headers: HTTPHeaders?
  253|       |        let requestModifier: RequestModifier?
  254|       |
  255|      0|        func asURLRequest() throws -> URLRequest {
  256|      0|            var request = try URLRequest(url: url, method: method, headers: headers)
  257|      0|            try requestModifier?(&request)
  258|      0|
  259|      0|            return try encoding.encode(request, with: parameters)
  260|      0|        }
  261|       |    }
  262|       |
  263|       |    /// Creates a `DataRequest` from a `URLRequest` created using the passed components and a `RequestInterceptor`.
  264|       |    ///
  265|       |    /// - Parameters:
  266|       |    ///   - convertible:     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  267|       |    ///   - method:          `HTTPMethod` for the `URLRequest`. `.get` by default.
  268|       |    ///   - parameters:      `Parameters` (a.k.a. `[String: Any]`) value to be encoded into the `URLRequest`. `nil` by
  269|       |    ///                      default.
  270|       |    ///   - encoding:        `ParameterEncoding` to be used to encode the `parameters` value into the `URLRequest`.
  271|       |    ///                      `URLEncoding.default` by default.
  272|       |    ///   - headers:         `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  273|       |    ///   - interceptor:     `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  274|       |    ///   - requestModifier: `RequestModifier` which will be applied to the `URLRequest` created from the provided
  275|       |    ///                      parameters. `nil` by default.
  276|       |    ///
  277|       |    /// - Returns:       The created `DataRequest`.
  278|       |    open func request(_ convertible: URLConvertible,
  279|       |                      method: HTTPMethod = .get,
  280|       |                      parameters: Parameters? = nil,
  281|       |                      encoding: ParameterEncoding = URLEncoding.default,
  282|       |                      headers: HTTPHeaders? = nil,
  283|       |                      interceptor: RequestInterceptor? = nil,
  284|      0|                      requestModifier: RequestModifier? = nil) -> DataRequest {
  285|      0|        let convertible = RequestConvertible(url: convertible,
  286|      0|                                             method: method,
  287|      0|                                             parameters: parameters,
  288|      0|                                             encoding: encoding,
  289|      0|                                             headers: headers,
  290|      0|                                             requestModifier: requestModifier)
  291|      0|
  292|      0|        return request(convertible, interceptor: interceptor)
  293|      0|    }
  294|       |
  295|       |    struct RequestEncodableConvertible<Parameters: Encodable>: URLRequestConvertible {
  296|       |        let url: URLConvertible
  297|       |        let method: HTTPMethod
  298|       |        let parameters: Parameters?
  299|       |        let encoder: ParameterEncoder
  300|       |        let headers: HTTPHeaders?
  301|       |        let requestModifier: RequestModifier?
  302|       |
  303|      0|        func asURLRequest() throws -> URLRequest {
  304|      0|            var request = try URLRequest(url: url, method: method, headers: headers)
  305|      0|            try requestModifier?(&request)
  306|      0|
  307|      0|            return try parameters.map { try encoder.encode($0, into: request) } ?? request
  308|      0|        }
  309|       |    }
  310|       |
  311|       |    /// Creates a `DataRequest` from a `URLRequest` created using the passed components, `Encodable` parameters, and a
  312|       |    /// `RequestInterceptor`.
  313|       |    ///
  314|       |    /// - Parameters:
  315|       |    ///   - convertible: `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  316|       |    ///   - method:      `HTTPMethod` for the `URLRequest`. `.get` by default.
  317|       |    ///   - parameters:  `Encodable` value to be encoded into the `URLRequest`. `nil` by default.
  318|       |    ///   - encoder:     `ParameterEncoder` to be used to encode the `parameters` value into the `URLRequest`.
  319|       |    ///                  `URLEncodedFormParameterEncoder.default` by default.
  320|       |    ///   - headers:     `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  321|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  322|       |    ///
  323|       |    /// - Returns:       The created `DataRequest`.
  324|       |    open func request<Parameters: Encodable>(_ convertible: URLConvertible,
  325|       |                                             method: HTTPMethod = .get,
  326|       |                                             parameters: Parameters? = nil,
  327|       |                                             encoder: ParameterEncoder = URLEncodedFormParameterEncoder.default,
  328|       |                                             headers: HTTPHeaders? = nil,
  329|       |                                             interceptor: RequestInterceptor? = nil,
  330|      0|                                             requestModifier: RequestModifier? = nil) -> DataRequest {
  331|      0|        let convertible = RequestEncodableConvertible(url: convertible,
  332|      0|                                                      method: method,
  333|      0|                                                      parameters: parameters,
  334|      0|                                                      encoder: encoder,
  335|      0|                                                      headers: headers,
  336|      0|                                                      requestModifier: requestModifier)
  337|      0|
  338|      0|        return request(convertible, interceptor: interceptor)
  339|      0|    }
  340|       |
  341|       |    /// Creates a `DataRequest` from a `URLRequestConvertible` value and a `RequestInterceptor`.
  342|       |    ///
  343|       |    /// - Parameters:
  344|       |    ///   - convertible: `URLRequestConvertible` value to be used to create the `URLRequest`.
  345|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  346|       |    ///
  347|       |    /// - Returns:       The created `DataRequest`.
  348|      0|    open func request(_ convertible: URLRequestConvertible, interceptor: RequestInterceptor? = nil) -> DataRequest {
  349|      0|        let request = DataRequest(convertible: convertible,
  350|      0|                                  underlyingQueue: rootQueue,
  351|      0|                                  serializationQueue: serializationQueue,
  352|      0|                                  eventMonitor: eventMonitor,
  353|      0|                                  interceptor: interceptor,
  354|      0|                                  delegate: self)
  355|      0|
  356|      0|        perform(request)
  357|      0|
  358|      0|        return request
  359|      0|    }
  360|       |
  361|       |    // MARK: - DataStreamRequest
  362|       |
  363|       |    /// Creates a `DataStreamRequest` from the passed components, `Encodable` parameters, and `RequestInterceptor`.
  364|       |    ///
  365|       |    /// - Parameters:
  366|       |    ///   - convertible:                      `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  367|       |    ///   - method:                           `HTTPMethod` for the `URLRequest`. `.get` by default.
  368|       |    ///   - parameters:                       `Encodable` value to be encoded into the `URLRequest`. `nil` by default.
  369|       |    ///   - encoder:                          `ParameterEncoder` to be used to encode the `parameters` value into the
  370|       |    ///                                       `URLRequest`.
  371|       |    ///                                       `URLEncodedFormParameterEncoder.default` by default.
  372|       |    ///   - headers:                          `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  373|       |    ///   - automaticallyCancelOnStreamError: `Bool` indicating whether the instance should be canceled when an `Error`
  374|       |    ///                                       is thrown while serializing stream `Data`. `false` by default.
  375|       |    ///   - interceptor:                      `RequestInterceptor` value to be used by the returned `DataRequest`. `nil`
  376|       |    ///                                       by default.
  377|       |    ///   - requestModifier:                  `RequestModifier` which will be applied to the `URLRequest` created from
  378|       |    ///                                       the provided parameters. `nil` by default.
  379|       |    ///
  380|       |    /// - Returns:       The created `DataStream` request.
  381|       |    open func streamRequest<Parameters: Encodable>(_ convertible: URLConvertible,
  382|       |                                                   method: HTTPMethod = .get,
  383|       |                                                   parameters: Parameters? = nil,
  384|       |                                                   encoder: ParameterEncoder = URLEncodedFormParameterEncoder.default,
  385|       |                                                   headers: HTTPHeaders? = nil,
  386|       |                                                   automaticallyCancelOnStreamError: Bool = false,
  387|       |                                                   interceptor: RequestInterceptor? = nil,
  388|      0|                                                   requestModifier: RequestModifier? = nil) -> DataStreamRequest {
  389|      0|        let convertible = RequestEncodableConvertible(url: convertible,
  390|      0|                                                      method: method,
  391|      0|                                                      parameters: parameters,
  392|      0|                                                      encoder: encoder,
  393|      0|                                                      headers: headers,
  394|      0|                                                      requestModifier: requestModifier)
  395|      0|
  396|      0|        return streamRequest(convertible,
  397|      0|                             automaticallyCancelOnStreamError: automaticallyCancelOnStreamError,
  398|      0|                             interceptor: interceptor)
  399|      0|    }
  400|       |
  401|       |    /// Creates a `DataStreamRequest` from the passed components and `RequestInterceptor`.
  402|       |    ///
  403|       |    /// - Parameters:
  404|       |    ///   - convertible:                      `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  405|       |    ///   - method:                           `HTTPMethod` for the `URLRequest`. `.get` by default.
  406|       |    ///   - headers:                          `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  407|       |    ///   - automaticallyCancelOnStreamError: `Bool` indicating whether the instance should be canceled when an `Error`
  408|       |    ///                                       is thrown while serializing stream `Data`. `false` by default.
  409|       |    ///   - interceptor:                      `RequestInterceptor` value to be used by the returned `DataRequest`. `nil`
  410|       |    ///                                       by default.
  411|       |    ///   - requestModifier:                  `RequestModifier` which will be applied to the `URLRequest` created from
  412|       |    ///                                       the provided parameters. `nil` by default.
  413|       |    ///
  414|       |    /// - Returns:       The created `DataStream` request.
  415|       |    open func streamRequest(_ convertible: URLConvertible,
  416|       |                            method: HTTPMethod = .get,
  417|       |                            headers: HTTPHeaders? = nil,
  418|       |                            automaticallyCancelOnStreamError: Bool = false,
  419|       |                            interceptor: RequestInterceptor? = nil,
  420|      0|                            requestModifier: RequestModifier? = nil) -> DataStreamRequest {
  421|      0|        let convertible = RequestEncodableConvertible(url: convertible,
  422|      0|                                                      method: method,
  423|      0|                                                      parameters: Optional<Empty>.none,
  424|      0|                                                      encoder: URLEncodedFormParameterEncoder.default,
  425|      0|                                                      headers: headers,
  426|      0|                                                      requestModifier: requestModifier)
  427|      0|
  428|      0|        return streamRequest(convertible,
  429|      0|                             automaticallyCancelOnStreamError: automaticallyCancelOnStreamError,
  430|      0|                             interceptor: interceptor)
  431|      0|    }
  432|       |
  433|       |    /// Creates a `DataStreamRequest` from the passed `URLRequestConvertible` value and `RequestInterceptor`.
  434|       |    ///
  435|       |    /// - Parameters:
  436|       |    ///   - convertible:                      `URLRequestConvertible` value to be used to create the `URLRequest`.
  437|       |    ///   - automaticallyCancelOnStreamError: `Bool` indicating whether the instance should be canceled when an `Error`
  438|       |    ///                                       is thrown while serializing stream `Data`. `false` by default.
  439|       |    ///   - interceptor:                      `RequestInterceptor` value to be used by the returned `DataRequest`. `nil`
  440|       |    ///                                        by default.
  441|       |    ///
  442|       |    /// - Returns:       The created `DataStreamRequest`.
  443|       |    open func streamRequest(_ convertible: URLRequestConvertible,
  444|       |                            automaticallyCancelOnStreamError: Bool = false,
  445|      0|                            interceptor: RequestInterceptor? = nil) -> DataStreamRequest {
  446|      0|        let request = DataStreamRequest(convertible: convertible,
  447|      0|                                        automaticallyCancelOnStreamError: automaticallyCancelOnStreamError,
  448|      0|                                        underlyingQueue: rootQueue,
  449|      0|                                        serializationQueue: serializationQueue,
  450|      0|                                        eventMonitor: eventMonitor,
  451|      0|                                        interceptor: interceptor,
  452|      0|                                        delegate: self)
  453|      0|
  454|      0|        perform(request)
  455|      0|
  456|      0|        return request
  457|      0|    }
  458|       |
  459|       |    // MARK: - DownloadRequest
  460|       |
  461|       |    /// Creates a `DownloadRequest` using a `URLRequest` created using the passed components, `RequestInterceptor`, and
  462|       |    /// `Destination`.
  463|       |    ///
  464|       |    /// - Parameters:
  465|       |    ///   - convertible:     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  466|       |    ///   - method:          `HTTPMethod` for the `URLRequest`. `.get` by default.
  467|       |    ///   - parameters:      `Parameters` (a.k.a. `[String: Any]`) value to be encoded into the `URLRequest`. `nil` by
  468|       |    ///                      default.
  469|       |    ///   - encoding:        `ParameterEncoding` to be used to encode the `parameters` value into the `URLRequest`.
  470|       |    ///                      Defaults to `URLEncoding.default`.
  471|       |    ///   - headers:         `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  472|       |    ///   - interceptor:     `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  473|       |    ///   - requestModifier: `RequestModifier` which will be applied to the `URLRequest` created from the provided
  474|       |    ///                      parameters. `nil` by default.
  475|       |    ///   - destination:     `DownloadRequest.Destination` closure used to determine how and where the downloaded file
  476|       |    ///                      should be moved. `nil` by default.
  477|       |    ///
  478|       |    /// - Returns:           The created `DownloadRequest`.
  479|       |    open func download(_ convertible: URLConvertible,
  480|       |                       method: HTTPMethod = .get,
  481|       |                       parameters: Parameters? = nil,
  482|       |                       encoding: ParameterEncoding = URLEncoding.default,
  483|       |                       headers: HTTPHeaders? = nil,
  484|       |                       interceptor: RequestInterceptor? = nil,
  485|       |                       requestModifier: RequestModifier? = nil,
  486|      0|                       to destination: DownloadRequest.Destination? = nil) -> DownloadRequest {
  487|      0|        let convertible = RequestConvertible(url: convertible,
  488|      0|                                             method: method,
  489|      0|                                             parameters: parameters,
  490|      0|                                             encoding: encoding,
  491|      0|                                             headers: headers,
  492|      0|                                             requestModifier: requestModifier)
  493|      0|
  494|      0|        return download(convertible, interceptor: interceptor, to: destination)
  495|      0|    }
  496|       |
  497|       |    /// Creates a `DownloadRequest` from a `URLRequest` created using the passed components, `Encodable` parameters, and
  498|       |    /// a `RequestInterceptor`.
  499|       |    ///
  500|       |    /// - Parameters:
  501|       |    ///   - convertible:     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  502|       |    ///   - method:          `HTTPMethod` for the `URLRequest`. `.get` by default.
  503|       |    ///   - parameters:      Value conforming to `Encodable` to be encoded into the `URLRequest`. `nil` by default.
  504|       |    ///   - encoder:         `ParameterEncoder` to be used to encode the `parameters` value into the `URLRequest`.
  505|       |    ///                      Defaults to `URLEncodedFormParameterEncoder.default`.
  506|       |    ///   - headers:         `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  507|       |    ///   - interceptor:     `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  508|       |    ///   - requestModifier: `RequestModifier` which will be applied to the `URLRequest` created from the provided
  509|       |    ///                      parameters. `nil` by default.
  510|       |    ///   - destination:     `DownloadRequest.Destination` closure used to determine how and where the downloaded file
  511|       |    ///                      should be moved. `nil` by default.
  512|       |    ///
  513|       |    /// - Returns:           The created `DownloadRequest`.
  514|       |    open func download<Parameters: Encodable>(_ convertible: URLConvertible,
  515|       |                                              method: HTTPMethod = .get,
  516|       |                                              parameters: Parameters? = nil,
  517|       |                                              encoder: ParameterEncoder = URLEncodedFormParameterEncoder.default,
  518|       |                                              headers: HTTPHeaders? = nil,
  519|       |                                              interceptor: RequestInterceptor? = nil,
  520|       |                                              requestModifier: RequestModifier? = nil,
  521|      0|                                              to destination: DownloadRequest.Destination? = nil) -> DownloadRequest {
  522|      0|        let convertible = RequestEncodableConvertible(url: convertible,
  523|      0|                                                      method: method,
  524|      0|                                                      parameters: parameters,
  525|      0|                                                      encoder: encoder,
  526|      0|                                                      headers: headers,
  527|      0|                                                      requestModifier: requestModifier)
  528|      0|
  529|      0|        return download(convertible, interceptor: interceptor, to: destination)
  530|      0|    }
  531|       |
  532|       |    /// Creates a `DownloadRequest` from a `URLRequestConvertible` value, a `RequestInterceptor`, and a `Destination`.
  533|       |    ///
  534|       |    /// - Parameters:
  535|       |    ///   - convertible: `URLRequestConvertible` value to be used to create the `URLRequest`.
  536|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  537|       |    ///   - destination: `DownloadRequest.Destination` closure used to determine how and where the downloaded file
  538|       |    ///                  should be moved. `nil` by default.
  539|       |    ///
  540|       |    /// - Returns:       The created `DownloadRequest`.
  541|       |    open func download(_ convertible: URLRequestConvertible,
  542|       |                       interceptor: RequestInterceptor? = nil,
  543|      0|                       to destination: DownloadRequest.Destination? = nil) -> DownloadRequest {
  544|      0|        let request = DownloadRequest(downloadable: .request(convertible),
  545|      0|                                      underlyingQueue: rootQueue,
  546|      0|                                      serializationQueue: serializationQueue,
  547|      0|                                      eventMonitor: eventMonitor,
  548|      0|                                      interceptor: interceptor,
  549|      0|                                      delegate: self,
  550|      0|                                      destination: destination ?? DownloadRequest.defaultDestination)
  551|      0|
  552|      0|        perform(request)
  553|      0|
  554|      0|        return request
  555|      0|    }
  556|       |
  557|       |    /// Creates a `DownloadRequest` from the `resumeData` produced from a previously cancelled `DownloadRequest`, as
  558|       |    /// well as a `RequestInterceptor`, and a `Destination`.
  559|       |    ///
  560|       |    /// - Note: If `destination` is not specified, the download will be moved to a temporary location determined by
  561|       |    ///         Alamofire. The file will not be deleted until the system purges the temporary files.
  562|       |    ///
  563|       |    /// - Note: On some versions of all Apple platforms (iOS 10 - 10.2, macOS 10.12 - 10.12.2, tvOS 10 - 10.1, watchOS 3 - 3.1.1),
  564|       |    /// `resumeData` is broken on background URL session configurations. There's an underlying bug in the `resumeData`
  565|       |    /// generation logic where the data is written incorrectly and will always fail to resume the download. For more
  566|       |    /// information about the bug and possible workarounds, please refer to the [this Stack Overflow post](http://stackoverflow.com/a/39347461/1342462).
  567|       |    ///
  568|       |    /// - Parameters:
  569|       |    ///   - data:        The resume data from a previously cancelled `DownloadRequest` or `URLSessionDownloadTask`.
  570|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  571|       |    ///   - destination: `DownloadRequest.Destination` closure used to determine how and where the downloaded file
  572|       |    ///                  should be moved. `nil` by default.
  573|       |    ///
  574|       |    /// - Returns:       The created `DownloadRequest`.
  575|       |    open func download(resumingWith data: Data,
  576|       |                       interceptor: RequestInterceptor? = nil,
  577|      0|                       to destination: DownloadRequest.Destination? = nil) -> DownloadRequest {
  578|      0|        let request = DownloadRequest(downloadable: .resumeData(data),
  579|      0|                                      underlyingQueue: rootQueue,
  580|      0|                                      serializationQueue: serializationQueue,
  581|      0|                                      eventMonitor: eventMonitor,
  582|      0|                                      interceptor: interceptor,
  583|      0|                                      delegate: self,
  584|      0|                                      destination: destination ?? DownloadRequest.defaultDestination)
  585|      0|
  586|      0|        perform(request)
  587|      0|
  588|      0|        return request
  589|      0|    }
  590|       |
  591|       |    // MARK: - UploadRequest
  592|       |
  593|       |    struct ParameterlessRequestConvertible: URLRequestConvertible {
  594|       |        let url: URLConvertible
  595|       |        let method: HTTPMethod
  596|       |        let headers: HTTPHeaders?
  597|       |        let requestModifier: RequestModifier?
  598|       |
  599|      0|        func asURLRequest() throws -> URLRequest {
  600|      0|            var request = try URLRequest(url: url, method: method, headers: headers)
  601|      0|            try requestModifier?(&request)
  602|      0|
  603|      0|            return request
  604|      0|        }
  605|       |    }
  606|       |
  607|       |    struct Upload: UploadConvertible {
  608|       |        let request: URLRequestConvertible
  609|       |        let uploadable: UploadableConvertible
  610|       |
  611|      0|        func createUploadable() throws -> UploadRequest.Uploadable {
  612|      0|            try uploadable.createUploadable()
  613|      0|        }
  614|       |
  615|      0|        func asURLRequest() throws -> URLRequest {
  616|      0|            try request.asURLRequest()
  617|      0|        }
  618|       |    }
  619|       |
  620|       |    // MARK: Data
  621|       |
  622|       |    /// Creates an `UploadRequest` for the given `Data`, `URLRequest` components, and `RequestInterceptor`.
  623|       |    ///
  624|       |    /// - Parameters:
  625|       |    ///   - data:            The `Data` to upload.
  626|       |    ///   - convertible:     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  627|       |    ///   - method:          `HTTPMethod` for the `URLRequest`. `.post` by default.
  628|       |    ///   - headers:         `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  629|       |    ///   - interceptor:     `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  630|       |    ///   - fileManager:     `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  631|       |    ///                      default.
  632|       |    ///   - requestModifier: `RequestModifier` which will be applied to the `URLRequest` created from the provided
  633|       |    ///                      parameters. `nil` by default.
  634|       |    ///
  635|       |    /// - Returns:           The created `UploadRequest`.
  636|       |    open func upload(_ data: Data,
  637|       |                     to convertible: URLConvertible,
  638|       |                     method: HTTPMethod = .post,
  639|       |                     headers: HTTPHeaders? = nil,
  640|       |                     interceptor: RequestInterceptor? = nil,
  641|       |                     fileManager: FileManager = .default,
  642|      0|                     requestModifier: RequestModifier? = nil) -> UploadRequest {
  643|      0|        let convertible = ParameterlessRequestConvertible(url: convertible,
  644|      0|                                                          method: method,
  645|      0|                                                          headers: headers,
  646|      0|                                                          requestModifier: requestModifier)
  647|      0|
  648|      0|        return upload(data, with: convertible, interceptor: interceptor, fileManager: fileManager)
  649|      0|    }
  650|       |
  651|       |    /// Creates an `UploadRequest` for the given `Data` using the `URLRequestConvertible` value and `RequestInterceptor`.
  652|       |    ///
  653|       |    /// - Parameters:
  654|       |    ///   - data:        The `Data` to upload.
  655|       |    ///   - convertible: `URLRequestConvertible` value to be used to create the `URLRequest`.
  656|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  657|       |    ///   - fileManager: `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  658|       |    ///                  default.
  659|       |    ///
  660|       |    /// - Returns:       The created `UploadRequest`.
  661|       |    open func upload(_ data: Data,
  662|       |                     with convertible: URLRequestConvertible,
  663|       |                     interceptor: RequestInterceptor? = nil,
  664|      0|                     fileManager: FileManager = .default) -> UploadRequest {
  665|      0|        upload(.data(data), with: convertible, interceptor: interceptor, fileManager: fileManager)
  666|      0|    }
  667|       |
  668|       |    // MARK: File
  669|       |
  670|       |    /// Creates an `UploadRequest` for the file at the given file `URL`, using a `URLRequest` from the provided
  671|       |    /// components and `RequestInterceptor`.
  672|       |    ///
  673|       |    /// - Parameters:
  674|       |    ///   - fileURL:         The `URL` of the file to upload.
  675|       |    ///   - convertible:     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  676|       |    ///   - method:          `HTTPMethod` for the `URLRequest`. `.post` by default.
  677|       |    ///   - headers:         `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  678|       |    ///   - interceptor:     `RequestInterceptor` value to be used by the returned `UploadRequest`. `nil` by default.
  679|       |    ///   - fileManager:     `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  680|       |    ///                      default.
  681|       |    ///   - requestModifier: `RequestModifier` which will be applied to the `URLRequest` created from the provided
  682|       |    ///                      parameters. `nil` by default.
  683|       |    ///
  684|       |    /// - Returns:           The created `UploadRequest`.
  685|       |    open func upload(_ fileURL: URL,
  686|       |                     to convertible: URLConvertible,
  687|       |                     method: HTTPMethod = .post,
  688|       |                     headers: HTTPHeaders? = nil,
  689|       |                     interceptor: RequestInterceptor? = nil,
  690|       |                     fileManager: FileManager = .default,
  691|      0|                     requestModifier: RequestModifier? = nil) -> UploadRequest {
  692|      0|        let convertible = ParameterlessRequestConvertible(url: convertible,
  693|      0|                                                          method: method,
  694|      0|                                                          headers: headers,
  695|      0|                                                          requestModifier: requestModifier)
  696|      0|
  697|      0|        return upload(fileURL, with: convertible, interceptor: interceptor, fileManager: fileManager)
  698|      0|    }
  699|       |
  700|       |    /// Creates an `UploadRequest` for the file at the given file `URL` using the `URLRequestConvertible` value and
  701|       |    /// `RequestInterceptor`.
  702|       |    ///
  703|       |    /// - Parameters:
  704|       |    ///   - fileURL:     The `URL` of the file to upload.
  705|       |    ///   - convertible: `URLRequestConvertible` value to be used to create the `URLRequest`.
  706|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  707|       |    ///   - fileManager: `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  708|       |    ///                  default.
  709|       |    ///
  710|       |    /// - Returns:       The created `UploadRequest`.
  711|       |    open func upload(_ fileURL: URL,
  712|       |                     with convertible: URLRequestConvertible,
  713|       |                     interceptor: RequestInterceptor? = nil,
  714|      0|                     fileManager: FileManager = .default) -> UploadRequest {
  715|      0|        upload(.file(fileURL, shouldRemove: false), with: convertible, interceptor: interceptor, fileManager: fileManager)
  716|      0|    }
  717|       |
  718|       |    // MARK: InputStream
  719|       |
  720|       |    /// Creates an `UploadRequest` from the `InputStream` provided using a `URLRequest` from the provided components and
  721|       |    /// `RequestInterceptor`.
  722|       |    ///
  723|       |    /// - Parameters:
  724|       |    ///   - stream:          The `InputStream` that provides the data to upload.
  725|       |    ///   - convertible:     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  726|       |    ///   - method:          `HTTPMethod` for the `URLRequest`. `.post` by default.
  727|       |    ///   - headers:         `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  728|       |    ///   - interceptor:     `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  729|       |    ///   - fileManager:     `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  730|       |    ///                      default.
  731|       |    ///   - requestModifier: `RequestModifier` which will be applied to the `URLRequest` created from the provided
  732|       |    ///                      parameters. `nil` by default.
  733|       |    ///
  734|       |    /// - Returns:           The created `UploadRequest`.
  735|       |    open func upload(_ stream: InputStream,
  736|       |                     to convertible: URLConvertible,
  737|       |                     method: HTTPMethod = .post,
  738|       |                     headers: HTTPHeaders? = nil,
  739|       |                     interceptor: RequestInterceptor? = nil,
  740|       |                     fileManager: FileManager = .default,
  741|      0|                     requestModifier: RequestModifier? = nil) -> UploadRequest {
  742|      0|        let convertible = ParameterlessRequestConvertible(url: convertible,
  743|      0|                                                          method: method,
  744|      0|                                                          headers: headers,
  745|      0|                                                          requestModifier: requestModifier)
  746|      0|
  747|      0|        return upload(stream, with: convertible, interceptor: interceptor, fileManager: fileManager)
  748|      0|    }
  749|       |
  750|       |    /// Creates an `UploadRequest` from the provided `InputStream` using the `URLRequestConvertible` value and
  751|       |    /// `RequestInterceptor`.
  752|       |    ///
  753|       |    /// - Parameters:
  754|       |    ///   - stream:      The `InputStream` that provides the data to upload.
  755|       |    ///   - convertible: `URLRequestConvertible` value to be used to create the `URLRequest`.
  756|       |    ///   - interceptor: `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  757|       |    ///   - fileManager: `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  758|       |    ///                  default.
  759|       |    ///
  760|       |    /// - Returns:       The created `UploadRequest`.
  761|       |    open func upload(_ stream: InputStream,
  762|       |                     with convertible: URLRequestConvertible,
  763|       |                     interceptor: RequestInterceptor? = nil,
  764|      0|                     fileManager: FileManager = .default) -> UploadRequest {
  765|      0|        upload(.stream(stream), with: convertible, interceptor: interceptor, fileManager: fileManager)
  766|      0|    }
  767|       |
  768|       |    // MARK: MultipartFormData
  769|       |
  770|       |    /// Creates an `UploadRequest` for the multipart form data built using a closure and sent using the provided
  771|       |    /// `URLRequest` components and `RequestInterceptor`.
  772|       |    ///
  773|       |    /// It is important to understand the memory implications of uploading `MultipartFormData`. If the cumulative
  774|       |    /// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  775|       |    /// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  776|       |    /// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  777|       |    /// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  778|       |    /// used for larger payloads such as video content.
  779|       |    ///
  780|       |    /// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  781|       |    /// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  782|       |    /// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  783|       |    /// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  784|       |    /// technique was used.
  785|       |    ///
  786|       |    /// - Parameters:
  787|       |    ///   - multipartFormData:       `MultipartFormData` building closure.
  788|       |    ///   - convertible:             `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  789|       |    ///   - encodingMemoryThreshold: Byte threshold used to determine whether the form data is encoded into memory or
  790|       |    ///                              onto disk before being uploaded. `MultipartFormData.encodingMemoryThreshold` by
  791|       |    ///                              default.
  792|       |    ///   - method:                  `HTTPMethod` for the `URLRequest`. `.post` by default.
  793|       |    ///   - headers:                 `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  794|       |    ///   - interceptor:             `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  795|       |    ///   - fileManager:             `FileManager` to be used if the form data exceeds the memory threshold and is
  796|       |    ///                              written to disk before being uploaded. `.default` instance by default.
  797|       |    ///   - requestModifier:         `RequestModifier` which will be applied to the `URLRequest` created from the
  798|       |    ///                              provided parameters. `nil` by default.
  799|       |    ///
  800|       |    /// - Returns:                   The created `UploadRequest`.
  801|       |    open func upload(multipartFormData: @escaping (MultipartFormData) -> Void,
  802|       |                     to url: URLConvertible,
  803|       |                     usingThreshold encodingMemoryThreshold: UInt64 = MultipartFormData.encodingMemoryThreshold,
  804|       |                     method: HTTPMethod = .post,
  805|       |                     headers: HTTPHeaders? = nil,
  806|       |                     interceptor: RequestInterceptor? = nil,
  807|       |                     fileManager: FileManager = .default,
  808|      0|                     requestModifier: RequestModifier? = nil) -> UploadRequest {
  809|      0|        let convertible = ParameterlessRequestConvertible(url: url,
  810|      0|                                                          method: method,
  811|      0|                                                          headers: headers,
  812|      0|                                                          requestModifier: requestModifier)
  813|      0|
  814|      0|        let formData = MultipartFormData(fileManager: fileManager)
  815|      0|        multipartFormData(formData)
  816|      0|
  817|      0|        return upload(multipartFormData: formData,
  818|      0|                      with: convertible,
  819|      0|                      usingThreshold: encodingMemoryThreshold,
  820|      0|                      interceptor: interceptor,
  821|      0|                      fileManager: fileManager)
  822|      0|    }
  823|       |
  824|       |    /// Creates an `UploadRequest` using a `MultipartFormData` building closure, the provided `URLRequestConvertible`
  825|       |    /// value, and a `RequestInterceptor`.
  826|       |    ///
  827|       |    /// It is important to understand the memory implications of uploading `MultipartFormData`. If the cumulative
  828|       |    /// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  829|       |    /// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  830|       |    /// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  831|       |    /// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  832|       |    /// used for larger payloads such as video content.
  833|       |    ///
  834|       |    /// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  835|       |    /// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  836|       |    /// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  837|       |    /// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  838|       |    /// technique was used.
  839|       |    ///
  840|       |    /// - Parameters:
  841|       |    ///   - multipartFormData:       `MultipartFormData` building closure.
  842|       |    ///   - request:                 `URLRequestConvertible` value to be used to create the `URLRequest`.
  843|       |    ///   - encodingMemoryThreshold: Byte threshold used to determine whether the form data is encoded into memory or
  844|       |    ///                              onto disk before being uploaded. `MultipartFormData.encodingMemoryThreshold` by
  845|       |    ///                              default.
  846|       |    ///   - interceptor:             `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  847|       |    ///   - fileManager:             `FileManager` to be used if the form data exceeds the memory threshold and is
  848|       |    ///                              written to disk before being uploaded. `.default` instance by default.
  849|       |    ///
  850|       |    /// - Returns:                   The created `UploadRequest`.
  851|       |    open func upload(multipartFormData: @escaping (MultipartFormData) -> Void,
  852|       |                     with request: URLRequestConvertible,
  853|       |                     usingThreshold encodingMemoryThreshold: UInt64 = MultipartFormData.encodingMemoryThreshold,
  854|       |                     interceptor: RequestInterceptor? = nil,
  855|      0|                     fileManager: FileManager = .default) -> UploadRequest {
  856|      0|        let formData = MultipartFormData(fileManager: fileManager)
  857|      0|        multipartFormData(formData)
  858|      0|
  859|      0|        return upload(multipartFormData: formData,
  860|      0|                      with: request,
  861|      0|                      usingThreshold: encodingMemoryThreshold,
  862|      0|                      interceptor: interceptor,
  863|      0|                      fileManager: fileManager)
  864|      0|    }
  865|       |
  866|       |    /// Creates an `UploadRequest` for the prebuilt `MultipartFormData` value using the provided `URLRequest` components
  867|       |    /// and `RequestInterceptor`.
  868|       |    ///
  869|       |    /// It is important to understand the memory implications of uploading `MultipartFormData`. If the cumulative
  870|       |    /// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  871|       |    /// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  872|       |    /// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  873|       |    /// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  874|       |    /// used for larger payloads such as video content.
  875|       |    ///
  876|       |    /// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  877|       |    /// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  878|       |    /// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  879|       |    /// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  880|       |    /// technique was used.
  881|       |    ///
  882|       |    /// - Parameters:
  883|       |    ///   - multipartFormData:       `MultipartFormData` instance to upload.
  884|       |    ///   - url:                     `URLConvertible` value to be used as the `URLRequest`'s `URL`.
  885|       |    ///   - encodingMemoryThreshold: Byte threshold used to determine whether the form data is encoded into memory or
  886|       |    ///                              onto disk before being uploaded. `MultipartFormData.encodingMemoryThreshold` by
  887|       |    ///                              default.
  888|       |    ///   - method:                  `HTTPMethod` for the `URLRequest`. `.post` by default.
  889|       |    ///   - headers:                 `HTTPHeaders` value to be added to the `URLRequest`. `nil` by default.
  890|       |    ///   - interceptor:             `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  891|       |    ///   - fileManager:             `FileManager` to be used if the form data exceeds the memory threshold and is
  892|       |    ///                              written to disk before being uploaded. `.default` instance by default.
  893|       |    ///   - requestModifier:         `RequestModifier` which will be applied to the `URLRequest` created from the
  894|       |    ///                              provided parameters. `nil` by default.
  895|       |    ///
  896|       |    /// - Returns:                   The created `UploadRequest`.
  897|       |    open func upload(multipartFormData: MultipartFormData,
  898|       |                     to url: URLConvertible,
  899|       |                     usingThreshold encodingMemoryThreshold: UInt64 = MultipartFormData.encodingMemoryThreshold,
  900|       |                     method: HTTPMethod = .post,
  901|       |                     headers: HTTPHeaders? = nil,
  902|       |                     interceptor: RequestInterceptor? = nil,
  903|       |                     fileManager: FileManager = .default,
  904|      0|                     requestModifier: RequestModifier? = nil) -> UploadRequest {
  905|      0|        let convertible = ParameterlessRequestConvertible(url: url,
  906|      0|                                                          method: method,
  907|      0|                                                          headers: headers,
  908|      0|                                                          requestModifier: requestModifier)
  909|      0|
  910|      0|        let multipartUpload = MultipartUpload(isInBackgroundSession: session.configuration.identifier != nil,
  911|      0|                                              encodingMemoryThreshold: encodingMemoryThreshold,
  912|      0|                                              request: convertible,
  913|      0|                                              multipartFormData: multipartFormData)
  914|      0|
  915|      0|        return upload(multipartUpload, interceptor: interceptor, fileManager: fileManager)
  916|      0|    }
  917|       |
  918|       |    /// Creates an `UploadRequest` for the prebuilt `MultipartFormData` value using the providing `URLRequestConvertible`
  919|       |    /// value and `RequestInterceptor`.
  920|       |    ///
  921|       |    /// It is important to understand the memory implications of uploading `MultipartFormData`. If the cumulative
  922|       |    /// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  923|       |    /// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  924|       |    /// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  925|       |    /// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  926|       |    /// used for larger payloads such as video content.
  927|       |    ///
  928|       |    /// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  929|       |    /// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  930|       |    /// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  931|       |    /// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  932|       |    /// technique was used.
  933|       |    ///
  934|       |    /// - Parameters:
  935|       |    ///   - multipartFormData:       `MultipartFormData` instance to upload.
  936|       |    ///   - request:                 `URLRequestConvertible` value to be used to create the `URLRequest`.
  937|       |    ///   - encodingMemoryThreshold: Byte threshold used to determine whether the form data is encoded into memory or
  938|       |    ///                              onto disk before being uploaded. `MultipartFormData.encodingMemoryThreshold` by
  939|       |    ///                              default.
  940|       |    ///   - interceptor:             `RequestInterceptor` value to be used by the returned `DataRequest`. `nil` by default.
  941|       |    ///   - fileManager:             `FileManager` instance to be used by the returned `UploadRequest`. `.default` instance by
  942|       |    ///                              default.
  943|       |    ///
  944|       |    /// - Returns:                   The created `UploadRequest`.
  945|       |    open func upload(multipartFormData: MultipartFormData,
  946|       |                     with request: URLRequestConvertible,
  947|       |                     usingThreshold encodingMemoryThreshold: UInt64 = MultipartFormData.encodingMemoryThreshold,
  948|       |                     interceptor: RequestInterceptor? = nil,
  949|      0|                     fileManager: FileManager = .default) -> UploadRequest {
  950|      0|        let multipartUpload = MultipartUpload(isInBackgroundSession: session.configuration.identifier != nil,
  951|      0|                                              encodingMemoryThreshold: encodingMemoryThreshold,
  952|      0|                                              request: request,
  953|      0|                                              multipartFormData: multipartFormData)
  954|      0|
  955|      0|        return upload(multipartUpload, interceptor: interceptor, fileManager: fileManager)
  956|      0|    }
  957|       |
  958|       |    // MARK: - Internal API
  959|       |
  960|       |    // MARK: Uploadable
  961|       |
  962|       |    func upload(_ uploadable: UploadRequest.Uploadable,
  963|       |                with convertible: URLRequestConvertible,
  964|       |                interceptor: RequestInterceptor?,
  965|      0|                fileManager: FileManager) -> UploadRequest {
  966|      0|        let uploadable = Upload(request: convertible, uploadable: uploadable)
  967|      0|
  968|      0|        return upload(uploadable, interceptor: interceptor, fileManager: fileManager)
  969|      0|    }
  970|       |
  971|      0|    func upload(_ upload: UploadConvertible, interceptor: RequestInterceptor?, fileManager: FileManager) -> UploadRequest {
  972|      0|        let request = UploadRequest(convertible: upload,
  973|      0|                                    underlyingQueue: rootQueue,
  974|      0|                                    serializationQueue: serializationQueue,
  975|      0|                                    eventMonitor: eventMonitor,
  976|      0|                                    interceptor: interceptor,
  977|      0|                                    fileManager: fileManager,
  978|      0|                                    delegate: self)
  979|      0|
  980|      0|        perform(request)
  981|      0|
  982|      0|        return request
  983|      0|    }
  984|       |
  985|       |    // MARK: Perform
  986|       |
  987|       |    /// Starts performing the provided `Request`.
  988|       |    ///
  989|       |    /// - Parameter request: The `Request` to perform.
  990|      0|    func perform(_ request: Request) {
  991|      0|        rootQueue.async {
  992|      0|            guard !request.isCancelled else { return }
  993|      0|
  994|      0|            self.activeRequests.insert(request)
  995|      0|
  996|      0|            self.requestQueue.async {
  997|      0|                // Leaf types must come first, otherwise they will cast as their superclass.
  998|      0|                switch request {
  999|      0|                case let r as UploadRequest: self.performUploadRequest(r) // UploadRequest must come before DataRequest due to subtype relationship.
 1000|      0|                case let r as DataRequest: self.performDataRequest(r)
 1001|      0|                case let r as DownloadRequest: self.performDownloadRequest(r)
 1002|      0|                case let r as DataStreamRequest: self.performDataStreamRequest(r)
 1003|      0|                default: fatalError("Attempted to perform unsupported Request subclass: \(type(of: request))")
 1004|      0|                }
 1005|      0|            }
 1006|      0|        }
 1007|      0|    }
 1008|       |
 1009|      0|    func performDataRequest(_ request: DataRequest) {
 1010|      0|        dispatchPrecondition(condition: .onQueue(requestQueue))
 1011|      0|
 1012|      0|        performSetupOperations(for: request, convertible: request.convertible)
 1013|      0|    }
 1014|       |
 1015|      0|    func performDataStreamRequest(_ request: DataStreamRequest) {
 1016|      0|        dispatchPrecondition(condition: .onQueue(requestQueue))
 1017|      0|
 1018|      0|        performSetupOperations(for: request, convertible: request.convertible)
 1019|      0|    }
 1020|       |
 1021|      0|    func performUploadRequest(_ request: UploadRequest) {
 1022|      0|        dispatchPrecondition(condition: .onQueue(requestQueue))
 1023|      0|
 1024|      0|        do {
 1025|      0|            let uploadable = try request.upload.createUploadable()
 1026|      0|            rootQueue.async { request.didCreateUploadable(uploadable) }
 1027|      0|
 1028|      0|            performSetupOperations(for: request, convertible: request.convertible)
 1029|      0|        } catch {
 1030|      0|            rootQueue.async { request.didFailToCreateUploadable(with: error.asAFError(or: .createUploadableFailed(error: error))) }
 1031|      0|        }
 1032|      0|    }
 1033|       |
 1034|      0|    func performDownloadRequest(_ request: DownloadRequest) {
 1035|      0|        dispatchPrecondition(condition: .onQueue(requestQueue))
 1036|      0|
 1037|      0|        switch request.downloadable {
 1038|      0|        case let .request(convertible):
 1039|      0|            performSetupOperations(for: request, convertible: convertible)
 1040|      0|        case let .resumeData(resumeData):
 1041|      0|            rootQueue.async { self.didReceiveResumeData(resumeData, for: request) }
 1042|      0|        }
 1043|      0|    }
 1044|       |
 1045|      0|    func performSetupOperations(for request: Request, convertible: URLRequestConvertible) {
 1046|      0|        dispatchPrecondition(condition: .onQueue(requestQueue))
 1047|      0|
 1048|      0|        let initialRequest: URLRequest
 1049|      0|
 1050|      0|        do {
 1051|      0|            initialRequest = try convertible.asURLRequest()
 1052|      0|            try initialRequest.validate()
 1053|      0|        } catch {
 1054|      0|            rootQueue.async { request.didFailToCreateURLRequest(with: error.asAFError(or: .createURLRequestFailed(error: error))) }
 1055|      0|            return
 1056|      0|        }
 1057|      0|
 1058|      0|        rootQueue.async { request.didCreateInitialURLRequest(initialRequest) }
 1059|      0|
 1060|      0|        guard !request.isCancelled else { return }
 1061|      0|
 1062|      0|        guard let adapter = adapter(for: request) else {
 1063|      0|            rootQueue.async { self.didCreateURLRequest(initialRequest, for: request) }
 1064|      0|            return
 1065|      0|        }
 1066|      0|
 1067|      0|        adapter.adapt(initialRequest, for: self) { result in
 1068|      0|            do {
 1069|      0|                let adaptedRequest = try result.get()
 1070|      0|                try adaptedRequest.validate()
 1071|      0|
 1072|      0|                self.rootQueue.async {
 1073|      0|                    request.didAdaptInitialRequest(initialRequest, to: adaptedRequest)
 1074|      0|                    self.didCreateURLRequest(adaptedRequest, for: request)
 1075|      0|                }
 1076|      0|            } catch {
 1077|      0|                self.rootQueue.async { request.didFailToAdaptURLRequest(initialRequest, withError: .requestAdaptationFailed(error: error)) }
 1078|      0|            }
 1079|      0|        }
 1080|      0|    }
 1081|       |
 1082|       |    // MARK: - Task Handling
 1083|       |
 1084|      0|    func didCreateURLRequest(_ urlRequest: URLRequest, for request: Request) {
 1085|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1086|      0|
 1087|      0|        request.didCreateURLRequest(urlRequest)
 1088|      0|
 1089|      0|        guard !request.isCancelled else { return }
 1090|      0|
 1091|      0|        let task = request.task(for: urlRequest, using: session)
 1092|      0|        requestTaskMap[request] = task
 1093|      0|        request.didCreateTask(task)
 1094|      0|
 1095|      0|        updateStatesForTask(task, request: request)
 1096|      0|    }
 1097|       |
 1098|      0|    func didReceiveResumeData(_ data: Data, for request: DownloadRequest) {
 1099|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1100|      0|
 1101|      0|        guard !request.isCancelled else { return }
 1102|      0|
 1103|      0|        let task = request.task(forResumeData: data, using: session)
 1104|      0|        requestTaskMap[request] = task
 1105|      0|        request.didCreateTask(task)
 1106|      0|
 1107|      0|        updateStatesForTask(task, request: request)
 1108|      0|    }
 1109|       |
 1110|      0|    func updateStatesForTask(_ task: URLSessionTask, request: Request) {
 1111|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1112|      0|
 1113|      0|        request.withState { state in
 1114|      0|            switch state {
 1115|      0|            case .initialized, .finished:
 1116|      0|                // Do nothing.
 1117|      0|                break
 1118|      0|            case .resumed:
 1119|      0|                task.resume()
 1120|      0|                rootQueue.async { request.didResumeTask(task) }
 1121|      0|            case .suspended:
 1122|      0|                task.suspend()
 1123|      0|                rootQueue.async { request.didSuspendTask(task) }
 1124|      0|            case .cancelled:
 1125|      0|                // Resume to ensure metrics are gathered.
 1126|      0|                task.resume()
 1127|      0|                task.cancel()
 1128|      0|                rootQueue.async { request.didCancelTask(task) }
 1129|      0|            }
 1130|      0|        }
 1131|      0|    }
 1132|       |
 1133|       |    // MARK: - Adapters and Retriers
 1134|       |
 1135|      0|    func adapter(for request: Request) -> RequestAdapter? {
 1136|      0|        if let requestInterceptor = request.interceptor, let sessionInterceptor = interceptor {
 1137|      0|            return Interceptor(adapters: [requestInterceptor, sessionInterceptor])
 1138|      0|        } else {
 1139|      0|            return request.interceptor ?? interceptor
 1140|      0|        }
 1141|      0|    }
 1142|       |
 1143|      0|    func retrier(for request: Request) -> RequestRetrier? {
 1144|      0|        if let requestInterceptor = request.interceptor, let sessionInterceptor = interceptor {
 1145|      0|            return Interceptor(retriers: [requestInterceptor, sessionInterceptor])
 1146|      0|        } else {
 1147|      0|            return request.interceptor ?? interceptor
 1148|      0|        }
 1149|      0|    }
 1150|       |
 1151|       |    // MARK: - Invalidation
 1152|       |
 1153|      0|    func finishRequestsForDeinit() {
 1154|      0|        requestTaskMap.requests.forEach { request in
 1155|      0|            rootQueue.async {
 1156|      0|                request.finish(error: AFError.sessionDeinitialized)
 1157|      0|            }
 1158|      0|        }
 1159|      0|    }
 1160|       |}
 1161|       |
 1162|       |// MARK: - RequestDelegate
 1163|       |
 1164|       |extension Session: RequestDelegate {
 1165|      0|    public var sessionConfiguration: URLSessionConfiguration {
 1166|      0|        session.configuration
 1167|      0|    }
 1168|       |
 1169|      0|    public var startImmediately: Bool { startRequestsImmediately }
 1170|       |
 1171|      0|    public func cleanup(after request: Request) {
 1172|      0|        activeRequests.remove(request)
 1173|      0|    }
 1174|       |
 1175|      0|    public func retryResult(for request: Request, dueTo error: AFError, completion: @escaping (RetryResult) -> Void) {
 1176|      0|        guard let retrier = retrier(for: request) else {
 1177|      0|            rootQueue.async { completion(.doNotRetry) }
 1178|      0|            return
 1179|      0|        }
 1180|      0|
 1181|      0|        retrier.retry(request, for: self, dueTo: error) { retryResult in
 1182|      0|            self.rootQueue.async {
 1183|      0|                guard let retryResultError = retryResult.error else { completion(retryResult); return }
 1184|      0|
 1185|      0|                let retryError = AFError.requestRetryFailed(retryError: retryResultError, originalError: error)
 1186|      0|                completion(.doNotRetryWithError(retryError))
 1187|      0|            }
 1188|      0|        }
 1189|      0|    }
 1190|       |
 1191|      0|    public func retryRequest(_ request: Request, withDelay timeDelay: TimeInterval?) {
 1192|      0|        rootQueue.async {
 1193|      0|            let retry: () -> Void = {
 1194|      0|                guard !request.isCancelled else { return }
 1195|      0|
 1196|      0|                request.prepareForRetry()
 1197|      0|                self.perform(request)
 1198|      0|            }
 1199|      0|
 1200|      0|            if let retryDelay = timeDelay {
 1201|      0|                self.rootQueue.after(retryDelay) { retry() }
 1202|      0|            } else {
 1203|      0|                retry()
 1204|      0|            }
 1205|      0|        }
 1206|      0|    }
 1207|       |}
 1208|       |
 1209|       |// MARK: - SessionStateProvider
 1210|       |
 1211|       |extension Session: SessionStateProvider {
 1212|      0|    func request(for task: URLSessionTask) -> Request? {
 1213|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1214|      0|
 1215|      0|        return requestTaskMap[task]
 1216|      0|    }
 1217|       |
 1218|      0|    func didGatherMetricsForTask(_ task: URLSessionTask) {
 1219|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1220|      0|
 1221|      0|        let didDisassociate = requestTaskMap.disassociateIfNecessaryAfterGatheringMetricsForTask(task)
 1222|      0|
 1223|      0|        if didDisassociate {
 1224|      0|            waitingCompletions[task]?()
 1225|      0|            waitingCompletions[task] = nil
 1226|      0|        }
 1227|      0|    }
 1228|       |
 1229|      0|    func didCompleteTask(_ task: URLSessionTask, completion: @escaping () -> Void) {
 1230|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1231|      0|
 1232|      0|        let didDisassociate = requestTaskMap.disassociateIfNecessaryAfterCompletingTask(task)
 1233|      0|
 1234|      0|        if didDisassociate {
 1235|      0|            completion()
 1236|      0|        } else {
 1237|      0|            waitingCompletions[task] = completion
 1238|      0|        }
 1239|      0|    }
 1240|       |
 1241|      0|    func credential(for task: URLSessionTask, in protectionSpace: URLProtectionSpace) -> URLCredential? {
 1242|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1243|      0|
 1244|      0|        return requestTaskMap[task]?.credential ??
 1245|      0|            session.configuration.urlCredentialStorage?.defaultCredential(for: protectionSpace)
 1246|      0|    }
 1247|       |
 1248|      0|    func cancelRequestsForSessionInvalidation(with error: Error?) {
 1249|      0|        dispatchPrecondition(condition: .onQueue(rootQueue))
 1250|      0|
 1251|      0|        requestTaskMap.requests.forEach { $0.finish(error: AFError.sessionInvalidated(error: error)) }
 1252|      0|    }
 1253|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/SessionDelegate.swift:
    1|       |//
    2|       |//  SessionDelegate.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Class which implements the various `URLSessionDelegate` methods to connect various Alamofire features.
   28|       |open class SessionDelegate: NSObject {
   29|       |    private let fileManager: FileManager
   30|       |
   31|       |    weak var stateProvider: SessionStateProvider?
   32|       |    var eventMonitor: EventMonitor?
   33|       |
   34|       |    /// Creates an instance from the given `FileManager`.
   35|       |    ///
   36|       |    /// - Parameter fileManager: `FileManager` to use for underlying file management, such as moving downloaded files.
   37|       |    ///                          `.default` by default.
   38|      0|    public init(fileManager: FileManager = .default) {
   39|      0|        self.fileManager = fileManager
   40|      0|    }
   41|       |
   42|       |    /// Internal method to find and cast requests while maintaining some integrity checking.
   43|       |    ///
   44|       |    /// - Parameters:
   45|       |    ///   - task: The `URLSessionTask` for which to find the associated `Request`.
   46|       |    ///   - type: The `Request` subclass type to cast any `Request` associate with `task`.
   47|      0|    func request<R: Request>(for task: URLSessionTask, as type: R.Type) -> R? {
   48|      0|        guard let provider = stateProvider else {
   49|      0|            assertionFailure("StateProvider is nil.")
   50|      0|            return nil
   51|      0|        }
   52|      0|
   53|      0|        return provider.request(for: task) as? R
   54|      0|    }
   55|       |}
   56|       |
   57|       |/// Type which provides various `Session` state values.
   58|       |protocol SessionStateProvider: AnyObject {
   59|       |    var serverTrustManager: ServerTrustManager? { get }
   60|       |    var redirectHandler: RedirectHandler? { get }
   61|       |    var cachedResponseHandler: CachedResponseHandler? { get }
   62|       |
   63|       |    func request(for task: URLSessionTask) -> Request?
   64|       |    func didGatherMetricsForTask(_ task: URLSessionTask)
   65|       |    func didCompleteTask(_ task: URLSessionTask, completion: @escaping () -> Void)
   66|       |    func credential(for task: URLSessionTask, in protectionSpace: URLProtectionSpace) -> URLCredential?
   67|       |    func cancelRequestsForSessionInvalidation(with error: Error?)
   68|       |}
   69|       |
   70|       |// MARK: URLSessionDelegate
   71|       |
   72|       |extension SessionDelegate: URLSessionDelegate {
   73|      0|    open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {
   74|      0|        eventMonitor?.urlSession(session, didBecomeInvalidWithError: error)
   75|      0|
   76|      0|        stateProvider?.cancelRequestsForSessionInvalidation(with: error)
   77|      0|    }
   78|       |}
   79|       |
   80|       |// MARK: URLSessionTaskDelegate
   81|       |
   82|       |extension SessionDelegate: URLSessionTaskDelegate {
   83|       |    /// Result of a `URLAuthenticationChallenge` evaluation.
   84|       |    typealias ChallengeEvaluation = (disposition: URLSession.AuthChallengeDisposition, credential: URLCredential?, error: AFError?)
   85|       |
   86|       |    open func urlSession(_ session: URLSession,
   87|       |                         task: URLSessionTask,
   88|       |                         didReceive challenge: URLAuthenticationChallenge,
   89|      0|                         completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
   90|      0|        eventMonitor?.urlSession(session, task: task, didReceive: challenge)
   91|      0|
   92|      0|        let evaluation: ChallengeEvaluation
   93|      0|        switch challenge.protectionSpace.authenticationMethod {
   94|      0|        case NSURLAuthenticationMethodServerTrust:
   95|      0|            evaluation = attemptServerTrustAuthentication(with: challenge)
   96|      0|        case NSURLAuthenticationMethodHTTPBasic, NSURLAuthenticationMethodHTTPDigest, NSURLAuthenticationMethodNTLM,
   97|      0|             NSURLAuthenticationMethodNegotiate, NSURLAuthenticationMethodClientCertificate:
   98|      0|            evaluation = attemptCredentialAuthentication(for: challenge, belongingTo: task)
   99|      0|        default:
  100|      0|            evaluation = (.performDefaultHandling, nil, nil)
  101|      0|        }
  102|      0|
  103|      0|        if let error = evaluation.error {
  104|      0|            stateProvider?.request(for: task)?.didFailTask(task, earlyWithError: error)
  105|      0|        }
  106|      0|
  107|      0|        completionHandler(evaluation.disposition, evaluation.credential)
  108|      0|    }
  109|       |
  110|       |    /// Evaluates the server trust `URLAuthenticationChallenge` received.
  111|       |    ///
  112|       |    /// - Parameter challenge: The `URLAuthenticationChallenge`.
  113|       |    ///
  114|       |    /// - Returns:             The `ChallengeEvaluation`.
  115|      0|    func attemptServerTrustAuthentication(with challenge: URLAuthenticationChallenge) -> ChallengeEvaluation {
  116|      0|        let host = challenge.protectionSpace.host
  117|      0|
  118|      0|        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,
  119|      0|              let trust = challenge.protectionSpace.serverTrust
  120|      0|        else {
  121|      0|            return (.performDefaultHandling, nil, nil)
  122|      0|        }
  123|      0|
  124|      0|        do {
  125|      0|            guard let evaluator = try stateProvider?.serverTrustManager?.serverTrustEvaluator(forHost: host) else {
  126|      0|                return (.performDefaultHandling, nil, nil)
  127|      0|            }
  128|      0|
  129|      0|            try evaluator.evaluate(trust, forHost: host)
  130|      0|
  131|      0|            return (.useCredential, URLCredential(trust: trust), nil)
  132|      0|        } catch {
  133|      0|            return (.cancelAuthenticationChallenge, nil, error.asAFError(or: .serverTrustEvaluationFailed(reason: .customEvaluationFailed(error: error))))
  134|      0|        }
  135|      0|    }
  136|       |
  137|       |    /// Evaluates the credential-based authentication `URLAuthenticationChallenge` received for `task`.
  138|       |    ///
  139|       |    /// - Parameters:
  140|       |    ///   - challenge: The `URLAuthenticationChallenge`.
  141|       |    ///   - task:      The `URLSessionTask` which received the challenge.
  142|       |    ///
  143|       |    /// - Returns:     The `ChallengeEvaluation`.
  144|       |    func attemptCredentialAuthentication(for challenge: URLAuthenticationChallenge,
  145|      0|                                         belongingTo task: URLSessionTask) -> ChallengeEvaluation {
  146|      0|        guard challenge.previousFailureCount == 0 else {
  147|      0|            return (.rejectProtectionSpace, nil, nil)
  148|      0|        }
  149|      0|
  150|      0|        guard let credential = stateProvider?.credential(for: task, in: challenge.protectionSpace) else {
  151|      0|            return (.performDefaultHandling, nil, nil)
  152|      0|        }
  153|      0|
  154|      0|        return (.useCredential, credential, nil)
  155|      0|    }
  156|       |
  157|       |    open func urlSession(_ session: URLSession,
  158|       |                         task: URLSessionTask,
  159|       |                         didSendBodyData bytesSent: Int64,
  160|       |                         totalBytesSent: Int64,
  161|      0|                         totalBytesExpectedToSend: Int64) {
  162|      0|        eventMonitor?.urlSession(session,
  163|      0|                                 task: task,
  164|      0|                                 didSendBodyData: bytesSent,
  165|      0|                                 totalBytesSent: totalBytesSent,
  166|      0|                                 totalBytesExpectedToSend: totalBytesExpectedToSend)
  167|      0|
  168|      0|        stateProvider?.request(for: task)?.updateUploadProgress(totalBytesSent: totalBytesSent,
  169|      0|                                                                totalBytesExpectedToSend: totalBytesExpectedToSend)
  170|      0|    }
  171|       |
  172|       |    open func urlSession(_ session: URLSession,
  173|       |                         task: URLSessionTask,
  174|      0|                         needNewBodyStream completionHandler: @escaping (InputStream?) -> Void) {
  175|      0|        eventMonitor?.urlSession(session, taskNeedsNewBodyStream: task)
  176|      0|
  177|      0|        guard let request = request(for: task, as: UploadRequest.self) else {
  178|      0|            assertionFailure("needNewBodyStream did not find UploadRequest.")
  179|      0|            completionHandler(nil)
  180|      0|            return
  181|      0|        }
  182|      0|
  183|      0|        completionHandler(request.inputStream())
  184|      0|    }
  185|       |
  186|       |    open func urlSession(_ session: URLSession,
  187|       |                         task: URLSessionTask,
  188|       |                         willPerformHTTPRedirection response: HTTPURLResponse,
  189|       |                         newRequest request: URLRequest,
  190|      0|                         completionHandler: @escaping (URLRequest?) -> Void) {
  191|      0|        eventMonitor?.urlSession(session, task: task, willPerformHTTPRedirection: response, newRequest: request)
  192|      0|
  193|      0|        if let redirectHandler = stateProvider?.request(for: task)?.redirectHandler ?? stateProvider?.redirectHandler {
  194|      0|            redirectHandler.task(task, willBeRedirectedTo: request, for: response, completion: completionHandler)
  195|      0|        } else {
  196|      0|            completionHandler(request)
  197|      0|        }
  198|      0|    }
  199|       |
  200|      0|    open func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {
  201|      0|        eventMonitor?.urlSession(session, task: task, didFinishCollecting: metrics)
  202|      0|
  203|      0|        stateProvider?.request(for: task)?.didGatherMetrics(metrics)
  204|      0|
  205|      0|        stateProvider?.didGatherMetricsForTask(task)
  206|      0|    }
  207|       |
  208|      0|    open func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  209|      0|        eventMonitor?.urlSession(session, task: task, didCompleteWithError: error)
  210|      0|
  211|      0|        let request = stateProvider?.request(for: task)
  212|      0|
  213|      0|        stateProvider?.didCompleteTask(task) {
  214|      0|            request?.didCompleteTask(task, with: error.map { $0.asAFError(or: .sessionTaskFailed(error: $0)) })
  215|      0|        }
  216|      0|    }
  217|       |
  218|       |    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  219|      0|    open func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {
  220|      0|        eventMonitor?.urlSession(session, taskIsWaitingForConnectivity: task)
  221|      0|    }
  222|       |}
  223|       |
  224|       |// MARK: URLSessionDataDelegate
  225|       |
  226|       |extension SessionDelegate: URLSessionDataDelegate {
  227|      0|    open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  228|      0|        eventMonitor?.urlSession(session, dataTask: dataTask, didReceive: data)
  229|      0|
  230|      0|        if let request = request(for: dataTask, as: DataRequest.self) {
  231|      0|            request.didReceive(data: data)
  232|      0|        } else if let request = request(for: dataTask, as: DataStreamRequest.self) {
  233|      0|            request.didReceive(data: data)
  234|      0|        } else {
  235|      0|            assertionFailure("dataTask did not find DataRequest or DataStreamRequest in didReceive")
  236|      0|            return
  237|      0|        }
  238|      0|    }
  239|       |
  240|       |    open func urlSession(_ session: URLSession,
  241|       |                         dataTask: URLSessionDataTask,
  242|       |                         willCacheResponse proposedResponse: CachedURLResponse,
  243|      0|                         completionHandler: @escaping (CachedURLResponse?) -> Void) {
  244|      0|        eventMonitor?.urlSession(session, dataTask: dataTask, willCacheResponse: proposedResponse)
  245|      0|
  246|      0|        if let handler = stateProvider?.request(for: dataTask)?.cachedResponseHandler ?? stateProvider?.cachedResponseHandler {
  247|      0|            handler.dataTask(dataTask, willCacheResponse: proposedResponse, completion: completionHandler)
  248|      0|        } else {
  249|      0|            completionHandler(proposedResponse)
  250|      0|        }
  251|      0|    }
  252|       |}
  253|       |
  254|       |// MARK: URLSessionDownloadDelegate
  255|       |
  256|       |extension SessionDelegate: URLSessionDownloadDelegate {
  257|       |    open func urlSession(_ session: URLSession,
  258|       |                         downloadTask: URLSessionDownloadTask,
  259|       |                         didResumeAtOffset fileOffset: Int64,
  260|      0|                         expectedTotalBytes: Int64) {
  261|      0|        eventMonitor?.urlSession(session,
  262|      0|                                 downloadTask: downloadTask,
  263|      0|                                 didResumeAtOffset: fileOffset,
  264|      0|                                 expectedTotalBytes: expectedTotalBytes)
  265|      0|        guard let downloadRequest = request(for: downloadTask, as: DownloadRequest.self) else {
  266|      0|            assertionFailure("downloadTask did not find DownloadRequest.")
  267|      0|            return
  268|      0|        }
  269|      0|
  270|      0|        downloadRequest.updateDownloadProgress(bytesWritten: fileOffset,
  271|      0|                                               totalBytesExpectedToWrite: expectedTotalBytes)
  272|      0|    }
  273|       |
  274|       |    open func urlSession(_ session: URLSession,
  275|       |                         downloadTask: URLSessionDownloadTask,
  276|       |                         didWriteData bytesWritten: Int64,
  277|       |                         totalBytesWritten: Int64,
  278|      0|                         totalBytesExpectedToWrite: Int64) {
  279|      0|        eventMonitor?.urlSession(session,
  280|      0|                                 downloadTask: downloadTask,
  281|      0|                                 didWriteData: bytesWritten,
  282|      0|                                 totalBytesWritten: totalBytesWritten,
  283|      0|                                 totalBytesExpectedToWrite: totalBytesExpectedToWrite)
  284|      0|        guard let downloadRequest = request(for: downloadTask, as: DownloadRequest.self) else {
  285|      0|            assertionFailure("downloadTask did not find DownloadRequest.")
  286|      0|            return
  287|      0|        }
  288|      0|
  289|      0|        downloadRequest.updateDownloadProgress(bytesWritten: bytesWritten,
  290|      0|                                               totalBytesExpectedToWrite: totalBytesExpectedToWrite)
  291|      0|    }
  292|       |
  293|      0|    open func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
  294|      0|        eventMonitor?.urlSession(session, downloadTask: downloadTask, didFinishDownloadingTo: location)
  295|      0|
  296|      0|        guard let request = request(for: downloadTask, as: DownloadRequest.self) else {
  297|      0|            assertionFailure("downloadTask did not find DownloadRequest.")
  298|      0|            return
  299|      0|        }
  300|      0|
  301|      0|        let (destination, options): (URL, DownloadRequest.Options)
  302|      0|        if let response = request.response {
  303|      0|            (destination, options) = request.destination(location, response)
  304|      0|        } else {
  305|      0|            // If there's no response this is likely a local file download, so generate the temporary URL directly.
  306|      0|            (destination, options) = (DownloadRequest.defaultDestinationURL(location), [])
  307|      0|        }
  308|      0|
  309|      0|        eventMonitor?.request(request, didCreateDestinationURL: destination)
  310|      0|
  311|      0|        do {
  312|      0|            if options.contains(.removePreviousFile), fileManager.fileExists(atPath: destination.path) {
  313|      0|                try fileManager.removeItem(at: destination)
  314|      0|            }
  315|      0|
  316|      0|            if options.contains(.createIntermediateDirectories) {
  317|      0|                let directory = destination.deletingLastPathComponent()
  318|      0|                try fileManager.createDirectory(at: directory, withIntermediateDirectories: true)
  319|      0|            }
  320|      0|
  321|      0|            try fileManager.moveItem(at: location, to: destination)
  322|      0|
  323|      0|            request.didFinishDownloading(using: downloadTask, with: .success(destination))
  324|      0|        } catch {
  325|      0|            request.didFinishDownloading(using: downloadTask, with: .failure(.downloadedFileMoveFailed(error: error,
  326|      0|                                                                                                       source: location,
  327|      0|                                                                                                       destination: destination)))
  328|      0|        }
  329|      0|    }
  330|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/StringEncoding+Alamofire.swift:
    1|       |//
    2|       |//  StringEncoding+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2020 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension String.Encoding {
   28|       |    /// Creates an encoding from the IANA charset name.
   29|       |    ///
   30|       |    /// - Notes: These mappings match those [provided by CoreFoundation](https://opensource.apple.com/source/CF/CF-476.18/CFStringUtilities.c.auto.html)
   31|       |    ///
   32|       |    /// - Parameter name: IANA charset name.
   33|      0|    init?(ianaCharsetName name: String) {
   34|      0|        switch name.lowercased() {
   35|      0|        case "utf-8":
   36|      0|            self = .utf8
   37|      0|        case "iso-8859-1":
   38|      0|            self = .isoLatin1
   39|      0|        case "unicode-1-1", "iso-10646-ucs-2", "utf-16":
   40|      0|            self = .utf16
   41|      0|        case "utf-16be":
   42|      0|            self = .utf16BigEndian
   43|      0|        case "utf-16le":
   44|      0|            self = .utf16LittleEndian
   45|      0|        case "utf-32":
   46|      0|            self = .utf32
   47|      0|        case "utf-32be":
   48|      0|            self = .utf32BigEndian
   49|      0|        case "utf-32le":
   50|      0|            self = .utf32LittleEndian
   51|      0|        default:
   52|      0|            return nil
   53|      0|        }
   54|      0|    }
   55|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/URLConvertible+URLRequestConvertible.swift:
    1|       |//
    2|       |//  URLConvertible+URLRequestConvertible.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Types adopting the `URLConvertible` protocol can be used to construct `URL`s, which can then be used to construct
   28|       |/// `URLRequests`.
   29|       |public protocol URLConvertible {
   30|       |    /// Returns a `URL` from the conforming instance or throws.
   31|       |    ///
   32|       |    /// - Returns: The `URL` created from the instance.
   33|       |    /// - Throws:  Any error thrown while creating the `URL`.
   34|       |    func asURL() throws -> URL
   35|       |}
   36|       |
   37|       |extension String: URLConvertible {
   38|       |    /// Returns a `URL` if `self` can be used to initialize a `URL` instance, otherwise throws.
   39|       |    ///
   40|       |    /// - Returns: The `URL` initialized with `self`.
   41|       |    /// - Throws:  An `AFError.invalidURL` instance.
   42|      0|    public func asURL() throws -> URL {
   43|      0|        guard let url = URL(string: self) else { throw AFError.invalidURL(url: self) }
   44|      0|
   45|      0|        return url
   46|      0|    }
   47|       |}
   48|       |
   49|       |extension URL: URLConvertible {
   50|       |    /// Returns `self`.
   51|      0|    public func asURL() throws -> URL { self }
   52|       |}
   53|       |
   54|       |extension URLComponents: URLConvertible {
   55|       |    /// Returns a `URL` if the `self`'s `url` is not nil, otherwise throws.
   56|       |    ///
   57|       |    /// - Returns: The `URL` from the `url` property.
   58|       |    /// - Throws:  An `AFError.invalidURL` instance.
   59|      0|    public func asURL() throws -> URL {
   60|      0|        guard let url = url else { throw AFError.invalidURL(url: self) }
   61|      0|
   62|      0|        return url
   63|      0|    }
   64|       |}
   65|       |
   66|       |// MARK: -
   67|       |
   68|       |/// Types adopting the `URLRequestConvertible` protocol can be used to safely construct `URLRequest`s.
   69|       |public protocol URLRequestConvertible {
   70|       |    /// Returns a `URLRequest` or throws if an `Error` was encountered.
   71|       |    ///
   72|       |    /// - Returns: A `URLRequest`.
   73|       |    /// - Throws:  Any error thrown while constructing the `URLRequest`.
   74|       |    func asURLRequest() throws -> URLRequest
   75|       |}
   76|       |
   77|       |extension URLRequestConvertible {
   78|       |    /// The `URLRequest` returned by discarding any `Error` encountered.
   79|      0|    public var urlRequest: URLRequest? { try? asURLRequest() }
   80|       |}
   81|       |
   82|       |extension URLRequest: URLRequestConvertible {
   83|       |    /// Returns `self`.
   84|      0|    public func asURLRequest() throws -> URLRequest { self }
   85|       |}
   86|       |
   87|       |// MARK: -
   88|       |
   89|       |extension URLRequest {
   90|       |    /// Creates an instance with the specified `url`, `method`, and `headers`.
   91|       |    ///
   92|       |    /// - Parameters:
   93|       |    ///   - url:     The `URLConvertible` value.
   94|       |    ///   - method:  The `HTTPMethod`.
   95|       |    ///   - headers: The `HTTPHeaders`, `nil` by default.
   96|       |    /// - Throws:    Any error thrown while converting the `URLConvertible` to a `URL`.
   97|      0|    public init(url: URLConvertible, method: HTTPMethod, headers: HTTPHeaders? = nil) throws {
   98|      0|        let url = try url.asURL()
   99|      0|
  100|      0|        self.init(url: url)
  101|      0|
  102|      0|        httpMethod = method.rawValue
  103|      0|        allHTTPHeaderFields = headers?.dictionary
  104|      0|    }
  105|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/URLEncodedFormEncoder.swift:
    1|       |//
    2|       |//  URLEncodedFormEncoder.swift
    3|       |//
    4|       |//  Copyright (c) 2019 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// An object that encodes instances into URL-encoded query strings.
   28|       |///
   29|       |/// There is no published specification for how to encode collection types. By default, the convention of appending
   30|       |/// `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for
   31|       |/// nested dictionary values (`foo[bar]=baz`) is used. Optionally, `ArrayEncoding` can be used to omit the
   32|       |/// square brackets appended to array keys.
   33|       |///
   34|       |/// `BoolEncoding` can be used to configure how `Bool` values are encoded. The default behavior is to encode
   35|       |/// `true` as 1 and `false` as 0.
   36|       |///
   37|       |/// `DateEncoding` can be used to configure how `Date` values are encoded. By default, the `.deferredToDate`
   38|       |/// strategy is used, which formats dates from their structure.
   39|       |///
   40|       |/// `SpaceEncoding` can be used to configure how spaces are encoded. Modern encodings use percent replacement (`%20`),
   41|       |/// while older encodings may expect spaces to be replaced with `+`.
   42|       |///
   43|       |/// This type is largely based on Vapor's [`url-encoded-form`](https://github.com/vapor/url-encoded-form) project.
   44|       |public final class URLEncodedFormEncoder {
   45|       |    /// Encoding to use for `Array` values.
   46|       |    public enum ArrayEncoding {
   47|       |        /// An empty set of square brackets ("[]") are appended to the key for every value. This is the default encoding.
   48|       |        case brackets
   49|       |        /// No brackets are appended to the key and the key is encoded as is.
   50|       |        case noBrackets
   51|       |
   52|       |        /// Encodes the key according to the encoding.
   53|       |        ///
   54|       |        /// - Parameter key: The `key` to encode.
   55|       |        /// - Returns:       The encoded key.
   56|      0|        func encode(_ key: String) -> String {
   57|      0|            switch self {
   58|      0|            case .brackets: return "\(key)[]"
   59|      0|            case .noBrackets: return key
   60|      0|            }
   61|      0|        }
   62|       |    }
   63|       |
   64|       |    /// Encoding to use for `Bool` values.
   65|       |    public enum BoolEncoding {
   66|       |        /// Encodes `true` as `1`, `false` as `0`.
   67|       |        case numeric
   68|       |        /// Encodes `true` as "true", `false` as "false". This is the default encoding.
   69|       |        case literal
   70|       |
   71|       |        /// Encodes the given `Bool` as a `String`.
   72|       |        ///
   73|       |        /// - Parameter value: The `Bool` to encode.
   74|       |        ///
   75|       |        /// - Returns:         The encoded `String`.
   76|      0|        func encode(_ value: Bool) -> String {
   77|      0|            switch self {
   78|      0|            case .numeric: return value ? "1" : "0"
   79|      0|            case .literal: return value ? "true" : "false"
   80|      0|            }
   81|      0|        }
   82|       |    }
   83|       |
   84|       |    /// Encoding to use for `Data` values.
   85|       |    public enum DataEncoding {
   86|       |        /// Defers encoding to the `Data` type.
   87|       |        case deferredToData
   88|       |        /// Encodes `Data` as a Base64-encoded string. This is the default encoding.
   89|       |        case base64
   90|       |        /// Encode the `Data` as a custom value encoded by the given closure.
   91|       |        case custom((Data) throws -> String)
   92|       |
   93|       |        /// Encodes `Data` according to the encoding.
   94|       |        ///
   95|       |        /// - Parameter data: The `Data` to encode.
   96|       |        ///
   97|       |        /// - Returns:        The encoded `String`, or `nil` if the `Data` should be encoded according to its
   98|       |        ///                   `Encodable` implementation.
   99|      0|        func encode(_ data: Data) throws -> String? {
  100|      0|            switch self {
  101|      0|            case .deferredToData: return nil
  102|      0|            case .base64: return data.base64EncodedString()
  103|      0|            case let .custom(encoding): return try encoding(data)
  104|      0|            }
  105|      0|        }
  106|       |    }
  107|       |
  108|       |    /// Encoding to use for `Date` values.
  109|       |    public enum DateEncoding {
  110|       |        /// ISO8601 and RFC3339 formatter.
  111|      0|        private static let iso8601Formatter: ISO8601DateFormatter = {
  112|      0|            let formatter = ISO8601DateFormatter()
  113|      0|            formatter.formatOptions = .withInternetDateTime
  114|      0|            return formatter
  115|      0|        }()
  116|       |
  117|       |        /// Defers encoding to the `Date` type. This is the default encoding.
  118|       |        case deferredToDate
  119|       |        /// Encodes `Date`s as seconds since midnight UTC on January 1, 1970.
  120|       |        case secondsSince1970
  121|       |        /// Encodes `Date`s as milliseconds since midnight UTC on January 1, 1970.
  122|       |        case millisecondsSince1970
  123|       |        /// Encodes `Date`s according to the ISO8601 and RFC3339 standards.
  124|       |        case iso8601
  125|       |        /// Encodes `Date`s using the given `DateFormatter`.
  126|       |        case formatted(DateFormatter)
  127|       |        /// Encodes `Date`s using the given closure.
  128|       |        case custom((Date) throws -> String)
  129|       |
  130|       |        /// Encodes the date according to the encoding.
  131|       |        ///
  132|       |        /// - Parameter date: The `Date` to encode.
  133|       |        ///
  134|       |        /// - Returns:        The encoded `String`, or `nil` if the `Date` should be encoded according to its
  135|       |        ///                   `Encodable` implementation.
  136|      0|        func encode(_ date: Date) throws -> String? {
  137|      0|            switch self {
  138|      0|            case .deferredToDate:
  139|      0|                return nil
  140|      0|            case .secondsSince1970:
  141|      0|                return String(date.timeIntervalSince1970)
  142|      0|            case .millisecondsSince1970:
  143|      0|                return String(date.timeIntervalSince1970 * 1000.0)
  144|      0|            case .iso8601:
  145|      0|                return DateEncoding.iso8601Formatter.string(from: date)
  146|      0|            case let .formatted(formatter):
  147|      0|                return formatter.string(from: date)
  148|      0|            case let .custom(closure):
  149|      0|                return try closure(date)
  150|      0|            }
  151|      0|        }
  152|       |    }
  153|       |
  154|       |    /// Encoding to use for keys.
  155|       |    ///
  156|       |    /// This type is derived from [`JSONEncoder`'s `KeyEncodingStrategy`](https://github.com/apple/swift/blob/6aa313b8dd5f05135f7f878eccc1db6f9fbe34ff/stdlib/public/Darwin/Foundation/JSONEncoder.swift#L128)
  157|       |    /// and [`XMLEncoder`s `KeyEncodingStrategy`](https://github.com/MaxDesiatov/XMLCoder/blob/master/Sources/XMLCoder/Encoder/XMLEncoder.swift#L102).
  158|       |    public enum KeyEncoding {
  159|       |        /// Use the keys specified by each type. This is the default encoding.
  160|       |        case useDefaultKeys
  161|       |        /// Convert from "camelCaseKeys" to "snake_case_keys" before writing a key.
  162|       |        ///
  163|       |        /// Capital characters are determined by testing membership in
  164|       |        /// `CharacterSet.uppercaseLetters` and `CharacterSet.lowercaseLetters`
  165|       |        /// (Unicode General Categories Lu and Lt).
  166|       |        /// The conversion to lower case uses `Locale.system`, also known as
  167|       |        /// the ICU "root" locale. This means the result is consistent
  168|       |        /// regardless of the current user's locale and language preferences.
  169|       |        ///
  170|       |        /// Converting from camel case to snake case:
  171|       |        /// 1. Splits words at the boundary of lower-case to upper-case
  172|       |        /// 2. Inserts `_` between words
  173|       |        /// 3. Lowercases the entire string
  174|       |        /// 4. Preserves starting and ending `_`.
  175|       |        ///
  176|       |        /// For example, `oneTwoThree` becomes `one_two_three`. `_oneTwoThree_` becomes `_one_two_three_`.
  177|       |        ///
  178|       |        /// - Note: Using a key encoding strategy has a nominal performance cost, as each string key has to be converted.
  179|       |        case convertToSnakeCase
  180|       |        /// Same as convertToSnakeCase, but using `-` instead of `_`.
  181|       |        /// For example `oneTwoThree` becomes `one-two-three`.
  182|       |        case convertToKebabCase
  183|       |        /// Capitalize the first letter only.
  184|       |        /// For example `oneTwoThree` becomes  `OneTwoThree`.
  185|       |        case capitalized
  186|       |        /// Uppercase all letters.
  187|       |        /// For example `oneTwoThree` becomes  `ONETWOTHREE`.
  188|       |        case uppercased
  189|       |        /// Lowercase all letters.
  190|       |        /// For example `oneTwoThree` becomes  `onetwothree`.
  191|       |        case lowercased
  192|       |        /// A custom encoding using the provided closure.
  193|       |        case custom((String) -> String)
  194|       |
  195|      0|        func encode(_ key: String) -> String {
  196|      0|            switch self {
  197|      0|            case .useDefaultKeys: return key
  198|      0|            case .convertToSnakeCase: return convertToSnakeCase(key)
  199|      0|            case .convertToKebabCase: return convertToKebabCase(key)
  200|      0|            case .capitalized: return String(key.prefix(1).uppercased() + key.dropFirst())
  201|      0|            case .uppercased: return key.uppercased()
  202|      0|            case .lowercased: return key.lowercased()
  203|      0|            case let .custom(encoding): return encoding(key)
  204|      0|            }
  205|      0|        }
  206|       |
  207|      0|        private func convertToSnakeCase(_ key: String) -> String {
  208|      0|            convert(key, usingSeparator: "_")
  209|      0|        }
  210|       |
  211|      0|        private func convertToKebabCase(_ key: String) -> String {
  212|      0|            convert(key, usingSeparator: "-")
  213|      0|        }
  214|       |
  215|      0|        private func convert(_ key: String, usingSeparator separator: String) -> String {
  216|      0|            guard !key.isEmpty else { return key }
  217|      0|
  218|      0|            var words: [Range<String.Index>] = []
  219|      0|            // The general idea of this algorithm is to split words on
  220|      0|            // transition from lower to upper case, then on transition of >1
  221|      0|            // upper case characters to lowercase
  222|      0|            //
  223|      0|            // myProperty -> my_property
  224|      0|            // myURLProperty -> my_url_property
  225|      0|            //
  226|      0|            // It is assumed, per Swift naming conventions, that the first character of the key is lowercase.
  227|      0|            var wordStart = key.startIndex
  228|      0|            var searchRange = key.index(after: wordStart)..<key.endIndex
  229|      0|
  230|      0|            // Find next uppercase character
  231|      0|            while let upperCaseRange = key.rangeOfCharacter(from: CharacterSet.uppercaseLetters, options: [], range: searchRange) {
  232|      0|                let untilUpperCase = wordStart..<upperCaseRange.lowerBound
  233|      0|                words.append(untilUpperCase)
  234|      0|
  235|      0|                // Find next lowercase character
  236|      0|                searchRange = upperCaseRange.lowerBound..<searchRange.upperBound
  237|      0|                guard let lowerCaseRange = key.rangeOfCharacter(from: CharacterSet.lowercaseLetters, options: [], range: searchRange) else {
  238|      0|                    // There are no more lower case letters. Just end here.
  239|      0|                    wordStart = searchRange.lowerBound
  240|      0|                    break
  241|      0|                }
  242|      0|
  243|      0|                // Is the next lowercase letter more than 1 after the uppercase?
  244|      0|                // If so, we encountered a group of uppercase letters that we
  245|      0|                // should treat as its own word
  246|      0|                let nextCharacterAfterCapital = key.index(after: upperCaseRange.lowerBound)
  247|      0|                if lowerCaseRange.lowerBound == nextCharacterAfterCapital {
  248|      0|                    // The next character after capital is a lower case character and therefore not a word boundary.
  249|      0|                    // Continue searching for the next upper case for the boundary.
  250|      0|                    wordStart = upperCaseRange.lowerBound
  251|      0|                } else {
  252|      0|                    // There was a range of >1 capital letters. Turn those into a word, stopping at the capital before the lower case character.
  253|      0|                    let beforeLowerIndex = key.index(before: lowerCaseRange.lowerBound)
  254|      0|                    words.append(upperCaseRange.lowerBound..<beforeLowerIndex)
  255|      0|
  256|      0|                    // Next word starts at the capital before the lowercase we just found
  257|      0|                    wordStart = beforeLowerIndex
  258|      0|                }
  259|      0|                searchRange = lowerCaseRange.upperBound..<searchRange.upperBound
  260|      0|            }
  261|      0|            words.append(wordStart..<searchRange.upperBound)
  262|      0|            let result = words.map { range in
  263|      0|                key[range].lowercased()
  264|      0|            }.joined(separator: separator)
  265|      0|
  266|      0|            return result
  267|      0|        }
  268|       |    }
  269|       |
  270|       |    /// Encoding to use for spaces.
  271|       |    public enum SpaceEncoding {
  272|       |        /// Encodes spaces according to normal percent escaping rules (%20).
  273|       |        case percentEscaped
  274|       |        /// Encodes spaces as `+`,
  275|       |        case plusReplaced
  276|       |
  277|       |        /// Encodes the string according to the encoding.
  278|       |        ///
  279|       |        /// - Parameter string: The `String` to encode.
  280|       |        ///
  281|       |        /// - Returns:          The encoded `String`.
  282|      0|        func encode(_ string: String) -> String {
  283|      0|            switch self {
  284|      0|            case .percentEscaped: return string.replacingOccurrences(of: " ", with: "%20")
  285|      0|            case .plusReplaced: return string.replacingOccurrences(of: " ", with: "+")
  286|      0|            }
  287|      0|        }
  288|       |    }
  289|       |
  290|       |    /// `URLEncodedFormEncoder` error.
  291|       |    public enum Error: Swift.Error {
  292|       |        /// An invalid root object was created by the encoder. Only keyed values are valid.
  293|       |        case invalidRootObject(String)
  294|       |
  295|      0|        var localizedDescription: String {
  296|      0|            switch self {
  297|      0|            case let .invalidRootObject(object):
  298|      0|                return "URLEncodedFormEncoder requires keyed root object. Received \(object) instead."
  299|      0|            }
  300|      0|        }
  301|       |    }
  302|       |
  303|       |    /// Whether or not to sort the encoded key value pairs.
  304|       |    ///
  305|       |    /// - Note: This setting ensures a consistent ordering for all encodings of the same parameters. When set to `false`,
  306|       |    ///         encoded `Dictionary` values may have a different encoded order each time they're encoded due to
  307|       |    ///       ` Dictionary`'s random storage order, but `Encodable` types will maintain their encoded order.
  308|       |    public let alphabetizeKeyValuePairs: Bool
  309|       |    /// The `ArrayEncoding` to use.
  310|       |    public let arrayEncoding: ArrayEncoding
  311|       |    /// The `BoolEncoding` to use.
  312|       |    public let boolEncoding: BoolEncoding
  313|       |    /// THe `DataEncoding` to use.
  314|       |    public let dataEncoding: DataEncoding
  315|       |    /// The `DateEncoding` to use.
  316|       |    public let dateEncoding: DateEncoding
  317|       |    /// The `KeyEncoding` to use.
  318|       |    public let keyEncoding: KeyEncoding
  319|       |    /// The `SpaceEncoding` to use.
  320|       |    public let spaceEncoding: SpaceEncoding
  321|       |    /// The `CharacterSet` of allowed (non-escaped) characters.
  322|       |    public var allowedCharacters: CharacterSet
  323|       |
  324|       |    /// Creates an instance from the supplied parameters.
  325|       |    ///
  326|       |    /// - Parameters:
  327|       |    ///   - alphabetizeKeyValuePairs: Whether or not to sort the encoded key value pairs. `true` by default.
  328|       |    ///   - arrayEncoding:            The `ArrayEncoding` to use. `.brackets` by default.
  329|       |    ///   - boolEncoding:             The `BoolEncoding` to use. `.numeric` by default.
  330|       |    ///   - dataEncoding:             The `DataEncoding` to use. `.base64` by default.
  331|       |    ///   - dateEncoding:             The `DateEncoding` to use. `.deferredToDate` by default.
  332|       |    ///   - keyEncoding:              The `KeyEncoding` to use. `.useDefaultKeys` by default.
  333|       |    ///   - spaceEncoding:            The `SpaceEncoding` to use. `.percentEscaped` by default.
  334|       |    ///   - allowedCharacters:        The `CharacterSet` of allowed (non-escaped) characters. `.afURLQueryAllowed` by
  335|       |    ///                               default.
  336|       |    public init(alphabetizeKeyValuePairs: Bool = true,
  337|       |                arrayEncoding: ArrayEncoding = .brackets,
  338|       |                boolEncoding: BoolEncoding = .numeric,
  339|       |                dataEncoding: DataEncoding = .base64,
  340|       |                dateEncoding: DateEncoding = .deferredToDate,
  341|       |                keyEncoding: KeyEncoding = .useDefaultKeys,
  342|       |                spaceEncoding: SpaceEncoding = .percentEscaped,
  343|      0|                allowedCharacters: CharacterSet = .afURLQueryAllowed) {
  344|      0|        self.alphabetizeKeyValuePairs = alphabetizeKeyValuePairs
  345|      0|        self.arrayEncoding = arrayEncoding
  346|      0|        self.boolEncoding = boolEncoding
  347|      0|        self.dataEncoding = dataEncoding
  348|      0|        self.dateEncoding = dateEncoding
  349|      0|        self.keyEncoding = keyEncoding
  350|      0|        self.spaceEncoding = spaceEncoding
  351|      0|        self.allowedCharacters = allowedCharacters
  352|      0|    }
  353|       |
  354|      0|    func encode(_ value: Encodable) throws -> URLEncodedFormComponent {
  355|      0|        let context = URLEncodedFormContext(.object([]))
  356|      0|        let encoder = _URLEncodedFormEncoder(context: context,
  357|      0|                                             boolEncoding: boolEncoding,
  358|      0|                                             dataEncoding: dataEncoding,
  359|      0|                                             dateEncoding: dateEncoding)
  360|      0|        try value.encode(to: encoder)
  361|      0|
  362|      0|        return context.component
  363|      0|    }
  364|       |
  365|       |    /// Encodes the `value` as a URL form encoded `String`.
  366|       |    ///
  367|       |    /// - Parameter value: The `Encodable` value.`
  368|       |    ///
  369|       |    /// - Returns:         The encoded `String`.
  370|       |    /// - Throws:          An `Error` or `EncodingError` instance if encoding fails.
  371|      0|    public func encode(_ value: Encodable) throws -> String {
  372|      0|        let component: URLEncodedFormComponent = try encode(value)
  373|      0|
  374|      0|        guard case let .object(object) = component else {
  375|      0|            throw Error.invalidRootObject("\(component)")
  376|      0|        }
  377|      0|
  378|      0|        let serializer = URLEncodedFormSerializer(alphabetizeKeyValuePairs: alphabetizeKeyValuePairs,
  379|      0|                                                  arrayEncoding: arrayEncoding,
  380|      0|                                                  keyEncoding: keyEncoding,
  381|      0|                                                  spaceEncoding: spaceEncoding,
  382|      0|                                                  allowedCharacters: allowedCharacters)
  383|      0|        let query = serializer.serialize(object)
  384|      0|
  385|      0|        return query
  386|      0|    }
  387|       |
  388|       |    /// Encodes the value as `Data`. This is performed by first creating an encoded `String` and then returning the
  389|       |    /// `.utf8` data.
  390|       |    ///
  391|       |    /// - Parameter value: The `Encodable` value.
  392|       |    ///
  393|       |    /// - Returns:         The encoded `Data`.
  394|       |    ///
  395|       |    /// - Throws:          An `Error` or `EncodingError` instance if encoding fails.
  396|      0|    public func encode(_ value: Encodable) throws -> Data {
  397|      0|        let string: String = try encode(value)
  398|      0|
  399|      0|        return Data(string.utf8)
  400|      0|    }
  401|       |}
  402|       |
  403|       |final class _URLEncodedFormEncoder {
  404|       |    var codingPath: [CodingKey]
  405|       |    // Returns an empty dictionary, as this encoder doesn't support userInfo.
  406|      0|    var userInfo: [CodingUserInfoKey: Any] { [:] }
  407|       |
  408|       |    let context: URLEncodedFormContext
  409|       |
  410|       |    private let boolEncoding: URLEncodedFormEncoder.BoolEncoding
  411|       |    private let dataEncoding: URLEncodedFormEncoder.DataEncoding
  412|       |    private let dateEncoding: URLEncodedFormEncoder.DateEncoding
  413|       |
  414|       |    init(context: URLEncodedFormContext,
  415|       |         codingPath: [CodingKey] = [],
  416|       |         boolEncoding: URLEncodedFormEncoder.BoolEncoding,
  417|       |         dataEncoding: URLEncodedFormEncoder.DataEncoding,
  418|      0|         dateEncoding: URLEncodedFormEncoder.DateEncoding) {
  419|      0|        self.context = context
  420|      0|        self.codingPath = codingPath
  421|      0|        self.boolEncoding = boolEncoding
  422|      0|        self.dataEncoding = dataEncoding
  423|      0|        self.dateEncoding = dateEncoding
  424|      0|    }
  425|       |}
  426|       |
  427|       |extension _URLEncodedFormEncoder: Encoder {
  428|      0|    func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> where Key: CodingKey {
  429|      0|        let container = _URLEncodedFormEncoder.KeyedContainer<Key>(context: context,
  430|      0|                                                                   codingPath: codingPath,
  431|      0|                                                                   boolEncoding: boolEncoding,
  432|      0|                                                                   dataEncoding: dataEncoding,
  433|      0|                                                                   dateEncoding: dateEncoding)
  434|      0|        return KeyedEncodingContainer(container)
  435|      0|    }
  436|       |
  437|      0|    func unkeyedContainer() -> UnkeyedEncodingContainer {
  438|      0|        _URLEncodedFormEncoder.UnkeyedContainer(context: context,
  439|      0|                                                codingPath: codingPath,
  440|      0|                                                boolEncoding: boolEncoding,
  441|      0|                                                dataEncoding: dataEncoding,
  442|      0|                                                dateEncoding: dateEncoding)
  443|      0|    }
  444|       |
  445|      0|    func singleValueContainer() -> SingleValueEncodingContainer {
  446|      0|        _URLEncodedFormEncoder.SingleValueContainer(context: context,
  447|      0|                                                    codingPath: codingPath,
  448|      0|                                                    boolEncoding: boolEncoding,
  449|      0|                                                    dataEncoding: dataEncoding,
  450|      0|                                                    dateEncoding: dateEncoding)
  451|      0|    }
  452|       |}
  453|       |
  454|       |final class URLEncodedFormContext {
  455|       |    var component: URLEncodedFormComponent
  456|       |
  457|      0|    init(_ component: URLEncodedFormComponent) {
  458|      0|        self.component = component
  459|      0|    }
  460|       |}
  461|       |
  462|       |enum URLEncodedFormComponent {
  463|       |    typealias Object = [(key: String, value: URLEncodedFormComponent)]
  464|       |
  465|       |    case string(String)
  466|       |    case array([URLEncodedFormComponent])
  467|       |    case object(Object)
  468|       |
  469|       |    /// Converts self to an `[URLEncodedFormData]` or returns `nil` if not convertible.
  470|      0|    var array: [URLEncodedFormComponent]? {
  471|      0|        switch self {
  472|      0|        case let .array(array): return array
  473|      0|        default: return nil
  474|      0|        }
  475|      0|    }
  476|       |
  477|       |    /// Converts self to an `Object` or returns `nil` if not convertible.
  478|      0|    var object: Object? {
  479|      0|        switch self {
  480|      0|        case let .object(object): return object
  481|      0|        default: return nil
  482|      0|        }
  483|      0|    }
  484|       |
  485|       |    /// Sets self to the supplied value at a given path.
  486|       |    ///
  487|       |    ///     data.set(to: "hello", at: ["path", "to", "value"])
  488|       |    ///
  489|       |    /// - parameters:
  490|       |    ///     - value: Value of `Self` to set at the supplied path.
  491|       |    ///     - path: `CodingKey` path to update with the supplied value.
  492|      0|    public mutating func set(to value: URLEncodedFormComponent, at path: [CodingKey]) {
  493|      0|        set(&self, to: value, at: path)
  494|      0|    }
  495|       |
  496|       |    /// Recursive backing method to `set(to:at:)`.
  497|      0|    private func set(_ context: inout URLEncodedFormComponent, to value: URLEncodedFormComponent, at path: [CodingKey]) {
  498|      0|        guard path.count >= 1 else {
  499|      0|            context = value
  500|      0|            return
  501|      0|        }
  502|      0|
  503|      0|        let end = path[0]
  504|      0|        var child: URLEncodedFormComponent
  505|      0|        switch path.count {
  506|      0|        case 1:
  507|      0|            child = value
  508|      0|        case 2...:
  509|      0|            if let index = end.intValue {
  510|      0|                let array = context.array ?? []
  511|      0|                if array.count > index {
  512|      0|                    child = array[index]
  513|      0|                } else {
  514|      0|                    child = .array([])
  515|      0|                }
  516|      0|                set(&child, to: value, at: Array(path[1...]))
  517|      0|            } else {
  518|      0|                child = context.object?.first { $0.key == end.stringValue }?.value ?? .object(.init())
  519|      0|                set(&child, to: value, at: Array(path[1...]))
  520|      0|            }
  521|      0|        default: fatalError("Unreachable")
  522|      0|        }
  523|      0|
  524|      0|        if let index = end.intValue {
  525|      0|            if var array = context.array {
  526|      0|                if array.count > index {
  527|      0|                    array[index] = child
  528|      0|                } else {
  529|      0|                    array.append(child)
  530|      0|                }
  531|      0|                context = .array(array)
  532|      0|            } else {
  533|      0|                context = .array([child])
  534|      0|            }
  535|      0|        } else {
  536|      0|            if var object = context.object {
  537|      0|                if let index = object.firstIndex(where: { $0.key == end.stringValue }) {
  538|      0|                    object[index] = (key: end.stringValue, value: child)
  539|      0|                } else {
  540|      0|                    object.append((key: end.stringValue, value: child))
  541|      0|                }
  542|      0|                context = .object(object)
  543|      0|            } else {
  544|      0|                context = .object([(key: end.stringValue, value: child)])
  545|      0|            }
  546|      0|        }
  547|      0|    }
  548|       |}
  549|       |
  550|       |struct AnyCodingKey: CodingKey, Hashable {
  551|       |    let stringValue: String
  552|       |    let intValue: Int?
  553|       |
  554|      0|    init?(stringValue: String) {
  555|      0|        self.stringValue = stringValue
  556|      0|        intValue = nil
  557|      0|    }
  558|       |
  559|      0|    init?(intValue: Int) {
  560|      0|        stringValue = "\(intValue)"
  561|      0|        self.intValue = intValue
  562|      0|    }
  563|       |
  564|      0|    init<Key>(_ base: Key) where Key: CodingKey {
  565|      0|        if let intValue = base.intValue {
  566|      0|            self.init(intValue: intValue)!
  567|      0|        } else {
  568|      0|            self.init(stringValue: base.stringValue)!
  569|      0|        }
  570|      0|    }
  571|       |}
  572|       |
  573|       |extension _URLEncodedFormEncoder {
  574|       |    final class KeyedContainer<Key> where Key: CodingKey {
  575|       |        var codingPath: [CodingKey]
  576|       |
  577|       |        private let context: URLEncodedFormContext
  578|       |        private let boolEncoding: URLEncodedFormEncoder.BoolEncoding
  579|       |        private let dataEncoding: URLEncodedFormEncoder.DataEncoding
  580|       |        private let dateEncoding: URLEncodedFormEncoder.DateEncoding
  581|       |
  582|       |        init(context: URLEncodedFormContext,
  583|       |             codingPath: [CodingKey],
  584|       |             boolEncoding: URLEncodedFormEncoder.BoolEncoding,
  585|       |             dataEncoding: URLEncodedFormEncoder.DataEncoding,
  586|      0|             dateEncoding: URLEncodedFormEncoder.DateEncoding) {
  587|      0|            self.context = context
  588|      0|            self.codingPath = codingPath
  589|      0|            self.boolEncoding = boolEncoding
  590|      0|            self.dataEncoding = dataEncoding
  591|      0|            self.dateEncoding = dateEncoding
  592|      0|        }
  593|       |
  594|      0|        private func nestedCodingPath(for key: CodingKey) -> [CodingKey] {
  595|      0|            codingPath + [key]
  596|      0|        }
  597|       |    }
  598|       |}
  599|       |
  600|       |extension _URLEncodedFormEncoder.KeyedContainer: KeyedEncodingContainerProtocol {
  601|      0|    func encodeNil(forKey key: Key) throws {
  602|      0|        let context = EncodingError.Context(codingPath: codingPath,
  603|      0|                                            debugDescription: "URLEncodedFormEncoder cannot encode nil values.")
  604|      0|        throw EncodingError.invalidValue("\(key): nil", context)
  605|      0|    }
  606|       |
  607|      0|    func encode<T>(_ value: T, forKey key: Key) throws where T: Encodable {
  608|      0|        var container = nestedSingleValueEncoder(for: key)
  609|      0|        try container.encode(value)
  610|      0|    }
  611|       |
  612|      0|    func nestedSingleValueEncoder(for key: Key) -> SingleValueEncodingContainer {
  613|      0|        let container = _URLEncodedFormEncoder.SingleValueContainer(context: context,
  614|      0|                                                                    codingPath: nestedCodingPath(for: key),
  615|      0|                                                                    boolEncoding: boolEncoding,
  616|      0|                                                                    dataEncoding: dataEncoding,
  617|      0|                                                                    dateEncoding: dateEncoding)
  618|      0|
  619|      0|        return container
  620|      0|    }
  621|       |
  622|      0|    func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer {
  623|      0|        let container = _URLEncodedFormEncoder.UnkeyedContainer(context: context,
  624|      0|                                                                codingPath: nestedCodingPath(for: key),
  625|      0|                                                                boolEncoding: boolEncoding,
  626|      0|                                                                dataEncoding: dataEncoding,
  627|      0|                                                                dateEncoding: dateEncoding)
  628|      0|
  629|      0|        return container
  630|      0|    }
  631|       |
  632|      0|    func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey: CodingKey {
  633|      0|        let container = _URLEncodedFormEncoder.KeyedContainer<NestedKey>(context: context,
  634|      0|                                                                         codingPath: nestedCodingPath(for: key),
  635|      0|                                                                         boolEncoding: boolEncoding,
  636|      0|                                                                         dataEncoding: dataEncoding,
  637|      0|                                                                         dateEncoding: dateEncoding)
  638|      0|
  639|      0|        return KeyedEncodingContainer(container)
  640|      0|    }
  641|       |
  642|      0|    func superEncoder() -> Encoder {
  643|      0|        _URLEncodedFormEncoder(context: context,
  644|      0|                               codingPath: codingPath,
  645|      0|                               boolEncoding: boolEncoding,
  646|      0|                               dataEncoding: dataEncoding,
  647|      0|                               dateEncoding: dateEncoding)
  648|      0|    }
  649|       |
  650|      0|    func superEncoder(forKey key: Key) -> Encoder {
  651|      0|        _URLEncodedFormEncoder(context: context,
  652|      0|                               codingPath: nestedCodingPath(for: key),
  653|      0|                               boolEncoding: boolEncoding,
  654|      0|                               dataEncoding: dataEncoding,
  655|      0|                               dateEncoding: dateEncoding)
  656|      0|    }
  657|       |}
  658|       |
  659|       |extension _URLEncodedFormEncoder {
  660|       |    final class SingleValueContainer {
  661|       |        var codingPath: [CodingKey]
  662|       |
  663|       |        private var canEncodeNewValue = true
  664|       |
  665|       |        private let context: URLEncodedFormContext
  666|       |        private let boolEncoding: URLEncodedFormEncoder.BoolEncoding
  667|       |        private let dataEncoding: URLEncodedFormEncoder.DataEncoding
  668|       |        private let dateEncoding: URLEncodedFormEncoder.DateEncoding
  669|       |
  670|       |        init(context: URLEncodedFormContext,
  671|       |             codingPath: [CodingKey],
  672|       |             boolEncoding: URLEncodedFormEncoder.BoolEncoding,
  673|       |             dataEncoding: URLEncodedFormEncoder.DataEncoding,
  674|      0|             dateEncoding: URLEncodedFormEncoder.DateEncoding) {
  675|      0|            self.context = context
  676|      0|            self.codingPath = codingPath
  677|      0|            self.boolEncoding = boolEncoding
  678|      0|            self.dataEncoding = dataEncoding
  679|      0|            self.dateEncoding = dateEncoding
  680|      0|        }
  681|       |
  682|      0|        private func checkCanEncode(value: Any?) throws {
  683|      0|            guard canEncodeNewValue else {
  684|      0|                let context = EncodingError.Context(codingPath: codingPath,
  685|      0|                                                    debugDescription: "Attempt to encode value through single value container when previously value already encoded.")
  686|      0|                throw EncodingError.invalidValue(value as Any, context)
  687|      0|            }
  688|      0|        }
  689|       |    }
  690|       |}
  691|       |
  692|       |extension _URLEncodedFormEncoder.SingleValueContainer: SingleValueEncodingContainer {
  693|      0|    func encodeNil() throws {
  694|      0|        try checkCanEncode(value: nil)
  695|      0|        defer { canEncodeNewValue = false }
  696|      0|
  697|      0|        let context = EncodingError.Context(codingPath: codingPath,
  698|      0|                                            debugDescription: "URLEncodedFormEncoder cannot encode nil values.")
  699|      0|        throw EncodingError.invalidValue("nil", context)
  700|      0|    }
  701|       |
  702|      0|    func encode(_ value: Bool) throws {
  703|      0|        try encode(value, as: String(boolEncoding.encode(value)))
  704|      0|    }
  705|       |
  706|      0|    func encode(_ value: String) throws {
  707|      0|        try encode(value, as: value)
  708|      0|    }
  709|       |
  710|      0|    func encode(_ value: Double) throws {
  711|      0|        try encode(value, as: String(value))
  712|      0|    }
  713|       |
  714|      0|    func encode(_ value: Float) throws {
  715|      0|        try encode(value, as: String(value))
  716|      0|    }
  717|       |
  718|      0|    func encode(_ value: Int) throws {
  719|      0|        try encode(value, as: String(value))
  720|      0|    }
  721|       |
  722|      0|    func encode(_ value: Int8) throws {
  723|      0|        try encode(value, as: String(value))
  724|      0|    }
  725|       |
  726|      0|    func encode(_ value: Int16) throws {
  727|      0|        try encode(value, as: String(value))
  728|      0|    }
  729|       |
  730|      0|    func encode(_ value: Int32) throws {
  731|      0|        try encode(value, as: String(value))
  732|      0|    }
  733|       |
  734|      0|    func encode(_ value: Int64) throws {
  735|      0|        try encode(value, as: String(value))
  736|      0|    }
  737|       |
  738|      0|    func encode(_ value: UInt) throws {
  739|      0|        try encode(value, as: String(value))
  740|      0|    }
  741|       |
  742|      0|    func encode(_ value: UInt8) throws {
  743|      0|        try encode(value, as: String(value))
  744|      0|    }
  745|       |
  746|      0|    func encode(_ value: UInt16) throws {
  747|      0|        try encode(value, as: String(value))
  748|      0|    }
  749|       |
  750|      0|    func encode(_ value: UInt32) throws {
  751|      0|        try encode(value, as: String(value))
  752|      0|    }
  753|       |
  754|      0|    func encode(_ value: UInt64) throws {
  755|      0|        try encode(value, as: String(value))
  756|      0|    }
  757|       |
  758|      0|    private func encode<T>(_ value: T, as string: String) throws where T: Encodable {
  759|      0|        try checkCanEncode(value: value)
  760|      0|        defer { canEncodeNewValue = false }
  761|      0|
  762|      0|        context.component.set(to: .string(string), at: codingPath)
  763|      0|    }
  764|       |
  765|      0|    func encode<T>(_ value: T) throws where T: Encodable {
  766|      0|        switch value {
  767|      0|        case let date as Date:
  768|      0|            guard let string = try dateEncoding.encode(date) else {
  769|      0|                try attemptToEncode(value)
  770|      0|                return
  771|      0|            }
  772|      0|
  773|      0|            try encode(value, as: string)
  774|      0|        case let data as Data:
  775|      0|            guard let string = try dataEncoding.encode(data) else {
  776|      0|                try attemptToEncode(value)
  777|      0|                return
  778|      0|            }
  779|      0|
  780|      0|            try encode(value, as: string)
  781|      0|        case let decimal as Decimal:
  782|      0|            // Decimal's `Encodable` implementation returns an object, not a single value, so override it.
  783|      0|            try encode(value, as: String(describing: decimal))
  784|      0|        default:
  785|      0|            try attemptToEncode(value)
  786|      0|        }
  787|      0|    }
  788|       |
  789|      0|    private func attemptToEncode<T>(_ value: T) throws where T: Encodable {
  790|      0|        try checkCanEncode(value: value)
  791|      0|        defer { canEncodeNewValue = false }
  792|      0|
  793|      0|        let encoder = _URLEncodedFormEncoder(context: context,
  794|      0|                                             codingPath: codingPath,
  795|      0|                                             boolEncoding: boolEncoding,
  796|      0|                                             dataEncoding: dataEncoding,
  797|      0|                                             dateEncoding: dateEncoding)
  798|      0|        try value.encode(to: encoder)
  799|      0|    }
  800|       |}
  801|       |
  802|       |extension _URLEncodedFormEncoder {
  803|       |    final class UnkeyedContainer {
  804|       |        var codingPath: [CodingKey]
  805|       |
  806|       |        var count = 0
  807|      0|        var nestedCodingPath: [CodingKey] {
  808|      0|            codingPath + [AnyCodingKey(intValue: count)!]
  809|      0|        }
  810|       |
  811|       |        private let context: URLEncodedFormContext
  812|       |        private let boolEncoding: URLEncodedFormEncoder.BoolEncoding
  813|       |        private let dataEncoding: URLEncodedFormEncoder.DataEncoding
  814|       |        private let dateEncoding: URLEncodedFormEncoder.DateEncoding
  815|       |
  816|       |        init(context: URLEncodedFormContext,
  817|       |             codingPath: [CodingKey],
  818|       |             boolEncoding: URLEncodedFormEncoder.BoolEncoding,
  819|       |             dataEncoding: URLEncodedFormEncoder.DataEncoding,
  820|      0|             dateEncoding: URLEncodedFormEncoder.DateEncoding) {
  821|      0|            self.context = context
  822|      0|            self.codingPath = codingPath
  823|      0|            self.boolEncoding = boolEncoding
  824|      0|            self.dataEncoding = dataEncoding
  825|      0|            self.dateEncoding = dateEncoding
  826|      0|        }
  827|       |    }
  828|       |}
  829|       |
  830|       |extension _URLEncodedFormEncoder.UnkeyedContainer: UnkeyedEncodingContainer {
  831|      0|    func encodeNil() throws {
  832|      0|        let context = EncodingError.Context(codingPath: codingPath,
  833|      0|                                            debugDescription: "URLEncodedFormEncoder cannot encode nil values.")
  834|      0|        throw EncodingError.invalidValue("nil", context)
  835|      0|    }
  836|       |
  837|      0|    func encode<T>(_ value: T) throws where T: Encodable {
  838|      0|        var container = nestedSingleValueContainer()
  839|      0|        try container.encode(value)
  840|      0|    }
  841|       |
  842|      0|    func nestedSingleValueContainer() -> SingleValueEncodingContainer {
  843|      0|        defer { count += 1 }
  844|      0|
  845|      0|        return _URLEncodedFormEncoder.SingleValueContainer(context: context,
  846|      0|                                                           codingPath: nestedCodingPath,
  847|      0|                                                           boolEncoding: boolEncoding,
  848|      0|                                                           dataEncoding: dataEncoding,
  849|      0|                                                           dateEncoding: dateEncoding)
  850|      0|    }
  851|       |
  852|      0|    func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey: CodingKey {
  853|      0|        defer { count += 1 }
  854|      0|        let container = _URLEncodedFormEncoder.KeyedContainer<NestedKey>(context: context,
  855|      0|                                                                         codingPath: nestedCodingPath,
  856|      0|                                                                         boolEncoding: boolEncoding,
  857|      0|                                                                         dataEncoding: dataEncoding,
  858|      0|                                                                         dateEncoding: dateEncoding)
  859|      0|
  860|      0|        return KeyedEncodingContainer(container)
  861|      0|    }
  862|       |
  863|      0|    func nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
  864|      0|        defer { count += 1 }
  865|      0|
  866|      0|        return _URLEncodedFormEncoder.UnkeyedContainer(context: context,
  867|      0|                                                       codingPath: nestedCodingPath,
  868|      0|                                                       boolEncoding: boolEncoding,
  869|      0|                                                       dataEncoding: dataEncoding,
  870|      0|                                                       dateEncoding: dateEncoding)
  871|      0|    }
  872|       |
  873|      0|    func superEncoder() -> Encoder {
  874|      0|        defer { count += 1 }
  875|      0|
  876|      0|        return _URLEncodedFormEncoder(context: context,
  877|      0|                                      codingPath: codingPath,
  878|      0|                                      boolEncoding: boolEncoding,
  879|      0|                                      dataEncoding: dataEncoding,
  880|      0|                                      dateEncoding: dateEncoding)
  881|      0|    }
  882|       |}
  883|       |
  884|       |final class URLEncodedFormSerializer {
  885|       |    private let alphabetizeKeyValuePairs: Bool
  886|       |    private let arrayEncoding: URLEncodedFormEncoder.ArrayEncoding
  887|       |    private let keyEncoding: URLEncodedFormEncoder.KeyEncoding
  888|       |    private let spaceEncoding: URLEncodedFormEncoder.SpaceEncoding
  889|       |    private let allowedCharacters: CharacterSet
  890|       |
  891|       |    init(alphabetizeKeyValuePairs: Bool,
  892|       |         arrayEncoding: URLEncodedFormEncoder.ArrayEncoding,
  893|       |         keyEncoding: URLEncodedFormEncoder.KeyEncoding,
  894|       |         spaceEncoding: URLEncodedFormEncoder.SpaceEncoding,
  895|      0|         allowedCharacters: CharacterSet) {
  896|      0|        self.alphabetizeKeyValuePairs = alphabetizeKeyValuePairs
  897|      0|        self.arrayEncoding = arrayEncoding
  898|      0|        self.keyEncoding = keyEncoding
  899|      0|        self.spaceEncoding = spaceEncoding
  900|      0|        self.allowedCharacters = allowedCharacters
  901|      0|    }
  902|       |
  903|      0|    func serialize(_ object: URLEncodedFormComponent.Object) -> String {
  904|      0|        var output: [String] = []
  905|      0|        for (key, component) in object {
  906|      0|            let value = serialize(component, forKey: key)
  907|      0|            output.append(value)
  908|      0|        }
  909|      0|        output = alphabetizeKeyValuePairs ? output.sorted() : output
  910|      0|
  911|      0|        return output.joinedWithAmpersands()
  912|      0|    }
  913|       |
  914|      0|    func serialize(_ component: URLEncodedFormComponent, forKey key: String) -> String {
  915|      0|        switch component {
  916|      0|        case let .string(string): return "\(escape(keyEncoding.encode(key)))=\(escape(string))"
  917|      0|        case let .array(array): return serialize(array, forKey: key)
  918|      0|        case let .object(object): return serialize(object, forKey: key)
  919|      0|        }
  920|      0|    }
  921|       |
  922|      0|    func serialize(_ object: URLEncodedFormComponent.Object, forKey key: String) -> String {
  923|      0|        var segments: [String] = object.map { subKey, value in
  924|      0|            let keyPath = "[\(subKey)]"
  925|      0|            return serialize(value, forKey: key + keyPath)
  926|      0|        }
  927|      0|        segments = alphabetizeKeyValuePairs ? segments.sorted() : segments
  928|      0|
  929|      0|        return segments.joinedWithAmpersands()
  930|      0|    }
  931|       |
  932|      0|    func serialize(_ array: [URLEncodedFormComponent], forKey key: String) -> String {
  933|      0|        var segments: [String] = array.map { component in
  934|      0|            let keyPath = arrayEncoding.encode(key)
  935|      0|            return serialize(component, forKey: keyPath)
  936|      0|        }
  937|      0|        segments = alphabetizeKeyValuePairs ? segments.sorted() : segments
  938|      0|
  939|      0|        return segments.joinedWithAmpersands()
  940|      0|    }
  941|       |
  942|      0|    func escape(_ query: String) -> String {
  943|      0|        var allowedCharactersWithSpace = allowedCharacters
  944|      0|        allowedCharactersWithSpace.insert(charactersIn: " ")
  945|      0|        let escapedQuery = query.addingPercentEncoding(withAllowedCharacters: allowedCharactersWithSpace) ?? query
  946|      0|        let spaceEncodedQuery = spaceEncoding.encode(escapedQuery)
  947|      0|
  948|      0|        return spaceEncodedQuery
  949|      0|    }
  950|       |}
  951|       |
  952|       |extension Array where Element == String {
  953|      0|    func joinedWithAmpersands() -> String {
  954|      0|        joined(separator: "&")
  955|      0|    }
  956|       |}
  957|       |
  958|       |extension CharacterSet {
  959|       |    /// Creates a CharacterSet from RFC 3986 allowed characters.
  960|       |    ///
  961|       |    /// RFC 3986 states that the following characters are "reserved" characters.
  962|       |    ///
  963|       |    /// - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
  964|       |    /// - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
  965|       |    ///
  966|       |    /// In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
  967|       |    /// query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
  968|       |    /// should be percent-escaped in the query string.
  969|      0|    public static let afURLQueryAllowed: CharacterSet = {
  970|      0|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
  971|      0|        let subDelimitersToEncode = "!$&'()*+,;="
  972|      0|        let encodableDelimiters = CharacterSet(charactersIn: "\(generalDelimitersToEncode)\(subDelimitersToEncode)")
  973|      0|
  974|      0|        return CharacterSet.urlQueryAllowed.subtracting(encodableDelimiters)
  975|      0|    }()
  976|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/URLRequest+Alamofire.swift:
    1|       |//
    2|       |//  URLRequest+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2019 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension URLRequest {
   28|       |    /// Returns the `httpMethod` as Alamofire's `HTTPMethod` type.
   29|       |    public var method: HTTPMethod? {
   30|      0|        get { httpMethod.flatMap(HTTPMethod.init) }
   31|      0|        set { httpMethod = newValue?.rawValue }
   32|       |    }
   33|       |
   34|      0|    public func validate() throws {
   35|      0|        if method == .get, let bodyData = httpBody {
   36|      0|            throw AFError.urlRequestValidationFailed(reason: .bodyDataInGETRequest(bodyData))
   37|      0|        }
   38|      0|    }
   39|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/URLSessionConfiguration+Alamofire.swift:
    1|       |//
    2|       |//  URLSessionConfiguration+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension URLSessionConfiguration: AlamofireExtended {}
   28|       |extension AlamofireExtension where ExtendedType: URLSessionConfiguration {
   29|       |    /// Alamofire's default configuration. Same as `URLSessionConfiguration.default` but adds Alamofire default
   30|       |    /// `Accept-Language`, `Accept-Encoding`, and `User-Agent` headers.
   31|      0|    public static var `default`: URLSessionConfiguration {
   32|      0|        let configuration = URLSessionConfiguration.default
   33|      0|        configuration.headers = .default
   34|      0|
   35|      0|        return configuration
   36|      0|    }
   37|       |}

/Users/jeongkyunkim/Library/Developer/Xcode/DerivedData/watsup-cojekpvwilvrehaavzixvcgxazph/SourcePackages/checkouts/Alamofire/Source/Validation.swift:
    1|       |//
    2|       |//  Validation.swift
    3|       |//
    4|       |//  Copyright (c) 2014-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension Request {
   28|       |    // MARK: Helper Types
   29|       |
   30|       |    fileprivate typealias ErrorReason = AFError.ResponseValidationFailureReason
   31|       |
   32|       |    /// Used to represent whether a validation succeeded or failed.
   33|       |    public typealias ValidationResult = Result<Void, Error>
   34|       |
   35|       |    fileprivate struct MIMEType {
   36|       |        let type: String
   37|       |        let subtype: String
   38|       |
   39|      0|        var isWildcard: Bool { type == "*" && subtype == "*" }
   40|       |
   41|      0|        init?(_ string: String) {
   42|      0|            let components: [String] = {
   43|      0|                let stripped = string.trimmingCharacters(in: .whitespacesAndNewlines)
   44|      0|                let split = stripped[..<(stripped.range(of: ";")?.lowerBound ?? stripped.endIndex)]
   45|      0|
   46|      0|                return split.components(separatedBy: "/")
   47|      0|            }()
   48|      0|
   49|      0|            if let type = components.first, let subtype = components.last {
   50|      0|                self.type = type
   51|      0|                self.subtype = subtype
   52|      0|            } else {
   53|      0|                return nil
   54|      0|            }
   55|      0|        }
   56|       |
   57|      0|        func matches(_ mime: MIMEType) -> Bool {
   58|      0|            switch (type, subtype) {
   59|      0|            case (mime.type, mime.subtype), (mime.type, "*"), ("*", mime.subtype), ("*", "*"):
   60|      0|                return true
   61|      0|            default:
   62|      0|                return false
   63|      0|            }
   64|      0|        }
   65|       |    }
   66|       |
   67|       |    // MARK: Properties
   68|       |
   69|      0|    fileprivate var acceptableStatusCodes: Range<Int> { 200..<300 }
   70|       |
   71|      0|    fileprivate var acceptableContentTypes: [String] {
   72|      0|        if let accept = request?.value(forHTTPHeaderField: "Accept") {
   73|      0|            return accept.components(separatedBy: ",")
   74|      0|        }
   75|      0|
   76|      0|        return ["*/*"]
   77|      0|    }
   78|       |
   79|       |    // MARK: Status Code
   80|       |
   81|       |    fileprivate func validate<S: Sequence>(statusCode acceptableStatusCodes: S,
   82|       |                                           response: HTTPURLResponse)
   83|       |        -> ValidationResult
   84|      0|        where S.Iterator.Element == Int {
   85|      0|        if acceptableStatusCodes.contains(response.statusCode) {
   86|      0|            return .success(())
   87|      0|        } else {
   88|      0|            let reason: ErrorReason = .unacceptableStatusCode(code: response.statusCode)
   89|      0|            return .failure(AFError.responseValidationFailed(reason: reason))
   90|      0|        }
   91|      0|    }
   92|       |
   93|       |    // MARK: Content Type
   94|       |
   95|       |    fileprivate func validate<S: Sequence>(contentType acceptableContentTypes: S,
   96|       |                                           response: HTTPURLResponse,
   97|       |                                           data: Data?)
   98|       |        -> ValidationResult
   99|      0|        where S.Iterator.Element == String {
  100|      0|        guard let data = data, !data.isEmpty else { return .success(()) }
  101|      0|
  102|      0|        return validate(contentType: acceptableContentTypes, response: response)
  103|      0|    }
  104|       |
  105|       |    fileprivate func validate<S: Sequence>(contentType acceptableContentTypes: S,
  106|       |                                           response: HTTPURLResponse)
  107|       |        -> ValidationResult
  108|      0|        where S.Iterator.Element == String {
  109|      0|        guard
  110|      0|            let responseContentType = response.mimeType,
  111|      0|            let responseMIMEType = MIMEType(responseContentType)
  112|      0|        else {
  113|      0|            for contentType in acceptableContentTypes {
  114|      0|                if let mimeType = MIMEType(contentType), mimeType.isWildcard {
  115|      0|                    return .success(())
  116|      0|                }
  117|      0|            }
  118|      0|
  119|      0|            let error: AFError = {
  120|      0|                let reason: ErrorReason = .missingContentType(acceptableContentTypes: Array(acceptableContentTypes))
  121|      0|                return AFError.responseValidationFailed(reason: reason)
  122|      0|            }()
  123|      0|
  124|      0|            return .failure(error)
  125|      0|        }
  126|      0|
  127|      0|        for contentType in acceptableContentTypes {
  128|      0|            if let acceptableMIMEType = MIMEType(contentType), acceptableMIMEType.matches(responseMIMEType) {
  129|      0|                return .success(())
  130|      0|            }
  131|      0|        }
  132|      0|
  133|      0|        let error: AFError = {
  134|      0|            let reason: ErrorReason = .unacceptableContentType(acceptableContentTypes: Array(acceptableContentTypes),
  135|      0|                                                               responseContentType: responseContentType)
  136|      0|
  137|      0|            return AFError.responseValidationFailed(reason: reason)
  138|      0|        }()
  139|      0|
  140|      0|        return .failure(error)
  141|      0|    }
  142|       |}
  143|       |
  144|       |// MARK: -
  145|       |
  146|       |extension DataRequest {
  147|       |    /// A closure used to validate a request that takes a URL request, a URL response and data, and returns whether the
  148|       |    /// request was valid.
  149|       |    public typealias Validation = (URLRequest?, HTTPURLResponse, Data?) -> ValidationResult
  150|       |
  151|       |    /// Validates that the response has a status code in the specified sequence.
  152|       |    ///
  153|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  154|       |    ///
  155|       |    /// - Parameter statusCode: `Sequence` of acceptable response status codes.
  156|       |    ///
  157|       |    /// - Returns:              The instance.
  158|       |    @discardableResult
  159|      0|    public func validate<S: Sequence>(statusCode acceptableStatusCodes: S) -> Self where S.Iterator.Element == Int {
  160|      0|        validate { [unowned self] _, response, _ in
  161|      0|            self.validate(statusCode: acceptableStatusCodes, response: response)
  162|      0|        }
  163|      0|    }
  164|       |
  165|       |    /// Validates that the response has a content type in the specified sequence.
  166|       |    ///
  167|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  168|       |    ///
  169|       |    /// - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
  170|       |    ///
  171|       |    /// - returns: The request.
  172|       |    @discardableResult
  173|      0|    public func validate<S: Sequence>(contentType acceptableContentTypes: @escaping @autoclosure () -> S) -> Self where S.Iterator.Element == String {
  174|      0|        validate { [unowned self] _, response, data in
  175|      0|            self.validate(contentType: acceptableContentTypes(), response: response, data: data)
  176|      0|        }
  177|      0|    }
  178|       |
  179|       |    /// Validates that the response has a status code in the default acceptable range of 200...299, and that the content
  180|       |    /// type matches any specified in the Accept HTTP header field.
  181|       |    ///
  182|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  183|       |    ///
  184|       |    /// - returns: The request.
  185|       |    @discardableResult
  186|      0|    public func validate() -> Self {
  187|      0|        let contentTypes: () -> [String] = { [unowned self] in
  188|      0|            self.acceptableContentTypes
  189|      0|        }
  190|      0|        return validate(statusCode: acceptableStatusCodes).validate(contentType: contentTypes())
  191|      0|    }
  192|       |}
  193|       |
  194|       |extension DataStreamRequest {
  195|       |    /// A closure used to validate a request that takes a `URLRequest` and `HTTPURLResponse` and returns whether the
  196|       |    /// request was valid.
  197|       |    public typealias Validation = (_ request: URLRequest?, _ response: HTTPURLResponse) -> ValidationResult
  198|       |
  199|       |    /// Validates that the response has a status code in the specified sequence.
  200|       |    ///
  201|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  202|       |    ///
  203|       |    /// - Parameter statusCode: `Sequence` of acceptable response status codes.
  204|       |    ///
  205|       |    /// - Returns:              The instance.
  206|       |    @discardableResult
  207|      0|    public func validate<S: Sequence>(statusCode acceptableStatusCodes: S) -> Self where S.Iterator.Element == Int {
  208|      0|        validate { [unowned self] _, response in
  209|      0|            self.validate(statusCode: acceptableStatusCodes, response: response)
  210|      0|        }
  211|      0|    }
  212|       |
  213|       |    /// Validates that the response has a content type in the specified sequence.
  214|       |    ///
  215|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  216|       |    ///
  217|       |    /// - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
  218|       |    ///
  219|       |    /// - returns: The request.
  220|       |    @discardableResult
  221|      0|    public func validate<S: Sequence>(contentType acceptableContentTypes: @escaping @autoclosure () -> S) -> Self where S.Iterator.Element == String {
  222|      0|        validate { [unowned self] _, response in
  223|      0|            self.validate(contentType: acceptableContentTypes(), response: response)
  224|      0|        }
  225|      0|    }
  226|       |
  227|       |    /// Validates that the response has a status code in the default acceptable range of 200...299, and that the content
  228|       |    /// type matches any specified in the Accept HTTP header field.
  229|       |    ///
  230|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  231|       |    ///
  232|       |    /// - Returns: The instance.
  233|       |    @discardableResult
  234|      0|    public func validate() -> Self {
  235|      0|        let contentTypes: () -> [String] = { [unowned self] in
  236|      0|            self.acceptableContentTypes
  237|      0|        }
  238|      0|        return validate(statusCode: acceptableStatusCodes).validate(contentType: contentTypes())
  239|      0|    }
  240|       |}
  241|       |
  242|       |// MARK: -
  243|       |
  244|       |extension DownloadRequest {
  245|       |    /// A closure used to validate a request that takes a URL request, a URL response, a temporary URL and a
  246|       |    /// destination URL, and returns whether the request was valid.
  247|       |    public typealias Validation = (_ request: URLRequest?,
  248|       |                                   _ response: HTTPURLResponse,
  249|       |                                   _ fileURL: URL?)
  250|       |        -> ValidationResult
  251|       |
  252|       |    /// Validates that the response has a status code in the specified sequence.
  253|       |    ///
  254|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  255|       |    ///
  256|       |    /// - Parameter statusCode: `Sequence` of acceptable response status codes.
  257|       |    ///
  258|       |    /// - Returns:              The instance.
  259|       |    @discardableResult
  260|      0|    public func validate<S: Sequence>(statusCode acceptableStatusCodes: S) -> Self where S.Iterator.Element == Int {
  261|      0|        validate { [unowned self] _, response, _ in
  262|      0|            self.validate(statusCode: acceptableStatusCodes, response: response)
  263|      0|        }
  264|      0|    }
  265|       |
  266|       |    /// Validates that the response has a content type in the specified sequence.
  267|       |    ///
  268|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  269|       |    ///
  270|       |    /// - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
  271|       |    ///
  272|       |    /// - returns: The request.
  273|       |    @discardableResult
  274|      0|    public func validate<S: Sequence>(contentType acceptableContentTypes: @escaping @autoclosure () -> S) -> Self where S.Iterator.Element == String {
  275|      0|        validate { [unowned self] _, response, fileURL in
  276|      0|            guard let validFileURL = fileURL else {
  277|      0|                return .failure(AFError.responseValidationFailed(reason: .dataFileNil))
  278|      0|            }
  279|      0|
  280|      0|            do {
  281|      0|                let data = try Data(contentsOf: validFileURL)
  282|      0|                return self.validate(contentType: acceptableContentTypes(), response: response, data: data)
  283|      0|            } catch {
  284|      0|                return .failure(AFError.responseValidationFailed(reason: .dataFileReadFailed(at: validFileURL)))
  285|      0|            }
  286|      0|        }
  287|      0|    }
  288|       |
  289|       |    /// Validates that the response has a status code in the default acceptable range of 200...299, and that the content
  290|       |    /// type matches any specified in the Accept HTTP header field.
  291|       |    ///
  292|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  293|       |    ///
  294|       |    /// - returns: The request.
  295|       |    @discardableResult
  296|      0|    public func validate() -> Self {
  297|      0|        let contentTypes = { [unowned self] in
  298|      0|            self.acceptableContentTypes
  299|      0|        }
  300|      0|        return validate(statusCode: acceptableStatusCodes).validate(contentType: contentTypes())
  301|      0|    }
  302|       |}

